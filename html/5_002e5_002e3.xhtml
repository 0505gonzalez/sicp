<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Structure and Interpretation of Computer Programs, 2e: 5.5.3</title>

<meta name="description" content="Structure and Interpretation of Computer Programs, 2e: 5.5.3" />
<meta name="keywords" content="Structure and Interpretation of Computer Programs, 2e: 5.5.3" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="Generator" content="texi2any" />
<meta charset="utf-8" />
<link href="index.xhtml#Top" rel="start" title="Top" />
<link href="Term-Index.xhtml#Term-Index" rel="index" title="Term Index" />
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents" />
<link href="5_002e5.xhtml#g_t5_002e5" rel="prev" title="5.5" />
<link href="5_002e5_002e4.xhtml#g_t5_002e5_002e4" rel="next" title="5.5.4" />
<link href="5_002e5_002e2.xhtml#g_t5_002e5_002e2" rel="prev" title="5.5.2" />

<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />

<script src="js/jquery.min.js" type="text/javascript"></script>
<script src="js/footnotes.js" type="text/javascript"></script>
<script src="js/browsertest.js" type="text/javascript"></script>
</head>

<body>
<section><a id="g_t5_002e5_002e3"></a>
<nav class="header">
<p>
Next: <a href="5_002e5_002e4.xhtml#g_t5_002e5_002e4" accesskey="n" rel="next">5.5.4</a>, Previous: <a href="5_002e5_002e2.xhtml#g_t5_002e5_002e2" accesskey="p" rel="prev">5.5.2</a>, Up: <a href="5_002e5.xhtml#g_t5_002e5" accesskey="u" rel="prev">5.5</a>   [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>
<hr />

<a id="Compiling-Combinations"></a>
<h4 class="subsection"><span class="secnum">5.5.3</span><span class="sectitle">Compiling Combinations</span></h4>

<p>The essence of the compilation process is the compilation of procedure
applications.  The code for a combination compiled with a given target and
linkage has the form
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="pln">⟨</span><em><span class="pln">compilation of operator</span><span class="pun">,</span><span class="pln"> 
 target </span><code><span class="pln">proc</span></code><span class="pun">,</span><span class="pln"> linkage </span><code><span class="pln">next</span></code></em><span class="pln">⟩
⟨</span><em><span class="pln">evaluate operands </span><span class="kwd">and</span><span class="pln"> construct 
 argument list in </span><code><span class="pln">argl</span></code></em><span class="pln">⟩
⟨</span><em><span class="pln">compilation of procedure call 
 with given target </span><span class="kwd">and</span><span class="pln"> linkage</span></em><span class="pln">⟩</span></pre></div>

<p>The registers <code>env</code>, <code>proc</code>, and <code>argl</code> may have to be saved and
restored during evaluation of the operator and operands.  Note that this is the
only place in the compiler where a target other than <code>val</code> is specified.
</p>
<p>The required code is generated by <code>compile-application</code>.  This recursively
compiles the operator, to produce code that puts the procedure to be applied
into <code>proc</code>, and compiles the operands, to produce code that evaluates the
individual operands of the application.  The instruction sequences for the
operands are combined (by <code>construct-arglist</code>) with code that constructs
the list of arguments in <code>argl</code>, and the resulting argument-list code is
combined with the procedure code and the code that performs the procedure call
(produced by <code>compile-procedure-call</code>).  In appending the code sequences,
the <code>env</code> register must be preserved around the evaluation of the operator
(since evaluating the operator might modify <code>env</code>, which will be needed to
evaluate the operands), and the <code>proc</code> register must be preserved around
the construction of the argument list (since evaluating the operands might
modify <code>proc</code>, which will be needed for the actual procedure application).
<code>Continue</code> must also be preserved throughout, since it is needed for the
linkage in the procedure call.
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">compile-application 
         exp target linkage</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">let</span><span class="pln"> </span><span class="opn">((</span><span class="pln">proc-code 
         </span><span class="opn">(</span><span class="pln">compile </span><span class="opn">(</span><span class="pln">operator exp</span><span class="clo">)</span><span class="pln"> </span><span class="lit">'proc</span><span class="pln"> </span><span class="lit">'next</span><span class="clo">))</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">operand-codes
         </span><span class="opn">(</span><span class="pln">map </span><span class="opn">(</span><span class="kwd">lambda</span><span class="pln"> </span><span class="opn">(</span><span class="pln">operand</span><span class="clo">)</span><span class="pln">
                </span><span class="opn">(</span><span class="pln">compile operand </span><span class="lit">'val</span><span class="pln"> </span><span class="lit">'next</span><span class="clo">))</span><span class="pln">
              </span><span class="opn">(</span><span class="pln">operands exp</span><span class="clo">))))</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">preserving 
     </span><span class="lit">'</span><span class="opn">(</span><span class="pln">env continue</span><span class="clo">)</span><span class="pln">
     proc-code
     </span><span class="opn">(</span><span class="pln">preserving 
      </span><span class="lit">'</span><span class="opn">(</span><span class="pln">proc continue</span><span class="clo">)</span><span class="pln">
      </span><span class="opn">(</span><span class="pln">construct-arglist operand-codes</span><span class="clo">)</span><span class="pln">
      </span><span class="opn">(</span><span class="pln">compile-procedure-call 
       target
       linkage</span><span class="clo">)))))</span></pre></div>

<p>The code to construct the argument list will evaluate each operand into
<code>val</code> and then <code>cons</code> that value onto the argument list being
accumulated in <code>argl</code>.  Since we <code>cons</code> the arguments onto
<code>argl</code> in sequence, we must start with the last argument and end with the
first, so that the arguments will appear in order from first to last in the
resulting list.  Rather than waste an instruction by initializing <code>argl</code>
to the empty list to set up for this sequence of evaluations, we make the first
code sequence construct the initial <code>argl</code>.  The general form of the
argument-list construction is thus as follows:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="pln">⟨</span><em><span class="pln">compilation of last operand</span><span class="pun">,</span><span class="pln"> targeted to </span><code><span class="pln">val</span></code></em><span class="pln">⟩
</span><span class="opn">(</span><span class="pln">assign argl </span><span class="opn">(</span><span class="pln">op list</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">))</span><span class="pln">
⟨</span><em><span class="pln">compilation of next operand</span><span class="pun">,</span><span class="pln"> targeted to </span><code><span class="pln">val</span></code></em><span class="pln">⟩
</span><span class="opn">(</span><span class="pln">assign argl </span><span class="opn">(</span><span class="pln">op </span><span class="kwd">cons</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">reg argl</span><span class="clo">))</span><span class="pln">
</span><span class="roman"><span class="pun">…</span></span><span class="pln">
⟨</span><em><span class="pln">compilation of first operand</span><span class="pun">,</span><span class="pln"> targeted to </span><code><span class="pln">val</span></code></em><span class="pln">⟩
</span><span class="opn">(</span><span class="pln">assign argl </span><span class="opn">(</span><span class="pln">op </span><span class="kwd">cons</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">reg argl</span><span class="clo">))</span></pre></div>

<p><code>Argl</code> must be preserved around each operand evaluation except the first
(so that arguments accumulated so far won’t be lost), and <code>env</code> must be
preserved around each operand evaluation except the last (for use by subsequent
operand evaluations).
</p>
<p>Compiling this argument code is a bit tricky, because of the special treatment
of the first operand to be evaluated and the need to preserve <code>argl</code> and
<code>env</code> in different places.  The <code>construct-arglist</code> procedure takes
as arguments the code that evaluates the individual operands.  If there are no
operands at all, it simply emits the instruction
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="pln">assign argl </span><span class="opn">(</span><span class="pln">const </span><span class="opn">(</span><span class="clo">)))</span></pre></div>

<p>Otherwise, <code>construct-arglist</code> creates code that initializes <code>argl</code>
with the last argument, and appends code that evaluates the rest of the
arguments and adjoins them to <code>argl</code> in succession.  In order to process
the arguments from last to first, we must reverse the list of operand code
sequences from the order supplied by <code>compile-application</code>.
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">construct-arglist operand-codes</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">let</span><span class="pln"> </span><span class="opn">((</span><span class="pln">operand-codes 
         </span><span class="opn">(</span><span class="pln">reverse operand-codes</span><span class="clo">)))</span><span class="pln">
    </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> </span><span class="opn">(</span><span class="pln">null? operand-codes</span><span class="clo">)</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">make-instruction-sequence 
         </span><span class="lit">'</span><span class="opn">(</span><span class="clo">)</span><span class="pln"> 
         </span><span class="lit">'</span><span class="opn">(</span><span class="pln">argl</span><span class="clo">)</span><span class="pln">
         </span><span class="lit">'</span><span class="opn">((</span><span class="pln">assign argl </span><span class="opn">(</span><span class="pln">const </span><span class="opn">(</span><span class="clo">)))))</span><span class="pln">
        </span><span class="opn">(</span><span class="kwd">let</span><span class="pln"> </span><span class="opn">((</span><span class="pln">code-to-get-last-arg
               </span><span class="opn">(</span><span class="pln">append-instruction-sequences
                </span><span class="opn">(</span><span class="kwd">car</span><span class="pln"> operand-codes</span><span class="clo">)</span><span class="pln">
                </span><span class="opn">(</span><span class="pln">make-instruction-sequence 
                 </span><span class="lit">'</span><span class="opn">(</span><span class="pln">val</span><span class="clo">)</span><span class="pln">
                 </span><span class="lit">'</span><span class="opn">(</span><span class="pln">argl</span><span class="clo">)</span><span class="pln">
                 </span><span class="lit">'</span><span class="opn">((</span><span class="pln">assign argl
                           </span><span class="opn">(</span><span class="pln">op list</span><span class="clo">)</span><span class="pln">
                           </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">)))))))</span><span class="pln">
          </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> </span><span class="opn">(</span><span class="pln">null? </span><span class="opn">(</span><span class="kwd">cdr</span><span class="pln"> operand-codes</span><span class="clo">))</span><span class="pln">
              code-to-get-last-arg
              </span><span class="opn">(</span><span class="pln">preserving 
               </span><span class="lit">'</span><span class="opn">(</span><span class="pln">env</span><span class="clo">)</span><span class="pln">
               code-to-get-last-arg
               </span><span class="opn">(</span><span class="pln">code-to-get-rest-args
                </span><span class="opn">(</span><span class="kwd">cdr</span><span class="pln"> operand-codes</span><span class="clo">))))))))</span><span class="pln">

</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">code-to-get-rest-args operand-codes</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">let</span><span class="pln"> </span><span class="opn">((</span><span class="pln">code-for-next-arg
         </span><span class="opn">(</span><span class="pln">preserving 
          </span><span class="lit">'</span><span class="opn">(</span><span class="pln">argl</span><span class="clo">)</span><span class="pln">
          </span><span class="opn">(</span><span class="kwd">car</span><span class="pln"> operand-codes</span><span class="clo">)</span><span class="pln">
          </span><span class="opn">(</span><span class="pln">make-instruction-sequence 
           </span><span class="lit">'</span><span class="opn">(</span><span class="pln">val argl</span><span class="clo">)</span><span class="pln">
           </span><span class="lit">'</span><span class="opn">(</span><span class="pln">argl</span><span class="clo">)</span><span class="pln">
           </span><span class="lit">'</span><span class="opn">((</span><span class="pln">assign argl
                     </span><span class="opn">(</span><span class="pln">op </span><span class="kwd">cons</span><span class="clo">)</span><span class="pln">
                     </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">)</span><span class="pln">
                     </span><span class="opn">(</span><span class="pln">reg argl</span><span class="clo">)))))))</span><span class="pln">
    </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> </span><span class="opn">(</span><span class="pln">null? </span><span class="opn">(</span><span class="kwd">cdr</span><span class="pln"> operand-codes</span><span class="clo">))</span><span class="pln">
        code-for-next-arg
        </span><span class="opn">(</span><span class="pln">preserving 
         </span><span class="lit">'</span><span class="opn">(</span><span class="pln">env</span><span class="clo">)</span><span class="pln">
         code-for-next-arg
         </span><span class="opn">(</span><span class="pln">code-to-get-rest-args 
          </span><span class="opn">(</span><span class="kwd">cdr</span><span class="pln"> operand-codes</span><span class="clo">))))))</span></pre></div>

<a id="Applying-procedures"></a>
<h5 class="subsubheading">Applying procedures</h5>

<p>After evaluating the elements of a combination, the compiled code must apply
the procedure in <code>proc</code> to the arguments in <code>argl</code>.  The code
performs essentially the same dispatch as the <code>apply</code> procedure in the
metacircular evaluator of <a href="4_002e1_002e1.xhtml#g_t4_002e1_002e1">4.1.1</a> or the <code>apply-dispatch</code>
entry point in the explicit-control evaluator of <a href="5_002e4_002e1.xhtml#g_t5_002e4_002e1">5.4.1</a>.  It
checks whether the procedure to be applied is a primitive procedure or a
compiled procedure.  For a primitive procedure, it uses
<code>apply-primitive-procedure</code>; we will see shortly how it handles compiled
procedures.  The procedure-application code has the following form:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="pln">test </span><span class="opn">(</span><span class="pln">op primitive-procedure?</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">))</span><span class="pln">
 </span><span class="opn">(</span><span class="pln">branch </span><span class="opn">(</span><span class="pln">label primitive-branch</span><span class="clo">))</span><span class="pln">
compiled-branch
 ⟨</span><em><span class="pln">code to apply compiled procedure 
  with given target </span><span class="kwd">and</span><span class="pln"> appropriate linkage</span></em><span class="pln">⟩
primitive-branch
 </span><span class="opn">(</span><span class="pln">assign ⟨</span><var><span class="pln">target</span></var><span class="pln">⟩
         </span><span class="opn">(</span><span class="pln">op apply-primitive-procedure</span><span class="clo">)</span><span class="pln">
         </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">)</span><span class="pln">
         </span><span class="opn">(</span><span class="pln">reg argl</span><span class="clo">))</span><span class="pln">
 ⟨</span><var><span class="pln">linkage</span></var><span class="pln">⟩
after-call</span></pre></div>

<p>Observe that the compiled branch must skip around the primitive branch.
Therefore, if the linkage for the original procedure call was <code>next</code>, the
compound branch must use a linkage that jumps to a label that is inserted after
the primitive branch.  (This is similar to the linkage used for the true branch
in <code>compile-if</code>.)
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">compile-procedure-call
         target linkage</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">let</span><span class="pln"> </span><span class="opn">((</span><span class="pln">primitive-branch 
         </span><span class="opn">(</span><span class="pln">make-label </span><span class="lit">'primitive-branch</span><span class="clo">))</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">compiled-branch 
         </span><span class="opn">(</span><span class="pln">make-label </span><span class="lit">'compiled-branch</span><span class="clo">))</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">after-call
         </span><span class="opn">(</span><span class="pln">make-label </span><span class="lit">'after-call</span><span class="clo">)))</span><span class="pln">
    </span><span class="opn">(</span><span class="kwd">let</span><span class="pln"> </span><span class="opn">((</span><span class="pln">compiled-linkage
           </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> </span><span class="opn">(</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> linkage </span><span class="lit">'next</span><span class="clo">)</span><span class="pln">
               after-call
               linkage</span><span class="clo">)))</span><span class="pln">
      </span><span class="opn">(</span><span class="pln">append-instruction-sequences
       </span><span class="opn">(</span><span class="pln">make-instruction-sequence 
        </span><span class="lit">'</span><span class="opn">(</span><span class="pln">proc</span><span class="clo">)</span><span class="pln">
        </span><span class="lit">'</span><span class="opn">(</span><span class="clo">)</span><span class="pln">
        </span><span class="pun">`</span><span class="opn">((</span><span class="pln">test 
           </span><span class="opn">(</span><span class="pln">op primitive-procedure?</span><span class="clo">)</span><span class="pln">
           </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">))</span><span class="pln">
          </span><span class="opn">(</span><span class="pln">branch 
           </span><span class="opn">(</span><span class="pln">label </span><span class="pun">,</span><span class="pln">primitive-branch</span><span class="clo">))))</span><span class="pln">
       </span><span class="opn">(</span><span class="pln">parallel-instruction-sequences
        </span><span class="opn">(</span><span class="pln">append-instruction-sequences
         compiled-branch
         </span><span class="opn">(</span><span class="pln">compile-proc-appl 
          target
          compiled-linkage</span><span class="clo">))</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">append-instruction-sequences
         primitive-branch
         </span><span class="opn">(</span><span class="pln">end-with-linkage
          linkage
          </span><span class="opn">(</span><span class="pln">make-instruction-sequence
           </span><span class="lit">'</span><span class="opn">(</span><span class="pln">proc argl</span><span class="clo">)</span><span class="pln">
           </span><span class="opn">(</span><span class="pln">list target</span><span class="clo">)</span><span class="pln">
           </span><span class="pun">`</span><span class="opn">((</span><span class="pln">assign 
              </span><span class="pun">,</span><span class="pln">target
              </span><span class="opn">(</span><span class="pln">op apply-primitive-procedure</span><span class="clo">)</span><span class="pln">
              </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">)</span><span class="pln">
              </span><span class="opn">(</span><span class="pln">reg argl</span><span class="clo">)))))))</span><span class="pln">
       after-call</span><span class="clo">))))</span></pre></div>

<p>The primitive and compound branches, like the true and false branches in
<code>compile-if</code>, are appended using <code>parallel-instruction-sequences</code>
rather than the ordinary <code>append-instruction-sequences</code>, because they will
not be executed sequentially.
</p>
<a id="Applying-compiled-procedures"></a>
<h5 class="subsubheading">Applying compiled procedures</h5>

<p>The code that handles procedure application is the most subtle part of the
compiler, even though the instruction sequences it generates are very short.  A
compiled procedure (as constructed by <code>compile-lambda</code>) has an entry
point, which is a label that designates where the code for the procedure
starts.  The code at this entry point computes a result in <code>val</code> and
returns by executing the instruction <code>(goto (reg continue))</code>.  Thus, we
might expect the code for a compiled-procedure application (to be generated by
<code>compile-proc-appl</code>) with a given target and linkage to look like this if
the linkage is a label
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="pln">assign continue 
        </span><span class="opn">(</span><span class="pln">label proc-return</span><span class="clo">))</span><span class="pln">
 </span><span class="opn">(</span><span class="pln">assign val
         </span><span class="opn">(</span><span class="pln">op compiled-procedure-entry</span><span class="clo">)</span><span class="pln">
         </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">))</span><span class="pln">
 </span><span class="opn">(</span><span class="pln">goto </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">))</span><span class="pln">
proc-return
 </span><span class="opn">(</span><span class="pln">assign ⟨</span><var><span class="pln">target</span></var><span class="pln">⟩ 
         </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">))</span><span class="pln">   </span><span class="roman"><span class="com">; included if target is not </span><code><span class="com">val</span></code></span><span class="pln">
 </span><span class="opn">(</span><span class="pln">goto </span><span class="opn">(</span><span class="pln">label ⟨</span><var><span class="pln">linkage</span></var><span class="pln">⟩</span><span class="clo">))</span><span class="pln">   </span><span class="roman"><span class="com">; linkage code</span></span>
</pre></div>

<p>or like this if the linkage is <code>return</code>.
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="pln">save continue</span><span class="clo">)</span><span class="pln">
 </span><span class="opn">(</span><span class="pln">assign continue 
         </span><span class="opn">(</span><span class="pln">label proc-return</span><span class="clo">))</span><span class="pln">
 </span><span class="opn">(</span><span class="pln">assign val 
         </span><span class="opn">(</span><span class="pln">op compiled-procedure-entry</span><span class="clo">)</span><span class="pln">
         </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">))</span><span class="pln">
 </span><span class="opn">(</span><span class="pln">goto </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">))</span><span class="pln">
proc-return
 </span><span class="opn">(</span><span class="pln">assign ⟨</span><var><span class="pln">target</span></var><span class="pln">⟩
         </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">))</span><span class="pln">   </span><span class="roman"><span class="com">; included if target is not </span><code><span class="com">val</span></code></span><span class="pln">
 </span><span class="opn">(</span><span class="pln">restore continue</span><span class="clo">)</span><span class="pln">
 </span><span class="opn">(</span><span class="pln">goto </span><span class="opn">(</span><span class="pln">reg continue</span><span class="clo">))</span><span class="pln">   </span><span class="roman"><span class="com">; linkage code</span></span>
</pre></div>

<p>This code sets up <code>continue</code> so that the procedure will return to a label
<code>proc-return</code> and jumps to the procedure’s entry point.  The code at
<code>proc-return</code> transfers the procedure’s result from <code>val</code> to the
target register (if necessary) and then jumps to the location specified by the
linkage.  (The linkage is always <code>return</code> or a label, because
<code>compile-procedure-call</code> replaces a <code>next</code> linkage for the
compound-procedure branch by an <code>after-call</code> label.)
</p>
<p>In fact, if the target is not <code>val</code>, that is exactly the code our compiler
will generate.<a class="footnote_link" id="DOCF324" href="#FOOT324"><sup>324</sup></a>  Usually, however, the target is
<code>val</code> (the only time the compiler specifies a different register is when
targeting the evaluation of an operator to <code>proc</code>), so the procedure
result is put directly into the target register and there is no need to return
to a special location that copies it.  Instead, we simplify the code by setting
up <code>continue</code> so that the procedure will “return” directly to the place
specified by the caller’s linkage:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="pln">⟨</span><em><span class="kwd">set</span><span class="pln"> up </span><code><span class="pln">continue</span></code><span class="pln"> for linkage</span></em><span class="pln">⟩
</span><span class="opn">(</span><span class="pln">assign val 
        </span><span class="opn">(</span><span class="pln">op compiled-procedure-entry</span><span class="clo">)</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="pln">goto </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">))</span></pre></div>

<p>If the linkage is a label, we set up <code>continue</code> so that the procedure will
return to that label.  (That is, the <code>(goto (reg continue))</code> the procedure
ends with becomes equivalent to the <code>(goto (label ⟨<var>linkage</var>⟩))</code> at
<code>proc-return</code> above.)
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="pln">assign continue 
        </span><span class="opn">(</span><span class="pln">label ⟨</span><var><span class="pln">linkage</span></var><span class="pln">⟩</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="pln">assign val
        </span><span class="opn">(</span><span class="pln">op compiled-procedure-entry</span><span class="clo">)</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="pln">goto </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">))</span></pre></div>

<p>If the linkage is <code>return</code>, we don’t need to set up <code>continue</code> at
all: It already holds the desired location.  (That is, the <code>(goto (reg
continue))</code> the procedure ends with goes directly to the place where the
<code>(goto (reg continue))</code> at <code>proc-return</code> would have gone.)
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="pln">assign val
        </span><span class="opn">(</span><span class="pln">op compiled-procedure-entry</span><span class="clo">)</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="pln">goto </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">))</span></pre></div>

<p>With this implementation of the <code>return</code> linkage, the compiler generates
tail-recursive code.  Calling a procedure as the final step in a procedure body
does a direct transfer, without saving any information on the stack.
</p>
<p>Suppose instead that we had handled the case of a procedure call with a linkage
of <code>return</code> and a target of <code>val</code> as shown above for a non-<code>val</code>
target.  This would destroy tail recursion.  Our system would still give the
same value for any expression.  But each time we called a procedure, we would
save <code>continue</code> and return after the call to undo the (useless) save.
These extra saves would accumulate during a nest of procedure
calls.<a class="footnote_link" id="DOCF325" href="#FOOT325"><sup>325</sup></a>
</p>
<p><code>Compile-proc-appl</code> generates the above procedure-application code by
considering four cases, depending on whether the target for the call is
<code>val</code> and whether the linkage is <code>return</code>.  Observe that the
instruction sequences are declared to modify all the registers, since executing
the procedure body can change the registers in arbitrary ways.<a class="footnote_link" id="DOCF326" href="#FOOT326"><sup>326</sup></a>
Also note that the code sequence for the case with target <code>val</code> and
linkage <code>return</code> is declared to need <code>continue</code>: Even though
<code>continue</code> is not explicitly used in the two-instruction sequence, we must
be sure that <code>continue</code> will have the correct value when we enter the
compiled procedure.
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">compile-proc-appl target linkage</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">cond</span><span class="pln"> </span><span class="opn">((</span><span class="kwd">and</span><span class="pln"> </span><span class="opn">(</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> target </span><span class="lit">'val</span><span class="clo">)</span><span class="pln">
              </span><span class="opn">(</span><span class="pln">not </span><span class="opn">(</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> linkage </span><span class="lit">'return</span><span class="clo">)))</span><span class="pln">
         </span><span class="opn">(</span><span class="pln">make-instruction-sequence 
          </span><span class="lit">'</span><span class="opn">(</span><span class="pln">proc</span><span class="clo">)</span><span class="pln">
          all-regs
          </span><span class="pun">`</span><span class="opn">((</span><span class="pln">assign continue </span><span class="opn">(</span><span class="pln">label </span><span class="pun">,</span><span class="pln">linkage</span><span class="clo">))</span><span class="pln">
            </span><span class="opn">(</span><span class="pln">assign 
             val 
             </span><span class="opn">(</span><span class="pln">op compiled-procedure-entry</span><span class="clo">)</span><span class="pln">
             </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">))</span><span class="pln">
            </span><span class="opn">(</span><span class="pln">goto </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">)))))</span><span class="pln">
        </span><span class="opn">((</span><span class="kwd">and</span><span class="pln"> </span><span class="opn">(</span><span class="pln">not </span><span class="opn">(</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> target </span><span class="lit">'val</span><span class="clo">))</span><span class="pln">
              </span><span class="opn">(</span><span class="pln">not </span><span class="opn">(</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> linkage </span><span class="lit">'return</span><span class="clo">)))</span><span class="pln">
         </span><span class="opn">(</span><span class="kwd">let</span><span class="pln"> </span><span class="opn">((</span><span class="pln">proc-return 
                </span><span class="opn">(</span><span class="pln">make-label </span><span class="lit">'proc-return</span><span class="clo">)))</span><span class="pln">
           </span><span class="opn">(</span><span class="pln">make-instruction-sequence 
            </span><span class="lit">'</span><span class="opn">(</span><span class="pln">proc</span><span class="clo">)</span><span class="pln">
            all-regs
            </span><span class="pun">`</span><span class="opn">((</span><span class="pln">assign continue 
                      </span><span class="opn">(</span><span class="pln">label </span><span class="pun">,</span><span class="pln">proc-return</span><span class="clo">))</span><span class="pln">
              </span><span class="opn">(</span><span class="pln">assign 
               val 
               </span><span class="opn">(</span><span class="pln">op compiled-procedure-entry</span><span class="clo">)</span><span class="pln">
               </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">))</span><span class="pln">
              </span><span class="opn">(</span><span class="pln">goto </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">))</span><span class="pln">
              </span><span class="pun">,</span><span class="pln">proc-return
              </span><span class="opn">(</span><span class="pln">assign </span><span class="pun">,</span><span class="pln">target </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">))</span><span class="pln">
              </span><span class="opn">(</span><span class="pln">goto </span><span class="opn">(</span><span class="pln">label </span><span class="pun">,</span><span class="pln">linkage</span><span class="clo">))))))</span><span class="pln">
        </span><span class="opn">((</span><span class="kwd">and</span><span class="pln"> </span><span class="opn">(</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> target </span><span class="lit">'val</span><span class="clo">)</span><span class="pln">
              </span><span class="opn">(</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> linkage </span><span class="lit">'return</span><span class="clo">))</span><span class="pln">
         </span><span class="opn">(</span><span class="pln">make-instruction-sequence 
          </span><span class="lit">'</span><span class="opn">(</span><span class="pln">proc continue</span><span class="clo">)</span><span class="pln"> 
          all-regs
          </span><span class="lit">'</span><span class="opn">((</span><span class="pln">assign 
             val 
             </span><span class="opn">(</span><span class="pln">op compiled-procedure-entry</span><span class="clo">)</span><span class="pln">
             </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">))</span><span class="pln">
            </span><span class="opn">(</span><span class="pln">goto </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">)))))</span><span class="pln">
        </span><span class="opn">((</span><span class="kwd">and</span><span class="pln"> </span><span class="opn">(</span><span class="pln">not </span><span class="opn">(</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> target </span><span class="lit">'val</span><span class="clo">))</span><span class="pln">
              </span><span class="opn">(</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> linkage </span><span class="lit">'return</span><span class="clo">))</span><span class="pln">
         </span><span class="opn">(</span><span class="err">error</span><span class="pln"> </span><span class="str">"return linkage, 
                 target not val: COMPILE"</span><span class="pln">
                target</span><span class="clo">))))</span></pre></div>

<div class="footnote">
<hr />

<h4 class="footnotes-heading">Footnotes</h4>

<div id="FOOT324"><p><a class="footnote_backlink" href="#DOCF324"><sup>324</sup></a>
Actually, we signal an error when the target is not
<code>val</code> and the linkage is <code>return</code>, since the only place we request
<code>return</code> linkages is in compiling procedures, and our convention is that
procedures return their values in <code>val</code>.</p>
</div>
<div id="FOOT325"><p><a class="footnote_backlink" href="#DOCF325"><sup>325</sup></a>
Making a compiler generate tail-recursive code might seem like
a straightforward idea.  But most compilers for common languages, including C
and Pascal, do not do this, and therefore these languages cannot represent
iterative processes in terms of procedure call alone.  The difficulty with tail
recursion in these languages is that their implementations use the stack to
store procedure arguments and local variables as well as return addresses.  The
Scheme implementations described in this book store arguments and variables in
memory to be garbage-collected.  The reason for using the stack for variables
and arguments is that it avoids the need for garbage collection in languages
that would not otherwise require it, and is generally believed to be more
efficient.  Sophisticated Lisp compilers can, in fact, use the stack for
arguments without destroying tail recursion.  (See <a href="References.xhtml#Hanson-1990">Hanson 1990</a> for a
description.)  There is also some debate about whether stack allocation is
actually more efficient than garbage collection in the first place, but the
details seem to hinge on fine points of computer architecture.  (See <a href="References.xhtml#Appel-1987">Appel 1987</a>
and <a href="References.xhtml#Miller-and-Rozas-1994">Miller and Rozas 1994</a> for opposing views on this issue.)</p>
</div>
<div id="FOOT326"><p><a class="footnote_backlink" href="#DOCF326"><sup>326</sup></a>
The
variable <code>all-regs</code> is bound to the list of names of all the registers:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> all-regs </span><span class="lit">'</span><span class="opn">(</span><span class="pln">env proc val argl continue</span><span class="clo">))</span></pre></div>
</div>
</div>
<hr />
<nav class="header">
<p>
Next: <a href="5_002e5_002e4.xhtml#g_t5_002e5_002e4" accesskey="n" rel="next">5.5.4</a>, Previous: <a href="5_002e5_002e2.xhtml#g_t5_002e5_002e2" accesskey="p" rel="prev">5.5.2</a>, Up: <a href="5_002e5.xhtml#g_t5_002e5" accesskey="u" rel="prev">5.5</a>   [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>


</section>
</body>
</html>