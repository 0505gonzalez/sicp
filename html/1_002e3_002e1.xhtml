<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Structure and Interpretation of Computer Programs, 2e: 1.3.1</title>

<meta name="description" content="Structure and Interpretation of Computer Programs, 2e: 1.3.1" />
<meta name="keywords" content="Structure and Interpretation of Computer Programs, 2e: 1.3.1" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="Generator" content="texi2any" />
<meta charset="utf-8" />
<link href="index.xhtml#Top" rel="start" title="Top" />
<link href="Term-Index.xhtml#Term-Index" rel="index" title="Term Index" />
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents" />
<link href="1_002e3.xhtml#g_t1_002e3" rel="prev" title="1.3" />
<link href="1_002e3_002e2.xhtml#g_t1_002e3_002e2" rel="next" title="1.3.2" />
<link href="1_002e3.xhtml#g_t1_002e3" rel="prev" title="1.3" />

<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />

<script src="js/jquery.min.js" type="text/javascript"></script>
<script src="js/footnotes.js" type="text/javascript"></script>
<script src="js/browsertest.js" type="text/javascript"></script>
</head>

<body>
<section><a id="g_t1_002e3_002e1"></a>
<nav class="header">
<p>
Next: <a href="1_002e3_002e2.xhtml#g_t1_002e3_002e2" accesskey="n" rel="next">1.3.2</a>, Previous: <a href="1_002e3.xhtml#g_t1_002e3" accesskey="p" rel="prev">1.3</a>, Up: <a href="1_002e3.xhtml#g_t1_002e3" accesskey="u" rel="prev">1.3</a>   [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>
<hr />

<a id="Procedures-as-Arguments"></a>
<h4 class="subsection"><span class="secnum">1.3.1</span><span class="sectitle">Procedures as Arguments</span></h4>

<p>Consider the following three procedures.  The first computes the sum of the
integers from <code>a</code> through <code>b</code>:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">sum-integers a b</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> </span><span class="opn">(</span><span class="pun">&gt;</span><span class="pln"> a b</span><span class="clo">)</span><span class="pln"> 
      </span><span class="lit">0</span><span class="pln"> 
      </span><span class="opn">(</span><span class="pun">+</span><span class="pln"> a </span><span class="opn">(</span><span class="pln">sum-integers </span><span class="opn">(</span><span class="pun">+</span><span class="pln"> a </span><span class="lit">1</span><span class="clo">)</span><span class="pln"> b</span><span class="clo">))))</span></pre></div>

<p>The second computes the sum of the cubes of the integers in the given range:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">sum-cubes a b</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> </span><span class="opn">(</span><span class="pun">&gt;</span><span class="pln"> a b</span><span class="clo">)</span><span class="pln"> 
      </span><span class="lit">0</span><span class="pln"> 
      </span><span class="opn">(</span><span class="pun">+</span><span class="pln"> </span><span class="opn">(</span><span class="pln">cube a</span><span class="clo">)</span><span class="pln"> 
         </span><span class="opn">(</span><span class="pln">sum-cubes </span><span class="opn">(</span><span class="pun">+</span><span class="pln"> a </span><span class="lit">1</span><span class="clo">)</span><span class="pln"> b</span><span class="clo">))))</span></pre></div>

<p>The third computes the sum of a sequence of terms in the series

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mfrac>
    <mn>1</mn>
    <mrow>
      <mn>1</mn>
      <mo>⋅<!-- ⋅ --></mo>
      <mn>3</mn>
    </mrow>
  </mfrac>
  <mo>+</mo>
  <mfrac>
    <mn>1</mn>
    <mrow>
      <mn>5</mn>
      <mo>⋅<!-- ⋅ --></mo>
      <mn>7</mn>
    </mrow>
  </mfrac>
  <mo>+</mo>
  <mfrac>
    <mn>1</mn>
    <mrow>
      <mn>9</mn>
      <mo>⋅<!-- ⋅ --></mo>
      <mn>11</mn>
    </mrow>
  </mfrac>
  <mo>+</mo>
  <mrow class="MJX-TeXAtom-ORD">
    <mo>…<!-- … --></mo>
    <mo>,</mo>
  </mrow>
</math>

which converges to <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mi>π<!-- π --></mi>
    <mrow class="MJX-TeXAtom-ORD">
      <mo>/</mo>
    </mrow>
    <mn>8</mn>
  </mrow>
</math> (very slowly):<a class="footnote_link" id="DOCF49" href="#FOOT49"><sup>49</sup></a>
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">pi-sum a b</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> </span><span class="opn">(</span><span class="pun">&gt;</span><span class="pln"> a b</span><span class="clo">)</span><span class="pln">
      </span><span class="lit">0</span><span class="pln">
      </span><span class="opn">(</span><span class="pun">+</span><span class="pln"> </span><span class="opn">(</span><span class="pun">/</span><span class="pln"> </span><span class="lit">1.0</span><span class="pln"> </span><span class="opn">(</span><span class="pun">*</span><span class="pln"> a </span><span class="opn">(</span><span class="pun">+</span><span class="pln"> a </span><span class="lit">2</span><span class="clo">)))</span><span class="pln"> 
         </span><span class="opn">(</span><span class="pln">pi-sum </span><span class="opn">(</span><span class="pun">+</span><span class="pln"> a </span><span class="lit">4</span><span class="clo">)</span><span class="pln"> b</span><span class="clo">))))</span></pre></div>

<p>These three procedures clearly share a common underlying pattern.  They are for
the most part identical, differing only in the name of the procedure, the
function of <code>a</code> used to compute the term to be added, and the function
that provides the next value of <code>a</code>.  We could generate each of the
procedures by filling in slots in the same template:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">⟨</span><var><span class="pln">name</span></var><span class="pln">⟩ a b</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> </span><span class="opn">(</span><span class="pun">&gt;</span><span class="pln"> a b</span><span class="clo">)</span><span class="pln">
      </span><span class="lit">0</span><span class="pln">
      </span><span class="opn">(</span><span class="pun">+</span><span class="pln"> </span><span class="opn">(</span><span class="pln">⟨</span><var><span class="pln">term</span></var><span class="pln">⟩ a</span><span class="clo">)</span><span class="pln"> 
         </span><span class="opn">(</span><span class="pln">⟨</span><var><span class="pln">name</span></var><span class="pln">⟩ </span><span class="opn">(</span><span class="pln">⟨</span><var><span class="pln">next</span></var><span class="pln">⟩ a</span><span class="clo">)</span><span class="pln"> b</span><span class="clo">))))</span></pre></div>

<p>The presence of such a common pattern is strong evidence that there is a useful
abstraction waiting to be brought to the surface.  Indeed, mathematicians long
ago identified the abstraction of <a id="index-summation-of-a-series"></a>
<em>summation of a series</em> and invented
“sigma notation,” for example

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mrow class="MJX-TeXAtom-ORD">
    <munderover>
      <mo>∑<!-- ∑ --></mo>
      <mrow class="MJX-TeXAtom-ORD">
        <mi>n</mi>
        <mo>=</mo>
        <mi>a</mi>
      </mrow>
      <mi>b</mi>
    </munderover>
    <mi>f</mi>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
  </mrow>
  <mspace width="thinmathspace"/>
  <mo>=</mo>
  <mspace width="thinmathspace"/>
  <mrow class="MJX-TeXAtom-ORD">
    <mi>f</mi>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
  </mrow>
  <mo>+</mo>
  <mo>⋯<!-- ⋯ --></mo>
  <mo>+</mo>
  <mrow class="MJX-TeXAtom-ORD">
    <mi>f</mi>
    <mo stretchy="false">(</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
    <mo>,</mo>
  </mrow>
</math>

to express this concept.  The power of sigma notation is that it allows
mathematicians to deal with the concept of summation itself rather than only
with particular sums—for example, to formulate general results about sums
that are independent of the particular series being summed.
</p>
<p>Similarly, as program designers, we would like our language to be powerful
enough so that we can write a procedure that expresses the concept of summation
itself rather than only procedures that compute particular sums.  We can do so
readily in our procedural language by taking the common template shown above
and transforming the “slots” into formal parameters:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">sum term a next b</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> </span><span class="opn">(</span><span class="pun">&gt;</span><span class="pln"> a b</span><span class="clo">)</span><span class="pln">
      </span><span class="lit">0</span><span class="pln">
      </span><span class="opn">(</span><span class="pun">+</span><span class="pln"> </span><span class="opn">(</span><span class="pln">term a</span><span class="clo">)</span><span class="pln">
         </span><span class="opn">(</span><span class="pln">sum term </span><span class="opn">(</span><span class="pln">next a</span><span class="clo">)</span><span class="pln"> next b</span><span class="clo">))))</span></pre></div>

<p>Notice that <code>sum</code> takes as its arguments the lower and upper bounds
<code>a</code> and <code>b</code> together with the procedures <code>term</code> and <code>next</code>.
We can use <code>sum</code> just as we would any procedure.  For example, we can use
it (along with a procedure <code>inc</code> that increments its argument by 1) to
define <code>sum-cubes</code>:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">inc n</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pun">+</span><span class="pln"> n </span><span class="lit">1</span><span class="clo">))</span><span class="pln">

</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">sum-cubes a b</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">sum cube a inc b</span><span class="clo">))</span></pre></div>

<p>Using this, we can compute the sum of the cubes of the integers from 1 to 10:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="pln">sum-cubes </span><span class="lit">1</span><span class="pln"> </span><span class="lit">10</span><span class="clo">)</span><span class="pln">
</span><i><span class="lit">3025</span></i>
</pre></div>

<p>With the aid of an identity procedure to compute the term, we can define
<code>sum-integers</code> in terms of <code>sum</code>:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">identity x</span><span class="clo">)</span><span class="pln"> x</span><span class="clo">)</span><span class="pln">

</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">sum-integers a b</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">sum identity a inc b</span><span class="clo">))</span></pre></div>

<p>Then we can add up the integers from 1 to 10:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="pln">sum-integers </span><span class="lit">1</span><span class="pln"> </span><span class="lit">10</span><span class="clo">)</span><span class="pln">
</span><i><span class="lit">55</span></i>
</pre></div>

<p>We can also define <code>pi-sum</code> in the same way:<a class="footnote_link" id="DOCF50" href="#FOOT50"><sup>50</sup></a>
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">pi-sum a b</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">pi-term x</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="pun">/</span><span class="pln"> </span><span class="lit">1.0</span><span class="pln"> </span><span class="opn">(</span><span class="pun">*</span><span class="pln"> x </span><span class="opn">(</span><span class="pun">+</span><span class="pln"> x </span><span class="lit">2</span><span class="clo">))))</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">pi-next x</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="pun">+</span><span class="pln"> x </span><span class="lit">4</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">sum pi-term a pi-next b</span><span class="clo">))</span></pre></div>

<p>Using these procedures, we can compute an approximation to <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>π<!-- π --></mi>
</math>:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="pun">*</span><span class="pln"> </span><span class="lit">8</span><span class="pln"> </span><span class="opn">(</span><span class="pln">pi-sum </span><span class="lit">1</span><span class="pln"> </span><span class="lit">1000</span><span class="clo">))</span><span class="pln">
</span><i><span class="lit">3.139592655589783</span></i>
</pre></div>

<p>Once we have <code>sum</code>, we can use it as a building block in formulating
further concepts.  For instance, the definite integral of a function <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>f</mi>
</math>
between the limits <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>a</mi>
</math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>b</mi>
</math> can be approximated numerically using the
formula

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mrow class="MJX-TeXAtom-ORD">
    <msubsup>
      <mo>∫<!-- ∫ --></mo>
      <mi>a</mi>
      <mi>b</mi>
    </msubsup>
    <mspace width="-0.3em"/>
    <mi>f</mi>
  </mrow>
  <mspace width="thickmathspace"/>
  <mo>=</mo>
  <mspace width="thickmathspace"/>
  <mrow class="MJX-TeXAtom-ORD">
    <mrow>
      <mo>[</mo>
      <mspace width="thickmathspace"/>
      <mi>f</mi>
      <mrow>
        <mo>(</mo>
        <mi>a</mi>
        <mo>+</mo>
        <mfrac>
          <mrow>
            <mi>d</mi>
            <mi>x</mi>
          </mrow>
          <mn>2</mn>
        </mfrac>
        <mo>)</mo>
      </mrow>
    </mrow>
  </mrow>
  <mspace width="thinmathspace"/>
  <mo>+</mo>
  <mspace width="thinmathspace"/>
  <mrow class="MJX-TeXAtom-ORD">
    <mi>f</mi>
    <mrow>
      <mo>(</mo>
      <mi>a</mi>
      <mo>+</mo>
      <mi>d</mi>
      <mi>x</mi>
      <mo>+</mo>
      <mfrac>
        <mrow>
          <mi>d</mi>
          <mi>x</mi>
        </mrow>
        <mn>2</mn>
      </mfrac>
      <mo>)</mo>
    </mrow>
  </mrow>
  <mspace width="thinmathspace"/>
  <mo>+</mo>
  <mspace width="thinmathspace"/>
  <mrow class="MJX-TeXAtom-ORD">
    <mrow>
      <mi>f</mi>
      <mrow>
        <mo>(</mo>
        <mi>a</mi>
        <mo>+</mo>
        <mn>2</mn>
        <mi>d</mi>
        <mi>x</mi>
        <mo>+</mo>
        <mfrac>
          <mrow>
            <mi>d</mi>
            <mi>x</mi>
          </mrow>
          <mn>2</mn>
        </mfrac>
        <mo>)</mo>
      </mrow>
      <mspace width="thinmathspace"/>
      <mo>+</mo>
      <mspace width="thinmathspace"/>
      <mo>…<!-- … --></mo>
      <mspace width="thickmathspace"/>
      <mo>]</mo>
    </mrow>
    <mi>d</mi>
    <mi>x</mi>
  </mrow>
</math>

for small values of <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mi>d</mi>
    <mi>x</mi>
  </mrow>
</math>.  We can express this directly as a procedure:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">integral f a b dx</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">add-dx x</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pun">+</span><span class="pln"> x dx</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pun">*</span><span class="pln"> </span><span class="opn">(</span><span class="pln">sum f </span><span class="opn">(</span><span class="pun">+</span><span class="pln"> a </span><span class="opn">(</span><span class="pun">/</span><span class="pln"> dx </span><span class="lit">2.0</span><span class="clo">))</span><span class="pln"> add-dx b</span><span class="clo">)</span><span class="pln"> 
     dx</span><span class="clo">))</span><span class="pln">

</span><span class="opn">(</span><span class="pln">integral cube </span><span class="lit">0</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="lit">0.01</span><span class="clo">)</span><span class="pln">
</span><i><span class="lit">.24998750000000042</span></i><span class="pln">

</span><span class="opn">(</span><span class="pln">integral cube </span><span class="lit">0</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="lit">0.001</span><span class="clo">)</span><span class="pln">
</span><i><span class="lit">.249999875000001</span></i>
</pre></div>

<p>(The exact value of the integral of <code>cube</code> between 0 and 1 is 1/4.)
</p>
<blockquote>
<p><strong><a id="Exercise-1_002e29"></a>Exercise 1.29:</strong> Simpson’s Rule is a more accurate
method of numerical integration than the method illustrated above.  Using
Simpson’s Rule, the integral of a function <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>f</mi>
</math> between <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>a</mi>
</math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>b</mi>
</math> is
approximated as

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mfrac>
    <mi>h</mi>
    <mn>3</mn>
  </mfrac>
  <mo stretchy="false">(</mo>
  <msub>
    <mi>y</mi>
    <mn>0</mn>
  </msub>
  <mo>+</mo>
  <mrow class="MJX-TeXAtom-ORD">
    <mn>4</mn>
    <msub>
      <mi>y</mi>
      <mn>1</mn>
    </msub>
  </mrow>
  <mo>+</mo>
  <mrow class="MJX-TeXAtom-ORD">
    <mn>2</mn>
    <msub>
      <mi>y</mi>
      <mn>2</mn>
    </msub>
  </mrow>
  <mo>+</mo>
  <mrow class="MJX-TeXAtom-ORD">
    <mn>4</mn>
    <msub>
      <mi>y</mi>
      <mn>3</mn>
    </msub>
  </mrow>
  <mo>+</mo>
  <mrow class="MJX-TeXAtom-ORD">
    <mn>2</mn>
    <msub>
      <mi>y</mi>
      <mn>4</mn>
    </msub>
  </mrow>
  <mo>+</mo>
  <mo>⋯<!-- ⋯ --></mo>
  <mo>+</mo>
  <mrow class="MJX-TeXAtom-ORD">
    <mn>2</mn>
    <msub>
      <mi>y</mi>
      <mrow class="MJX-TeXAtom-ORD">
        <mi>n</mi>
        <mo>−<!-- − --></mo>
        <mn>2</mn>
      </mrow>
    </msub>
  </mrow>
  <mo>+</mo>
  <mrow class="MJX-TeXAtom-ORD">
    <mn>4</mn>
    <msub>
      <mi>y</mi>
      <mrow class="MJX-TeXAtom-ORD">
        <mi>n</mi>
        <mo>−<!-- − --></mo>
        <mn>1</mn>
      </mrow>
    </msub>
    <mo>+</mo>
    <msub>
      <mi>y</mi>
      <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
    <mo>,</mo>
  </mrow>
</math>

where <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mi>h</mi>
    <mo>=</mo>
    <mo stretchy="false">(</mo>
    <mi>b</mi>
    <mo>−<!-- − --></mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
    <mrow class="MJX-TeXAtom-ORD">
      <mo>/</mo>
    </mrow>
    <mi>n</mi>
  </mrow>
</math>, for some even integer <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>n</mi>
</math>, and
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <msub>
    <mi>y</mi>
    <mi>k</mi>
  </msub>
  <mo>=</mo>
  <mrow class="MJX-TeXAtom-ORD">
    <mi>f</mi>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>+</mo>
    <mi>k</mi>
    <mi>h</mi>
    <mo stretchy="false">)</mo>
  </mrow>
</math>.  (Increasing <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>n</mi>
</math> increases the
accuracy of the approximation.)  Define a procedure that takes as arguments
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>f</mi>
</math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>a</mi>
</math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>b</mi>
</math>, and <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>n</mi>
</math> and returns the value of the integral, computed
using Simpson’s Rule.  Use your procedure to integrate <code>cube</code> between 0
and 1 (with <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mi>n</mi>
    <mo>=</mo>
    <mn>100</mn>
  </mrow>
</math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mi>n</mi>
    <mo>=</mo>
    <mn>1000</mn>
  </mrow>
</math>), and compare the results to those of
the <code>integral</code> procedure shown above.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-1_002e30"></a>Exercise 1.30:</strong> The <code>sum</code> procedure above
generates a linear recursion.  The procedure can be rewritten so that the sum
is performed iteratively.  Show how to do this by filling in the missing
expressions in the following definition:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">sum term a next b</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">iter a result</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> ⟨</span><span class="pun">??</span><span class="pln">⟩
        ⟨</span><span class="pun">??</span><span class="pln">⟩
        </span><span class="opn">(</span><span class="pln">iter ⟨</span><span class="pun">??</span><span class="pln">⟩ ⟨</span><span class="pun">??</span><span class="pln">⟩</span><span class="clo">)))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">iter ⟨</span><span class="pun">??</span><span class="pln">⟩ ⟨</span><span class="pun">??</span><span class="pln">⟩</span><span class="clo">))</span></pre></div>
</blockquote>

<blockquote>
<p><strong><a id="Exercise-1_002e31"></a>Exercise 1.31:</strong> 
</p>
<ol>
<li> The <code>sum</code> procedure is only the simplest of a vast number of similar
abstractions that can be captured as higher-order procedures.<a class="footnote_link" id="DOCF51" href="#FOOT51"><sup>51</sup></a>  Write an analogous
procedure called <code>product</code> that returns the product of the values of a
function at points over a given range.  Show how to define <code>factorial</code> in
terms of <code>product</code>.  Also use <code>product</code> to compute approximations to
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>π<!-- π --></mi>
</math> using the formula<a class="footnote_link" id="DOCF52" href="#FOOT52"><sup>52</sup></a>

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mfrac>
    <mi>π<!-- π --></mi>
    <mn>4</mn>
  </mfrac>
  <mspace width="thinmathspace"/>
  <mo>=</mo>
  <mspace width="thinmathspace"/>
  <mrow class="MJX-TeXAtom-ORD">
    <mfrac>
      <mrow>
        <mn>2</mn>
        <mo>⋅<!-- ⋅ --></mo>
        <mn>4</mn>
        <mo>⋅<!-- ⋅ --></mo>
        <mn>4</mn>
        <mo>⋅<!-- ⋅ --></mo>
        <mn>6</mn>
        <mo>⋅<!-- ⋅ --></mo>
        <mn>6</mn>
        <mo>⋅<!-- ⋅ --></mo>
        <mn>8</mn>
        <mo>⋅<!-- ⋅ --></mo>
        <mo>⋯<!-- ⋯ --></mo>
      </mrow>
      <mrow>
        <mn>3</mn>
        <mo>⋅<!-- ⋅ --></mo>
        <mn>3</mn>
        <mo>⋅<!-- ⋅ --></mo>
        <mn>5</mn>
        <mo>⋅<!-- ⋅ --></mo>
        <mn>5</mn>
        <mo>⋅<!-- ⋅ --></mo>
        <mn>7</mn>
        <mo>⋅<!-- ⋅ --></mo>
        <mn>7</mn>
        <mo>⋅<!-- ⋅ --></mo>
        <mo>⋯<!-- ⋯ --></mo>
      </mrow>
    </mfrac>
    <mo>.</mo>
  </mrow>
</math>

</li><li> If your <code>product</code> procedure generates a recursive process, write one that
generates an iterative process.  If it generates an iterative process, write
one that generates a recursive process.

</li></ol>
</blockquote>

<blockquote>
<p><strong><a id="Exercise-1_002e32"></a>Exercise 1.32:</strong> 
</p>
<ol>
<li> Show that <code>sum</code> and <code>product</code> (<a href="#Exercise-1_002e31">Exercise 1.31</a>) are both special
cases of a still more general notion called <code>accumulate</code> that combines a
collection of terms, using some general accumulation function:

<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="pln">accumulate 
 combiner null-value term a next b</span><span class="clo">)</span></pre></div>

<p><code>Accumulate</code> takes as arguments the same term and range specifications as
<code>sum</code> and <code>product</code>, together with a <code>combiner</code> procedure (of
two arguments) that specifies how the current term is to be combined with the
accumulation of the preceding terms and a <code>null-value</code> that specifies what
base value to use when the terms run out.  Write <code>accumulate</code> and show how
<code>sum</code> and <code>product</code> can both be defined as simple calls to
<code>accumulate</code>.
</p>
</li><li> If your <code>accumulate</code> procedure generates a recursive process, write one
that generates an iterative process.  If it generates an iterative process,
write one that generates a recursive process.

</li></ol>
</blockquote>

<blockquote>
<p><strong><a id="Exercise-1_002e33"></a>Exercise 1.33:</strong> You can obtain an even more
general version of <code>accumulate</code> (<a href="#Exercise-1_002e32">Exercise 1.32</a>) by introducing the
notion of a <a id="index-filter"></a>
<em>filter</em> on the terms to be combined.  That is, combine
only those terms derived from values in the range that satisfy a specified
condition.  The resulting <code>filtered-accumulate</code> abstraction takes the same
arguments as accumulate, together with an additional predicate of one argument
that specifies the filter.  Write <code>filtered-accumulate</code> as a procedure.
Show how to express the following using <code>filtered-accumulate</code>:
</p>
<ol>
<li> the sum of the squares of the prime numbers in the interval <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>a</mi>
</math> to <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>b</mi>
</math>
(assuming that you have a <code>prime?</code> predicate already written)

</li><li> the product of all the positive integers less than <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>n</mi>
</math> that are relatively
prime to <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>n</mi>
</math> (i.e., all positive integers <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mi>i</mi>
    <mo>&lt;</mo>
    <mi>n</mi>
  </mrow>
</math> such that
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mtext>GCD</mtext>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
    <mo>=</mo>
    <mn>1</mn>
  </mrow>
</math>).

</li></ol>
</blockquote>

<div class="footnote">
<hr />

<h4 class="footnotes-heading">Footnotes</h4>

<div id="FOOT49"><p><a class="footnote_backlink" href="#DOCF49"><sup>49</sup></a>
This series, usually
written in the equivalent form 
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mfrac>
      <mi>π<!-- π --></mi>
      <mn>4</mn>
    </mfrac>
  </mrow>
  <mo>=</mo>
  <mrow class="MJX-TeXAtom-ORD">
    <mn>1</mn>
    <mo>−<!-- − --></mo>
    <mrow class="MJX-TeXAtom-ORD">
      <mfrac>
        <mn>1</mn>
        <mn>3</mn>
      </mfrac>
    </mrow>
    <mo>+</mo>
    <mrow class="MJX-TeXAtom-ORD">
      <mfrac>
        <mn>1</mn>
        <mn>5</mn>
      </mfrac>
    </mrow>
  </mrow>
  <mo>−<!-- − --></mo>
  <mrow class="MJX-TeXAtom-ORD">
    <mrow class="MJX-TeXAtom-ORD">
      <mfrac>
        <mn>1</mn>
        <mn>7</mn>
      </mfrac>
    </mrow>
    <mo>+</mo>
    <mo>…<!-- … --></mo>
  </mrow>
</math>, 
is due to Leibniz.  We’ll see how to use this as the basis for some
fancy numerical tricks in <a href="3_002e5_002e3.xhtml#g_t3_002e5_002e3">3.5.3</a>.</p>
</div>
<div id="FOOT50"><p><a class="footnote_backlink" href="#DOCF50"><sup>50</sup></a>
Notice that we have
used block structure (<a href="1_002e1_002e8.xhtml#g_t1_002e1_002e8">1.1.8</a>) to embed the definitions of
<code>pi-next</code> and <code>pi-term</code> within <code>pi-sum</code>, since these procedures
are unlikely to be useful for any other purpose.  We will see how to get rid of
them altogether in <a href="1_002e3_002e2.xhtml#g_t1_002e3_002e2">1.3.2</a>.</p>
</div>
<div id="FOOT51"><p><a class="footnote_backlink" href="#DOCF51"><sup>51</sup></a>
The
intent of <a href="#Exercise-1_002e31">Exercise 1.31</a> through <a href="#Exercise-1_002e33">Exercise 1.33</a> is to demonstrate the
expressive power that is attained by using an appropriate abstraction to
consolidate many seemingly disparate operations.  However, though accumulation
and filtering are elegant ideas, our hands are somewhat tied in using them at
this point since we do not yet have data structures to provide suitable means
of combination for these abstractions.  We will return to these ideas in
<a href="2_002e2_002e3.xhtml#g_t2_002e2_002e3">2.2.3</a> when we show how to use <a id="index-sequences"></a>
<em>sequences</em> as interfaces
for combining filters and accumulators to build even more powerful
abstractions.  We will see there how these methods really come into their own
as a powerful and elegant approach to designing programs.</p>
</div>
<div id="FOOT52"><p><a class="footnote_backlink" href="#DOCF52"><sup>52</sup></a>
This formula was discovered by the
seventeenth-century English mathematician John Wallis.</p>
</div>
</div>
<hr />
<nav class="header">
<p>
Next: <a href="1_002e3_002e2.xhtml#g_t1_002e3_002e2" accesskey="n" rel="next">1.3.2</a>, Previous: <a href="1_002e3.xhtml#g_t1_002e3" accesskey="p" rel="prev">1.3</a>, Up: <a href="1_002e3.xhtml#g_t1_002e3" accesskey="u" rel="prev">1.3</a>   [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>


</section>
</body>
</html>