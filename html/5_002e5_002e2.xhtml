<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Structure and Interpretation of Computer Programs, 2e: 5.5.2</title>

<meta name="description" content="Structure and Interpretation of Computer Programs, 2e: 5.5.2" />
<meta name="keywords" content="Structure and Interpretation of Computer Programs, 2e: 5.5.2" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="Generator" content="texi2any" />
<meta charset="utf-8" />
<link href="index.xhtml#Top" rel="start" title="Top" />
<link href="Term-Index.xhtml#Term-Index" rel="index" title="Term Index" />
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents" />
<link href="5_002e5.xhtml#g_t5_002e5" rel="prev" title="5.5" />
<link href="5_002e5_002e3.xhtml#g_t5_002e5_002e3" rel="next" title="5.5.3" />
<link href="5_002e5_002e1.xhtml#g_t5_002e5_002e1" rel="prev" title="5.5.1" />

<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />

<script src="js/jquery.min.js" type="text/javascript"></script>
<script src="js/footnotes.js" type="text/javascript"></script>
<script src="js/browsertest.js" type="text/javascript"></script>
</head>

<body>
<section><a id="g_t5_002e5_002e2"></a>
<nav class="header">
<p>
Next: <a href="5_002e5_002e3.xhtml#g_t5_002e5_002e3" accesskey="n" rel="next">5.5.3</a>, Previous: <a href="5_002e5_002e1.xhtml#g_t5_002e5_002e1" accesskey="p" rel="prev">5.5.1</a>, Up: <a href="5_002e5.xhtml#g_t5_002e5" accesskey="u" rel="prev">5.5</a>   [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>
<hr />

<a id="Compiling-Expressions"></a>
<h4 class="subsection"><span class="secnum">5.5.2</span><span class="sectitle">Compiling Expressions</span></h4>

<p>In this section and the next we implement the code generators to which the
<code>compile</code> procedure dispatches.
</p>
<a id="Compiling-linkage-code"></a>
<h5 class="subsubheading">Compiling linkage code</h5>

<p>In general, the output of each code generator will end with
instructions—generated by the procedure <code>compile-linkage</code>—that
implement the required linkage.  If the linkage is <code>return</code> then we must
generate the instruction <code>(goto (reg continue))</code>.  This needs the
<code>continue</code> register and does not modify any registers.  If the linkage is
<code>next</code>, then we needn’t include any additional instructions.  Otherwise,
the linkage is a label, and we generate a <code>goto</code> to that label, an
instruction that does not need or modify any registers.<a class="footnote_link" id="DOCF321" href="#FOOT321"><sup>321</sup></a>
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">compile-linkage linkage</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">cond</span><span class="pln"> </span><span class="opn">((</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> linkage </span><span class="lit">'return</span><span class="clo">)</span><span class="pln">
         </span><span class="opn">(</span><span class="pln">make-instruction-sequence 
          </span><span class="lit">'</span><span class="opn">(</span><span class="pln">continue</span><span class="clo">)</span><span class="pln">
          </span><span class="lit">'</span><span class="opn">(</span><span class="clo">)</span><span class="pln">
          </span><span class="lit">'</span><span class="opn">((</span><span class="pln">goto </span><span class="opn">(</span><span class="pln">reg continue</span><span class="clo">)))))</span><span class="pln">
        </span><span class="opn">((</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> linkage </span><span class="lit">'next</span><span class="clo">)</span><span class="pln">
         </span><span class="opn">(</span><span class="pln">empty-instruction-sequence</span><span class="clo">))</span><span class="pln">
        </span><span class="opn">(</span><span class="kwd">else</span><span class="pln">
         </span><span class="opn">(</span><span class="pln">make-instruction-sequence </span><span class="lit">'</span><span class="opn">(</span><span class="clo">)</span><span class="pln"> </span><span class="lit">'</span><span class="opn">(</span><span class="clo">)</span><span class="pln">
          </span><span class="pun">`</span><span class="opn">((</span><span class="pln">goto </span><span class="opn">(</span><span class="pln">label </span><span class="pun">,</span><span class="pln">linkage</span><span class="clo">)))))))</span></pre></div>

<p>The linkage code is appended to an instruction sequence by <code>preserving</code>
the <code>continue</code> register, since a <code>return</code> linkage will require the
<code>continue</code> register: If the given instruction sequence modifies
<code>continue</code> and the linkage code needs it, <code>continue</code> will be saved
and restored.
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">end-with-linkage 
         linkage instruction-sequence</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">preserving </span><span class="lit">'</span><span class="opn">(</span><span class="pln">continue</span><span class="clo">)</span><span class="pln">
   instruction-sequence
   </span><span class="opn">(</span><span class="pln">compile-linkage linkage</span><span class="clo">)))</span></pre></div>

<a id="Compiling-simple-expressions"></a>
<h5 class="subsubheading">Compiling simple expressions</h5>

<p>The code generators for self-evaluating expressions, quotations, and variables
construct instruction sequences that assign the required value to the target
register and then proceed as specified by the linkage descriptor.
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">compile-self-evaluating 
         exp target linkage</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">end-with-linkage
   linkage </span><span class="opn">(</span><span class="pln">make-instruction-sequence 
            </span><span class="lit">'</span><span class="opn">(</span><span class="clo">)</span><span class="pln">
            </span><span class="opn">(</span><span class="pln">list target</span><span class="clo">)</span><span class="pln">
            </span><span class="pun">`</span><span class="opn">((</span><span class="pln">assign </span><span class="pun">,</span><span class="pln">target </span><span class="opn">(</span><span class="pln">const </span><span class="pun">,</span><span class="pln">exp</span><span class="clo">))))))</span><span class="pln">

</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">compile-quoted exp target linkage</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">end-with-linkage
   linkage
   </span><span class="opn">(</span><span class="pln">make-instruction-sequence
    </span><span class="lit">'</span><span class="opn">(</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">list target</span><span class="clo">)</span><span class="pln">
    </span><span class="pun">`</span><span class="opn">((</span><span class="pln">assign 
       </span><span class="pun">,</span><span class="pln">target
       </span><span class="opn">(</span><span class="pln">const </span><span class="pun">,</span><span class="opn">(</span><span class="pln">text-of-quotation exp</span><span class="clo">)))))))</span><span class="pln">

</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">compile-variable
         exp target linkage</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">end-with-linkage 
   linkage
   </span><span class="opn">(</span><span class="pln">make-instruction-sequence 
    </span><span class="lit">'</span><span class="opn">(</span><span class="pln">env</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">list target</span><span class="clo">)</span><span class="pln">
    </span><span class="pun">`</span><span class="opn">((</span><span class="pln">assign </span><span class="pun">,</span><span class="pln">target
              </span><span class="opn">(</span><span class="pln">op lookup-variable-value</span><span class="clo">)</span><span class="pln">
              </span><span class="opn">(</span><span class="pln">const </span><span class="pun">,</span><span class="pln">exp</span><span class="clo">)</span><span class="pln">
              </span><span class="opn">(</span><span class="pln">reg env</span><span class="clo">))))))</span></pre></div>

<p>All these assignment instructions modify the target register, and the one that
looks up a variable needs the <code>env</code> register.
</p>
<p>Assignments and definitions are handled much as they are in the interpreter.
We recursively generate code that computes the value to be assigned to the
variable, and append to it a two-instruction sequence that actually sets or
defines the variable and assigns the value of the whole expression (the symbol
<code>ok</code>) to the target register.  The recursive compilation has target
<code>val</code> and linkage <code>next</code> so that the code will put its result into
<code>val</code> and continue with the code that is appended after it.  The appending
is done preserving <code>env</code>, since the environment is needed for setting or
defining the variable and the code for the variable value could be the
compilation of a complex expression that might modify the registers in
arbitrary ways.
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">compile-assignment 
         exp target linkage</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">let</span><span class="pln"> </span><span class="opn">((</span><span class="pln">var </span><span class="opn">(</span><span class="pln">assignment-variable exp</span><span class="clo">))</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">get-value-code
         </span><span class="opn">(</span><span class="pln">compile </span><span class="opn">(</span><span class="pln">assignment-value exp</span><span class="clo">)</span><span class="pln"> 
                  </span><span class="lit">'val</span><span class="pln">
                  </span><span class="lit">'next</span><span class="clo">)))</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">end-with-linkage 
     linkage
     </span><span class="opn">(</span><span class="pln">preserving 
      </span><span class="lit">'</span><span class="opn">(</span><span class="pln">env</span><span class="clo">)</span><span class="pln">
      get-value-code
      </span><span class="opn">(</span><span class="pln">make-instruction-sequence
       </span><span class="lit">'</span><span class="opn">(</span><span class="pln">env val</span><span class="clo">)</span><span class="pln">
       </span><span class="opn">(</span><span class="pln">list target</span><span class="clo">)</span><span class="pln">
       </span><span class="pun">`</span><span class="opn">((</span><span class="pln">perform </span><span class="opn">(</span><span class="pln">op set-variable-value!</span><span class="clo">)</span><span class="pln">
                  </span><span class="opn">(</span><span class="pln">const </span><span class="pun">,</span><span class="pln">var</span><span class="clo">)</span><span class="pln">
                  </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">)</span><span class="pln">
                  </span><span class="opn">(</span><span class="pln">reg env</span><span class="clo">))</span><span class="pln">
         </span><span class="opn">(</span><span class="pln">assign </span><span class="pun">,</span><span class="pln">target </span><span class="opn">(</span><span class="pln">const ok</span><span class="clo">))))))))</span><span class="pln">

</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">compile-definition 
         exp target linkage</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">let</span><span class="pln"> </span><span class="opn">((</span><span class="pln">var </span><span class="opn">(</span><span class="pln">definition-variable exp</span><span class="clo">))</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">get-value-code
         </span><span class="opn">(</span><span class="pln">compile </span><span class="opn">(</span><span class="pln">definition-value exp</span><span class="clo">)</span><span class="pln">
                  </span><span class="lit">'val</span><span class="pln">
                  </span><span class="lit">'next</span><span class="clo">)))</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">end-with-linkage
     linkage
     </span><span class="opn">(</span><span class="pln">preserving 
      </span><span class="lit">'</span><span class="opn">(</span><span class="pln">env</span><span class="clo">)</span><span class="pln">
      get-value-code
      </span><span class="opn">(</span><span class="pln">make-instruction-sequence
       </span><span class="lit">'</span><span class="opn">(</span><span class="pln">env val</span><span class="clo">)</span><span class="pln">
       </span><span class="opn">(</span><span class="pln">list target</span><span class="clo">)</span><span class="pln">
       </span><span class="pun">`</span><span class="opn">((</span><span class="pln">perform </span><span class="opn">(</span><span class="pln">op define-variable!</span><span class="clo">)</span><span class="pln">
                  </span><span class="opn">(</span><span class="pln">const </span><span class="pun">,</span><span class="pln">var</span><span class="clo">)</span><span class="pln">
                  </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">)</span><span class="pln">
                  </span><span class="opn">(</span><span class="pln">reg env</span><span class="clo">))</span><span class="pln">
         </span><span class="opn">(</span><span class="pln">assign </span><span class="pun">,</span><span class="pln">target </span><span class="opn">(</span><span class="pln">const ok</span><span class="clo">))))))))</span></pre></div>

<p>The appended two-instruction sequence requires <code>env</code> and <code>val</code> and
modifies the target.  Note that although we preserve <code>env</code> for this
sequence, we do not preserve <code>val</code>, because the <code>get-value-code</code> is
designed to explicitly place its result in <code>val</code> for use by this sequence.
(In fact, if we did preserve <code>val</code>, we would have a bug, because this
would cause the previous contents of <code>val</code> to be restored right after the
<code>get-value-code</code> is run.)
</p>
<a id="Compiling-conditional-expressions"></a>
<h5 class="subsubheading">Compiling conditional expressions</h5>

<p>The code for an <code>if</code> expression compiled with a given target and linkage
has the form
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="pln">⟨</span><em><span class="pln">compilation of predicate</span><span class="pun">,</span><span class="pln"> 
 target </span><code><span class="pln">val</span></code><span class="pun">,</span><span class="pln"> linkage </span><code><span class="pln">next</span></code></em><span class="pln">⟩
 </span><span class="opn">(</span><span class="pln">test </span><span class="opn">(</span><span class="pln">op false?</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">))</span><span class="pln">
 </span><span class="opn">(</span><span class="pln">branch </span><span class="opn">(</span><span class="pln">label false-branch</span><span class="clo">))</span><span class="pln">
true-branch
 ⟨</span><em><span class="pln">compilation of consequent with given 
  target </span><span class="kwd">and</span><span class="pln"> given linkage </span><span class="kwd">or</span><span class="pln"> </span><code><span class="pln">after-if</span></code></em><span class="pln">⟩
false-branch
 ⟨</span><em><span class="pln">compilation of alternative 
  with given target </span><span class="kwd">and</span><span class="pln"> linkage</span></em><span class="pln">⟩
after-if</span></pre></div>

<p>To generate this code, we compile the predicate, consequent, and alternative,
and combine the resulting code with instructions to test the predicate result
and with newly generated labels to mark the true and false branches and the end
of the conditional.<a class="footnote_link" id="DOCF322" href="#FOOT322"><sup>322</sup></a> In this arrangement of code, we must branch around the true branch if the
test is false.  The only slight complication is in how the linkage for the true
branch should be handled.  If the linkage for the conditional is <code>return</code>
or a label, then the true and false branches will both use this same linkage.
If the linkage is <code>next</code>, the true branch ends with a jump around the code
for the false branch to the label at the end of the conditional.
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">compile-if exp target linkage</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">let</span><span class="pln"> </span><span class="opn">((</span><span class="pln">t-branch </span><span class="opn">(</span><span class="pln">make-label </span><span class="lit">'true-branch</span><span class="clo">))</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">f-branch </span><span class="opn">(</span><span class="pln">make-label </span><span class="lit">'false-branch</span><span class="clo">))</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">after-if </span><span class="opn">(</span><span class="pln">make-label </span><span class="lit">'after-if</span><span class="clo">)))</span><span class="pln">
    </span><span class="opn">(</span><span class="kwd">let</span><span class="pln"> </span><span class="opn">((</span><span class="pln">consequent-linkage
           </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> </span><span class="opn">(</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> linkage </span><span class="lit">'next</span><span class="clo">)</span><span class="pln"> 
               after-if
               linkage</span><span class="clo">)))</span><span class="pln">
      </span><span class="opn">(</span><span class="kwd">let</span><span class="pln"> </span><span class="opn">((</span><span class="pln">p-code 
             </span><span class="opn">(</span><span class="pln">compile </span><span class="opn">(</span><span class="pln">if-predicate exp</span><span class="clo">)</span><span class="pln">
                      </span><span class="lit">'val</span><span class="pln">
                      </span><span class="lit">'next</span><span class="clo">))</span><span class="pln">
            </span><span class="opn">(</span><span class="pln">c-code
             </span><span class="opn">(</span><span class="pln">compile </span><span class="opn">(</span><span class="pln">if-consequent exp</span><span class="clo">)</span><span class="pln"> 
                      target 
                      consequent-linkage</span><span class="clo">))</span><span class="pln">
            </span><span class="opn">(</span><span class="pln">a-code
             </span><span class="opn">(</span><span class="pln">compile </span><span class="opn">(</span><span class="pln">if-alternative exp</span><span class="clo">)</span><span class="pln">
                      target
                      linkage</span><span class="clo">)))</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">preserving 
         </span><span class="lit">'</span><span class="opn">(</span><span class="pln">env continue</span><span class="clo">)</span><span class="pln">
         p-code
         </span><span class="opn">(</span><span class="pln">append-instruction-sequences
          </span><span class="opn">(</span><span class="pln">make-instruction-sequence 
           </span><span class="lit">'</span><span class="opn">(</span><span class="pln">val</span><span class="clo">)</span><span class="pln"> 
           </span><span class="lit">'</span><span class="opn">(</span><span class="clo">)</span><span class="pln">
           </span><span class="pun">`</span><span class="opn">((</span><span class="pln">test </span><span class="opn">(</span><span class="pln">op false?</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">))</span><span class="pln">
             </span><span class="opn">(</span><span class="pln">branch </span><span class="opn">(</span><span class="pln">label </span><span class="pun">,</span><span class="pln">f-branch</span><span class="clo">))))</span><span class="pln">
          </span><span class="opn">(</span><span class="pln">parallel-instruction-sequences
           </span><span class="opn">(</span><span class="pln">append-instruction-sequences 
            t-branch c-code</span><span class="clo">)</span><span class="pln">
           </span><span class="opn">(</span><span class="pln">append-instruction-sequences
            f-branch a-code</span><span class="clo">))</span><span class="pln">
          after-if</span><span class="clo">))))))</span></pre></div>

<p><code>Env</code> is preserved around the predicate code because it could be needed by
the true and false branches, and <code>continue</code> is preserved because it could
be needed by the linkage code in those branches.  The code for the true and
false branches (which are not executed sequentially) is appended using a
special combiner <code>parallel-instruction-sequences</code> described in 
<a href="5_002e5_002e4.xhtml#g_t5_002e5_002e4">5.5.4</a>.
</p>
<p>Note that <code>cond</code> is a derived expression, so all that the compiler needs
to do handle it is to apply the <code>cond-&gt;if</code> transformer (from 
<a href="4_002e1_002e2.xhtml#g_t4_002e1_002e2">4.1.2</a>) and compile the resulting <code>if</code> expression.
</p>
<a id="Compiling-sequences"></a>
<h5 class="subsubheading">Compiling sequences</h5>

<p>The compilation of sequences (from procedure bodies or explicit <code>begin</code>
expressions) parallels their evaluation.  Each expression of the sequence is
compiled—the last expression with the linkage specified for the sequence, and
the other expressions with linkage <code>next</code> (to execute the rest of the
sequence).  The instruction sequences for the individual expressions are
appended to form a single instruction sequence, such that <code>env</code> (needed
for the rest of the sequence) and <code>continue</code> (possibly needed for the
linkage at the end of the sequence) are preserved.
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">compile-sequence seq target linkage</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> </span><span class="opn">(</span><span class="pln">last-exp? seq</span><span class="clo">)</span><span class="pln">
      </span><span class="opn">(</span><span class="pln">compile </span><span class="opn">(</span><span class="pln">first-exp seq</span><span class="clo">)</span><span class="pln"> target linkage</span><span class="clo">)</span><span class="pln">
      </span><span class="opn">(</span><span class="pln">preserving </span><span class="lit">'</span><span class="opn">(</span><span class="pln">env continue</span><span class="clo">)</span><span class="pln">
       </span><span class="opn">(</span><span class="pln">compile </span><span class="opn">(</span><span class="pln">first-exp seq</span><span class="clo">)</span><span class="pln"> target </span><span class="lit">'next</span><span class="clo">)</span><span class="pln">
       </span><span class="opn">(</span><span class="pln">compile-sequence </span><span class="opn">(</span><span class="pln">rest-exps seq</span><span class="clo">)</span><span class="pln">
                         target
                         linkage</span><span class="clo">))))</span></pre></div>

<a id="Compiling-lambda-expressions"></a>
<h5 class="subsubheading">Compiling <code>lambda</code> expressions</h5>

<p><code>Lambda</code> expressions construct procedures.  The object code for a
<code>lambda</code> expression must have the form
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="pln">⟨</span><em><span class="pln">construct procedure object 
 </span><span class="kwd">and</span><span class="pln"> assign it to target register</span></em><span class="pln">⟩
⟨</span><var><span class="pln">linkage</span></var><span class="pln">⟩</span></pre></div>

<p>When we compile the <code>lambda</code> expression, we also generate the code for the
procedure body.  Although the body won’t be executed at the time of procedure
construction, it is convenient to insert it into the object code right after
the code for the <code>lambda</code>.  If the linkage for the <code>lambda</code>
expression is a label or <code>return</code>, this is fine.  But if the linkage is
<code>next</code>, we will need to skip around the code for the procedure body by
using a linkage that jumps to a label that is inserted after the body.  The
object code thus has the form
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="pln">⟨</span><em><span class="pln">construct procedure object 
 </span><span class="kwd">and</span><span class="pln"> assign it to target register</span></em><span class="pln">⟩
 ⟨</span><em><span class="pln">code for given linkage</span></em><span class="pln">⟩ </span><em><span class="kwd">or</span></em><span class="pln"> 
  </span><code><span class="opn">(</span><span class="pln">goto </span><span class="opn">(</span><span class="pln">label after-lambda</span><span class="clo">))</span></code><span class="pln">
 ⟨</span><em><span class="pln">compilation of procedure body</span></em><span class="pln">⟩
after-lambda</span></pre></div>

<p><code>Compile-lambda</code> generates the code for constructing the procedure object
followed by the code for the procedure body.  The procedure object will be
constructed at run time by combining the current environment (the environment
at the point of definition) with the entry point to the compiled procedure body
(a newly generated label).<a class="footnote_link" id="DOCF323" href="#FOOT323"><sup>323</sup></a>
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">compile-lambda exp target linkage</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">let</span><span class="pln"> </span><span class="opn">((</span><span class="pln">proc-entry 
         </span><span class="opn">(</span><span class="pln">make-label </span><span class="lit">'entry</span><span class="clo">))</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">after-lambda 
         </span><span class="opn">(</span><span class="pln">make-label </span><span class="lit">'after-lambda</span><span class="clo">)))</span><span class="pln">
    </span><span class="opn">(</span><span class="kwd">let</span><span class="pln"> </span><span class="opn">((</span><span class="pln">lambda-linkage
           </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> </span><span class="opn">(</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> linkage </span><span class="lit">'next</span><span class="clo">)</span><span class="pln">
               after-lambda
               linkage</span><span class="clo">)))</span><span class="pln">
      </span><span class="opn">(</span><span class="pln">append-instruction-sequences
       </span><span class="opn">(</span><span class="pln">tack-on-instruction-sequence
        </span><span class="opn">(</span><span class="pln">end-with-linkage 
         lambda-linkage
         </span><span class="opn">(</span><span class="pln">make-instruction-sequence 
          </span><span class="lit">'</span><span class="opn">(</span><span class="pln">env</span><span class="clo">)</span><span class="pln">
          </span><span class="opn">(</span><span class="pln">list target</span><span class="clo">)</span><span class="pln">
          </span><span class="pun">`</span><span class="opn">((</span><span class="pln">assign 
             </span><span class="pun">,</span><span class="pln">target
             </span><span class="opn">(</span><span class="pln">op make-compiled-procedure</span><span class="clo">)</span><span class="pln">
             </span><span class="opn">(</span><span class="pln">label </span><span class="pun">,</span><span class="pln">proc-entry</span><span class="clo">)</span><span class="pln">
             </span><span class="opn">(</span><span class="pln">reg env</span><span class="clo">)))))</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">compile-lambda-body exp proc-entry</span><span class="clo">))</span><span class="pln">
       after-lambda</span><span class="clo">))))</span></pre></div>

<p><code>Compile-lambda</code> uses the special combiner
<code>tack-on-instruction-sequence</code> rather than
<code>append-instruction-sequences</code> (<a href="5_002e5_002e4.xhtml#g_t5_002e5_002e4">5.5.4</a>) to append the procedure body to the
<code>lambda</code> expression code, because the body is not part of the sequence of
instructions that will be executed when the combined sequence is entered;
rather, it is in the sequence only because that was a convenient place to put
it.
</p>
<p><code>Compile-lambda-body</code> constructs the code for the body of the procedure.
This code begins with a label for the entry point.  Next come instructions that
will cause the run-time evaluation environment to switch to the correct
environment for evaluating the procedure body—namely, the definition
environment of the procedure, extended to include the bindings of the formal
parameters to the arguments with which the procedure is called.  After this
comes the code for the sequence of expressions that makes up the procedure
body.  The sequence is compiled with linkage <code>return</code> and target
<code>val</code> so that it will end by returning from the procedure with the
procedure result in <code>val</code>.
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">compile-lambda-body exp proc-entry</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">let</span><span class="pln"> </span><span class="opn">((</span><span class="pln">formals </span><span class="opn">(</span><span class="pln">lambda-parameters exp</span><span class="clo">)))</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">append-instruction-sequences
     </span><span class="opn">(</span><span class="pln">make-instruction-sequence 
      </span><span class="lit">'</span><span class="opn">(</span><span class="pln">env proc argl</span><span class="clo">)</span><span class="pln">
      </span><span class="lit">'</span><span class="opn">(</span><span class="pln">env</span><span class="clo">)</span><span class="pln">
      </span><span class="pun">`</span><span class="opn">(</span><span class="pun">,</span><span class="pln">proc-entry
        </span><span class="opn">(</span><span class="pln">assign env 
                </span><span class="opn">(</span><span class="pln">op compiled-procedure-env</span><span class="clo">)</span><span class="pln">
                </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">))</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">assign env
                </span><span class="opn">(</span><span class="pln">op extend-environment</span><span class="clo">)</span><span class="pln">
                </span><span class="opn">(</span><span class="pln">const </span><span class="pun">,</span><span class="pln">formals</span><span class="clo">)</span><span class="pln">
                </span><span class="opn">(</span><span class="pln">reg argl</span><span class="clo">)</span><span class="pln">
                </span><span class="opn">(</span><span class="pln">reg env</span><span class="clo">))))</span><span class="pln">
     </span><span class="opn">(</span><span class="pln">compile-sequence </span><span class="opn">(</span><span class="pln">lambda-body exp</span><span class="clo">)</span><span class="pln">
                       </span><span class="lit">'val</span><span class="pln">
                       </span><span class="lit">'return</span><span class="clo">))))</span></pre></div>

<div class="footnote">
<hr />

<h4 class="footnotes-heading">Footnotes</h4>

<div id="FOOT321"><p><a class="footnote_backlink" href="#DOCF321"><sup>321</sup></a>
This procedure
uses a feature of Lisp called <a id="index-backquote"></a>
<em>backquote</em> (or <a id="index-quasiquote"></a>
<em>quasiquote</em>)
that is handy for constructing lists.  Preceding a list with a backquote symbol
is much like quoting it, except that anything in the list that is flagged with
a comma is evaluated.
</p>
<p>For example, if the value of <code>linkage</code> is the symbol <code>branch25</code>,
then the expression 
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="pun">`</span><span class="opn">((</span><span class="pln">goto </span><span class="opn">(</span><span class="pln">label </span><span class="pun">,</span><span class="pln">linkage</span><span class="clo">)))</span></pre></div>

<p>evaluates to the list 
</p>	
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">((</span><span class="pln">goto </span><span class="opn">(</span><span class="pln">label branch25</span><span class="clo">)))</span><span class="pln"> </span></pre></div>

<p>Similarly, if the value of <code>x</code> is the list <code>(a b c)</code>, then 
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="pun">`</span><span class="opn">(</span><span class="lit">1</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">,</span><span class="opn">(</span><span class="kwd">car</span><span class="pln"> x</span><span class="clo">))</span><span class="pln"> </span></pre></div>

<p>evaluates to the list 
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="lit">1</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> a</span><span class="clo">)</span></pre></div>
</div>
<div id="FOOT322"><p><a class="footnote_backlink" href="#DOCF322"><sup>322</sup></a>
We can’t just use the labels <code>true-branch</code>,
<code>false-branch</code>, and <code>after-if</code> as shown above, because there might be
more than one <code>if</code> in the program.  The compiler uses the procedure
<code>make-label</code> to generate labels.  <code>Make-label</code> takes a symbol as
argument and returns a new symbol that begins with the given symbol.  For
example, successive calls to <code>(make-label 'a)</code> would return <code>a1</code>,
<code>a2</code>, and so on.  <code>Make-label</code> can be implemented similarly to the
generation of unique variable names in the query language, as follows:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> label-counter </span><span class="lit">0</span><span class="clo">)</span><span class="pln">

</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">new-label-number</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">set</span><span class="pun">!</span><span class="pln"> label-counter </span><span class="opn">(</span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> label-counter</span><span class="clo">))</span><span class="pln">
  label-counter</span><span class="clo">)</span><span class="pln">

</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">make-label name</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">string-</span><span class="pun">&gt;</span><span class="pln">symbol
   </span><span class="opn">(</span><span class="pln">string-append 
    </span><span class="opn">(</span><span class="pln">symbol-</span><span class="pun">&gt;</span><span class="pln">string name</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">number-</span><span class="pun">&gt;</span><span class="pln">string </span><span class="opn">(</span><span class="pln">new-label-number</span><span class="clo">)))))</span></pre></div>
</div>
<div id="FOOT323"><p><a class="footnote_backlink" href="#DOCF323"><sup>323</sup></a>
<a id="Footnote-323"></a>We need
machine operations to implement a data structure for representing compiled
procedures, analogous to the structure for compound procedures described in
<a href="4_002e1_002e3.xhtml#g_t4_002e1_002e3">4.1.3</a>:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">make-compiled-procedure entry env</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">list </span><span class="lit">'compiled-procedure</span><span class="pln"> entry env</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">compiled-procedure? proc</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">tagged-list? proc </span><span class="lit">'compiled-procedure</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">compiled-procedure-entry c-proc</span><span class="clo">)</span><span class="pln"> 
  </span><span class="opn">(</span><span class="kwd">cadr</span><span class="pln"> c-proc</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">compiled-procedure-env c-proc</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">caddr</span><span class="pln"> c-proc</span><span class="clo">))</span></pre></div>
</div>
</div>
<hr />
<nav class="header">
<p>
Next: <a href="5_002e5_002e3.xhtml#g_t5_002e5_002e3" accesskey="n" rel="next">5.5.3</a>, Previous: <a href="5_002e5_002e1.xhtml#g_t5_002e5_002e1" accesskey="p" rel="prev">5.5.1</a>, Up: <a href="5_002e5.xhtml#g_t5_002e5" accesskey="u" rel="prev">5.5</a>   [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>


</section>
</body>
</html>