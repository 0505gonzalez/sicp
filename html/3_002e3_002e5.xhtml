<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Structure and Interpretation of Computer Programs, 2e: 3.3.5</title>

<meta name="description" content="Structure and Interpretation of Computer Programs, 2e: 3.3.5" />
<meta name="keywords" content="Structure and Interpretation of Computer Programs, 2e: 3.3.5" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="Generator" content="texi2any" />
<meta charset="utf-8" />
<link href="index.xhtml#Top" rel="start" title="Top" />
<link href="Term-Index.xhtml#Term-Index" rel="index" title="Term Index" />
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents" />
<link href="3_002e3.xhtml#g_t3_002e3" rel="prev" title="3.3" />
<link href="3_002e4.xhtml#g_t3_002e4" rel="next" title="3.4" />
<link href="3_002e3_002e4.xhtml#g_t3_002e3_002e4" rel="prev" title="3.3.4" />

<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />

<script src="js/jquery.min.js" type="text/javascript"></script>
<script src="js/footnotes.js" type="text/javascript"></script>
<script src="js/browsertest.js" type="text/javascript"></script>
</head>

<body>
<section><a id="g_t3_002e3_002e5"></a>
<nav class="header">
<p>
Next: <a href="3_002e4.xhtml#g_t3_002e4" accesskey="n" rel="next">3.4</a>, Previous: <a href="3_002e3_002e4.xhtml#g_t3_002e3_002e4" accesskey="p" rel="prev">3.3.4</a>, Up: <a href="3_002e3.xhtml#g_t3_002e3" accesskey="u" rel="prev">3.3</a>   [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>
<hr />

<a id="Propagation-of-Constraints"></a>
<h4 class="subsection"><span class="secnum">3.3.5</span><span class="sectitle">Propagation of Constraints</span></h4>

<p>Computer programs are traditionally organized as one-directional computations,
which perform operations on prespecified arguments to produce desired outputs.
On the other hand, we often model systems in terms of relations among
quantities.  For example, a mathematical model of a mechanical structure might
include the information that the deflection <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>d</mi>
</math> of a metal rod is related to
the force <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>F</mi>
</math> on the rod, the length <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>L</mi>
</math> of the rod, the cross-sectional
area <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>A</mi>
</math>, and the elastic modulus <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>E</mi>
</math> via the equation
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mrow class="MJX-TeXAtom-ORD">
    <mi>d</mi>
    <mi>A</mi>
    <mi>E</mi>
  </mrow>
  <mspace width="thinmathspace"/>
  <mo>=</mo>
  <mspace width="thinmathspace"/>
  <mrow class="MJX-TeXAtom-ORD">
    <mi>F</mi>
    <mi>L</mi>
    <mo>.</mo>
  </mrow>
</math>
Such an equation is not one-directional.  Given any four of the quantities, we
can use it to compute the fifth.  Yet translating the equation into a
traditional computer language would force us to choose one of the quantities to
be computed in terms of the other four.  Thus, a procedure for computing the
area <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>A</mi>
</math> could not be used to compute the deflection <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>d</mi>
</math>, even though the
computations of <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>A</mi>
</math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>d</mi>
</math> arise from the same
equation.<a class="footnote_link" id="DOCF159" href="#FOOT159"><sup>159</sup></a>
</p>
<p>In this section, we sketch the design of a language that enables us to work in
terms of relations themselves.  The primitive elements of the language are
<a id="index-primitive-constraints"></a>
<em>primitive constraints</em>, which state that certain relations hold
between quantities.  For example, <code>(adder a b c)</code> specifies that the
quantities <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>a</mi>
</math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>b</mi>
</math>, and <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>c</mi>
</math> must be related by the equation 
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mi>a</mi>
    <mo>+</mo>
    <mi>b</mi>
    <mo>=</mo>
    <mi>c</mi>
  </mrow>
</math>, <code>(multiplier x y z)</code> expresses the constraint 
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mi>x</mi>
    <mi>y</mi>
    <mo>=</mo>
    <mi>z</mi>
  </mrow>
</math>, and <code>(constant 3.14 x)</code> says that the value of <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>x</mi>
</math> must be 3.14.
</p>
<p>Our language provides a means of combining primitive constraints in order to
express more complex relations.  We combine constraints by constructing
<a id="index-constraint-networks"></a>
<em>constraint networks</em>, in which constraints are joined by
<a id="index-connectors"></a>
<em>connectors</em>.  A connector is an object that “holds” a value that may
participate in one or more constraints.  For example, we know that the
relationship between Fahrenheit and Celsius temperatures is
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mrow class="MJX-TeXAtom-ORD">
    <mn>9</mn>
    <mi>C</mi>
  </mrow>
  <mspace width="thinmathspace"/>
  <mo>=</mo>
  <mspace width="thinmathspace"/>
  <mrow class="MJX-TeXAtom-ORD">
    <mn>5</mn>
    <mo stretchy="false">(</mo>
    <mi>F</mi>
    <mo>−<!-- − --></mo>
    <mn>32</mn>
    <mo stretchy="false">)</mo>
    <mo>.</mo>
  </mrow>
</math>
Such a constraint can be thought of as a network consisting of primitive adder,
multiplier, and constant constraints (<a href="#Figure-3_002e28">Figure 3.28</a>).  In the figure, we
see on the left a multiplier box with three terminals, labeled <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>m</mi>
</math>1, <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>m</mi>
</math>2,
and <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>p</mi>
</math>.  These connect the multiplier to the rest of the network as follows:
The <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>m</mi>
</math>1 terminal is linked to a connector <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>C</mi>
</math>, which will hold the Celsius
temperature.  The <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>m</mi>
</math>2 terminal is linked to a connector <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>w</mi>
</math>, which is also
linked to a constant box that holds 9.  The <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>p</mi>
</math> terminal, which the
multiplier box constrains to be the product of <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>m</mi>
</math>1 and <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>m</mi>
</math>2, is linked to
the <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>p</mi>
</math> terminal of another multiplier box, whose <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>m</mi>
</math>2 is connected to a
constant 5 and whose <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>m</mi>
</math>1 is connected to one of the terms in a sum.
</p>
<figure class="float">
<a id="Figure-3_002e28"></a>
<object style="width: 58.11ex; height: 18.30ex;" data="fig/chap3/Fig3.28.std.svg" type="image/svg+xml">SVG</object>

<figcaption class="float-caption">
<p><strong>Figure 3.28:</strong> The relation <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mn>9</mn>
    <mi>C</mi>
    <mo>=</mo>
    <mn>5</mn>
    <mo stretchy="false">(</mo>
    <mi>F</mi>
    <mo>−<!-- − --></mo>
    <mn>32</mn>
    <mo stretchy="false">)</mo>
  </mrow>
</math> expressed as a constraint network.</p>
</figcaption>
</figure>

<p>Computation by such a network proceeds as follows: When a connector is given a
value (by the user or by a constraint box to which it is linked), it awakens
all of its associated constraints (except for the constraint that just awakened
it) to inform them that it has a value.  Each awakened constraint box then
polls its connectors to see if there is enough information to determine a value
for a connector.  If so, the box sets that connector, which then awakens all of
its associated constraints, and so on.  For instance, in conversion between
Celsius and Fahrenheit, <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>w</mi>
</math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>x</mi>
</math>, and <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>y</mi>
</math> are immediately set by the
constant boxes to 9, 5, and 32, respectively.  The connectors awaken the
multipliers and the adder, which determine that there is not enough information
to proceed.  If the user (or some other part of the network) sets <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>C</mi>
</math> to a
value (say 25), the leftmost multiplier will be awakened, and it will set <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>u</mi>
</math>
to <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mn>25</mn>
    <mo>⋅<!-- ⋅ --></mo>
    <mn>9</mn>
    <mo>=</mo>
    <mn>225</mn>
  </mrow>
</math>.  Then <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>u</mi>
</math> awakens the second multiplier, which sets <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>v</mi>
</math> to
45, and <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>v</mi>
</math> awakens the adder, which sets <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>f</mi>
</math> to 77.
</p>
<a id="Using-the-constraint-system"></a>
<h5 class="subsubheading">Using the constraint system</h5>

<p>To use the constraint system to carry out the temperature computation outlined
above, we first create two connectors, <code>C</code> and <code>F</code>, by calling the
constructor <code>make-connector</code>, and link <code>C</code> and <code>F</code> in an
appropriate network:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> C </span><span class="opn">(</span><span class="pln">make-connector</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> F </span><span class="opn">(</span><span class="pln">make-connector</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="pln">celsius-fahrenheit-converter C F</span><span class="clo">)</span><span class="pln">
</span><i><span class="pln">ok</span></i>
</pre></div>

<p>The procedure that creates the network is defined as follows:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">celsius-fahrenheit-converter c f</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">let</span><span class="pln"> </span><span class="opn">((</span><span class="pln">u </span><span class="opn">(</span><span class="pln">make-connector</span><span class="clo">))</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">v </span><span class="opn">(</span><span class="pln">make-connector</span><span class="clo">))</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">w </span><span class="opn">(</span><span class="pln">make-connector</span><span class="clo">))</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">x </span><span class="opn">(</span><span class="pln">make-connector</span><span class="clo">))</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">y </span><span class="opn">(</span><span class="pln">make-connector</span><span class="clo">)))</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">multiplier c w u</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">multiplier v x u</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">adder v y f</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">constant </span><span class="lit">9</span><span class="pln"> w</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">constant </span><span class="lit">5</span><span class="pln"> x</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">constant </span><span class="lit">32</span><span class="pln"> y</span><span class="clo">)</span><span class="pln">
    </span><span class="lit">'ok</span><span class="clo">))</span></pre></div>

<p>This procedure creates the internal connectors <code>u</code>, <code>v</code>, <code>w</code>,
<code>x</code>, and <code>y</code>, and links them as shown in <a href="#Figure-3_002e28">Figure 3.28</a> using the
primitive constraint constructors <code>adder</code>, <code>multiplier</code>, and
<code>constant</code>.  Just as with the digital-circuit simulator of 
<a href="3_002e3_002e4.xhtml#g_t3_002e3_002e4">3.3.4</a>, expressing these combinations of primitive elements in terms of
procedures automatically provides our language with a means of abstraction for
compound objects.
</p>
<p>To watch the network in action, we can place probes on the connectors <code>C</code>
and <code>F</code>, using a <code>probe</code> procedure similar to the one we used to
monitor wires in <a href="3_002e3_002e4.xhtml#g_t3_002e3_002e4">3.3.4</a>.  Placing a probe on a connector will
cause a message to be printed whenever the connector is given a value:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="pln">probe </span><span class="str">"Celsius temp"</span><span class="pln"> C</span><span class="clo">)</span><span class="pln">
</span><span class="opn">(</span><span class="pln">probe </span><span class="str">"Fahrenheit temp"</span><span class="pln"> F</span><span class="clo">)</span></pre></div>

<p>Next we set the value of <code>C</code> to 25.  (The third argument to
<code>set-value!</code> tells <code>C</code> that this directive comes from the
<code>user</code>.)
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="pln">set-value! C </span><span class="lit">25</span><span class="pln"> </span><span class="lit">'user</span><span class="clo">)</span><span class="pln">
</span><i><span class="pln">Probe</span><span class="pun">:</span><span class="pln"> Celsius temp </span><span class="pun">=</span><span class="pln"> </span><span class="lit">25</span></i><span class="pln">
</span><i><span class="pln">Probe</span><span class="pun">:</span><span class="pln"> Fahrenheit temp </span><span class="pun">=</span><span class="pln"> </span><span class="lit">77</span></i><span class="pln">
</span><i><span class="pln">done</span></i>
</pre></div>

<p>The probe on <code>C</code> awakens and reports the value.  <code>C</code> also propagates
its value through the network as described above.  This sets <code>F</code> to 77,
which is reported by the probe on <code>F</code>.
</p>
<p>Now we can try to set <code>F</code> to a new value, say 212:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="pln">set-value! F </span><span class="lit">212</span><span class="pln"> </span><span class="lit">'user</span><span class="clo">)</span><span class="pln">
</span><i><span class="pln">Error! Contradiction </span><span class="opn">(</span><span class="lit">77</span><span class="pln"> </span><span class="lit">212</span><span class="clo">)</span></i>
</pre></div>

<p>The connector complains that it has sensed a contradiction: Its value is 77,
and someone is trying to set it to 212.  If we really want to reuse the network
with new values, we can tell <code>C</code> to forget its old value:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="pln">forget-value! C </span><span class="lit">'user</span><span class="clo">)</span><span class="pln">
</span><i><span class="pln">Probe</span><span class="pun">:</span><span class="pln"> Celsius temp </span><span class="pun">=</span><span class="pln"> </span><span class="pun">?</span></i><span class="pln">
</span><i><span class="pln">Probe</span><span class="pun">:</span><span class="pln"> Fahrenheit temp </span><span class="pun">=</span><span class="pln"> </span><span class="pun">?</span></i><span class="pln">
</span><i><span class="pln">done</span></i>
</pre></div>

<p><code>C</code> finds that the <code>user</code>, who set its value originally, is now
retracting that value, so <code>C</code> agrees to lose its value, as shown by the
probe, and informs the rest of the network of this fact.  This information
eventually propagates to <code>F</code>, which now finds that it has no reason for
continuing to believe that its own value is 77.  Thus, <code>F</code> also gives up
its value, as shown by the probe.
</p>
<p>Now that <code>F</code> has no value, we are free to set it to 212:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="pln">set-value! F </span><span class="lit">212</span><span class="pln"> </span><span class="lit">'user</span><span class="clo">)</span><span class="pln">
</span><i><span class="pln">Probe</span><span class="pun">:</span><span class="pln"> Fahrenheit temp </span><span class="pun">=</span><span class="pln"> </span><span class="lit">212</span></i><span class="pln">
</span><i><span class="pln">Probe</span><span class="pun">:</span><span class="pln"> Celsius temp </span><span class="pun">=</span><span class="pln"> </span><span class="lit">100</span></i><span class="pln">
</span><i><span class="pln">done</span></i>
</pre></div>

<p>This new value, when propagated through the network, forces <code>C</code> to have a
value of 100, and this is registered by the probe on <code>C</code>.  Notice that the
very same network is being used to compute <code>C</code> given <code>F</code> and to
compute <code>F</code> given <code>C</code>.  This nondirectionality of computation is the
distinguishing feature of constraint-based systems.
</p>
<a id="Implementing-the-constraint-system"></a>
<h5 class="subsubheading">Implementing the constraint system</h5>

<p>The constraint system is implemented via procedural objects with local state,
in a manner very similar to the digital-circuit simulator of 
<a href="3_002e3_002e4.xhtml#g_t3_002e3_002e4">3.3.4</a>.  Although the primitive objects of the constraint system are
somewhat more complex, the overall system is simpler, since there is no concern
about agendas and logic delays.
</p>
<p>The basic operations on connectors are the following:
</p>
<ul>
<li> <code>(has-value? ⟨<var>connector</var>⟩)</code> tells whether the connector has a value.

</li><li> <code>(get-value ⟨<var>connector</var>⟩)</code> returns the connector’s current value.

</li><li> <code>(set-value! ⟨<var>connector</var>⟩ ⟨<var>new-value</var>⟩ ⟨<var>informant</var>⟩)</code>
indicates that the informant is requesting the connector to set its value to
the new value.

</li><li> <code>(forget-value! ⟨<var>connector</var>⟩ ⟨<var>retractor</var>⟩)</code> tells the connector
that the retractor is requesting it to forget its value.

</li><li> <code>(connect ⟨<var>connector</var>⟩ ⟨<var>new-constraint</var>⟩)</code> tells the connector
to participate in the new constraint.

</li></ul>

<p>The connectors communicate with the constraints by means of the procedures
<code>inform-about-value</code>, which tells the given constraint that the connector
has a value, and <code>inform-about-no-value</code>, which tells the constraint that
the connector has lost its value.
</p>
<p><code>Adder</code> constructs an adder constraint among summand connectors <code>a1</code>
and <code>a2</code> and a <code>sum</code> connector.  An adder is implemented as a
procedure with local state (the procedure <code>me</code> below):
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">adder a1 a2 sum</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">process-new-value</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="kwd">cond</span><span class="pln"> </span><span class="opn">((</span><span class="kwd">and</span><span class="pln"> </span><span class="opn">(</span><span class="pln">has-value? a1</span><span class="clo">)</span><span class="pln"> 
                </span><span class="opn">(</span><span class="pln">has-value? a2</span><span class="clo">))</span><span class="pln">
           </span><span class="opn">(</span><span class="pln">set-value! sum
                       </span><span class="opn">(</span><span class="pun">+</span><span class="pln"> </span><span class="opn">(</span><span class="pln">get-value a1</span><span class="clo">)</span><span class="pln"> 
                          </span><span class="opn">(</span><span class="pln">get-value a2</span><span class="clo">))</span><span class="pln">
                       me</span><span class="clo">))</span><span class="pln">
          </span><span class="opn">((</span><span class="kwd">and</span><span class="pln"> </span><span class="opn">(</span><span class="pln">has-value? a1</span><span class="clo">)</span><span class="pln"> 
                </span><span class="opn">(</span><span class="pln">has-value? sum</span><span class="clo">))</span><span class="pln">
           </span><span class="opn">(</span><span class="pln">set-value! a2
                       </span><span class="opn">(</span><span class="pun">-</span><span class="pln"> </span><span class="opn">(</span><span class="pln">get-value sum</span><span class="clo">)</span><span class="pln"> 
                          </span><span class="opn">(</span><span class="pln">get-value a1</span><span class="clo">))</span><span class="pln">
                       me</span><span class="clo">))</span><span class="pln">
          </span><span class="opn">((</span><span class="kwd">and</span><span class="pln"> </span><span class="opn">(</span><span class="pln">has-value? a2</span><span class="clo">)</span><span class="pln"> 
                </span><span class="opn">(</span><span class="pln">has-value? sum</span><span class="clo">))</span><span class="pln">
           </span><span class="opn">(</span><span class="pln">set-value! a1
                       </span><span class="opn">(</span><span class="pun">-</span><span class="pln"> </span><span class="opn">(</span><span class="pln">get-value sum</span><span class="clo">)</span><span class="pln"> 
                          </span><span class="opn">(</span><span class="pln">get-value a2</span><span class="clo">))</span><span class="pln">
                       me</span><span class="clo">))))</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">process-forget-value</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">forget-value! sum me</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">forget-value! a1 me</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">forget-value! a2 me</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">process-new-value</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">me request</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="kwd">cond</span><span class="pln"> </span><span class="opn">((</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> request </span><span class="lit">'I-have-a-value</span><span class="clo">)</span><span class="pln">
           </span><span class="opn">(</span><span class="pln">process-new-value</span><span class="clo">))</span><span class="pln">
          </span><span class="opn">((</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> request </span><span class="lit">'I-lost-my-value</span><span class="clo">)</span><span class="pln">
           </span><span class="opn">(</span><span class="pln">process-forget-value</span><span class="clo">))</span><span class="pln">
          </span><span class="opn">(</span><span class="kwd">else</span><span class="pln"> </span><span class="opn">(</span><span class="err">error</span><span class="pln"> </span><span class="str">"Unknown request: 
                        ADDER"</span><span class="pln"> request</span><span class="clo">))))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">connect a1 me</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">connect a2 me</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">connect sum me</span><span class="clo">)</span><span class="pln">
  me</span><span class="clo">)</span></pre></div>

<p><code>Adder</code> connects the new adder to the designated connectors and returns it
as its value.  The procedure <code>me</code>, which represents the adder, acts as a
dispatch to the local procedures.  The following “syntax interfaces” (see
<a href="3_002e3_002e4.xhtml#Footnote-155">Footnote 155</a> in <a href="3_002e3_002e4.xhtml#g_t3_002e3_002e4">3.3.4</a>) are used in conjunction with
the dispatch:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">inform-about-value constraint</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">constraint </span><span class="lit">'I-have-a-value</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">inform-about-no-value constraint</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">constraint </span><span class="lit">'I-lost-my-value</span><span class="clo">))</span></pre></div>

<p>The adder’s local procedure <code>process-new-value</code> is called when the adder
is informed that one of its connectors has a value. The adder first checks to
see if both <code>a1</code> and <code>a2</code> have values. If so, it tells <code>sum</code> to
set its value to the sum of the two addends.  The <code>informant</code> argument to
<code>set-value!</code> is <code>me</code>, which is the adder object itself.  If <code>a1</code>
and <code>a2</code> do not both have values, then the adder checks to see if perhaps
<code>a1</code> and <code>sum</code> have values.  If so, it sets <code>a2</code> to the
difference of these two.  Finally, if <code>a2</code> and <code>sum</code> have values,
this gives the adder enough information to set <code>a1</code>.  If the adder is told
that one of its connectors has lost a value, it requests that all of its
connectors now lose their values.  (Only those values that were set by this
adder are actually lost.)  Then it runs <code>process-new-value</code>.  The reason
for this last step is that one or more connectors may still have a value (that
is, a connector may have had a value that was not originally set by the adder),
and these values may need to be propagated back through the adder.
</p>
<p>A multiplier is very similar to an adder. It will set its <code>product</code> to 0
if either of the factors is 0, even if the other factor is not known.
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">multiplier m1 m2 product</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">process-new-value</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="kwd">cond</span><span class="pln"> </span><span class="opn">((</span><span class="kwd">or</span><span class="pln"> </span><span class="opn">(</span><span class="kwd">and</span><span class="pln"> </span><span class="opn">(</span><span class="pln">has-value? m1</span><span class="clo">)</span><span class="pln"> 
                    </span><span class="opn">(</span><span class="pun">=</span><span class="pln"> </span><span class="opn">(</span><span class="pln">get-value m1</span><span class="clo">)</span><span class="pln"> </span><span class="lit">0</span><span class="clo">))</span><span class="pln">
               </span><span class="opn">(</span><span class="kwd">and</span><span class="pln"> </span><span class="opn">(</span><span class="pln">has-value? m2</span><span class="clo">)</span><span class="pln"> 
                    </span><span class="opn">(</span><span class="pun">=</span><span class="pln"> </span><span class="opn">(</span><span class="pln">get-value m2</span><span class="clo">)</span><span class="pln"> </span><span class="lit">0</span><span class="clo">)))</span><span class="pln">
           </span><span class="opn">(</span><span class="pln">set-value! product </span><span class="lit">0</span><span class="pln"> me</span><span class="clo">))</span><span class="pln">
          </span><span class="opn">((</span><span class="kwd">and</span><span class="pln"> </span><span class="opn">(</span><span class="pln">has-value? m1</span><span class="clo">)</span><span class="pln"> 
                </span><span class="opn">(</span><span class="pln">has-value? m2</span><span class="clo">))</span><span class="pln">
           </span><span class="opn">(</span><span class="pln">set-value! product
                       </span><span class="opn">(</span><span class="pun">*</span><span class="pln"> </span><span class="opn">(</span><span class="pln">get-value m1</span><span class="clo">)</span><span class="pln"> 
                          </span><span class="opn">(</span><span class="pln">get-value m2</span><span class="clo">))</span><span class="pln">
                       me</span><span class="clo">))</span><span class="pln">
          </span><span class="opn">((</span><span class="kwd">and</span><span class="pln"> </span><span class="opn">(</span><span class="pln">has-value? product</span><span class="clo">)</span><span class="pln"> 
                </span><span class="opn">(</span><span class="pln">has-value? m1</span><span class="clo">))</span><span class="pln">
           </span><span class="opn">(</span><span class="pln">set-value! m2
                       </span><span class="opn">(</span><span class="pun">/</span><span class="pln"> </span><span class="opn">(</span><span class="pln">get-value product</span><span class="clo">)</span><span class="pln"> 
                          </span><span class="opn">(</span><span class="pln">get-value m1</span><span class="clo">))</span><span class="pln">
                       me</span><span class="clo">))</span><span class="pln">
          </span><span class="opn">((</span><span class="kwd">and</span><span class="pln"> </span><span class="opn">(</span><span class="pln">has-value? product</span><span class="clo">)</span><span class="pln"> 
                </span><span class="opn">(</span><span class="pln">has-value? m2</span><span class="clo">))</span><span class="pln">
           </span><span class="opn">(</span><span class="pln">set-value! m1
                       </span><span class="opn">(</span><span class="pun">/</span><span class="pln"> </span><span class="opn">(</span><span class="pln">get-value product</span><span class="clo">)</span><span class="pln"> 
                          </span><span class="opn">(</span><span class="pln">get-value m2</span><span class="clo">))</span><span class="pln">
                       me</span><span class="clo">))))</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">process-forget-value</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">forget-value! product me</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">forget-value! m1 me</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">forget-value! m2 me</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">process-new-value</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">me request</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="kwd">cond</span><span class="pln"> </span><span class="opn">((</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> request </span><span class="lit">'I-have-a-value</span><span class="clo">)</span><span class="pln">
           </span><span class="opn">(</span><span class="pln">process-new-value</span><span class="clo">))</span><span class="pln">
          </span><span class="opn">((</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> request </span><span class="lit">'I-lost-my-value</span><span class="clo">)</span><span class="pln">
           </span><span class="opn">(</span><span class="pln">process-forget-value</span><span class="clo">))</span><span class="pln">
          </span><span class="opn">(</span><span class="kwd">else</span><span class="pln">
           </span><span class="opn">(</span><span class="err">error</span><span class="pln"> </span><span class="str">"Unknown request: 
                   MULTIPLIER"</span><span class="pln"> 
                  request</span><span class="clo">))))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">connect m1 me</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">connect m2 me</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">connect product me</span><span class="clo">)</span><span class="pln">
  me</span><span class="clo">)</span></pre></div>

<p>A <code>constant</code> constructor simply sets the value of the designated
connector.  Any <code>I-have-a-value</code> or <code>I-lost-my-value</code> message sent to
the constant box will produce an error.
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">constant value connector</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">me request</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="err">error</span><span class="pln"> </span><span class="str">"Unknown request: CONSTANT"</span><span class="pln"> 
           request</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">connect connector me</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">set-value! connector value me</span><span class="clo">)</span><span class="pln">
  me</span><span class="clo">)</span></pre></div>

<p>Finally, a probe prints a message about the setting or unsetting of
the designated connector:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">probe name connector</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">print-probe value</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">newline</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">display </span><span class="str">"Probe: "</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">display name</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">display </span><span class="str">" = "</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">display value</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">process-new-value</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">print-probe </span><span class="opn">(</span><span class="pln">get-value connector</span><span class="clo">)))</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">process-forget-value</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">print-probe </span><span class="str">"?"</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">me request</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="kwd">cond</span><span class="pln"> </span><span class="opn">((</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> request </span><span class="lit">'I-have-a-value</span><span class="clo">)</span><span class="pln">
           </span><span class="opn">(</span><span class="pln">process-new-value</span><span class="clo">))</span><span class="pln">
          </span><span class="opn">((</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> request </span><span class="lit">'I-lost-my-value</span><span class="clo">)</span><span class="pln">
           </span><span class="opn">(</span><span class="pln">process-forget-value</span><span class="clo">))</span><span class="pln">
          </span><span class="opn">(</span><span class="kwd">else</span><span class="pln"> </span><span class="opn">(</span><span class="err">error</span><span class="pln"> </span><span class="str">"Unknown request: 
                        PROBE"</span><span class="pln"> request</span><span class="clo">))))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">connect connector me</span><span class="clo">)</span><span class="pln">
  me</span><span class="clo">)</span></pre></div>

<a id="Representing-connectors"></a>
<h5 class="subsubheading">Representing connectors</h5>

<p>A connector is represented as a procedural object with local state variables
<code>value</code>, the current value of the connector; <code>informant</code>, the object
that set the connector’s value; and <code>constraints</code>, a list of the
constraints in which the connector participates.
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">make-connector</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">let</span><span class="pln"> </span><span class="opn">((</span><span class="pln">value false</span><span class="clo">)</span><span class="pln"> 
        </span><span class="opn">(</span><span class="pln">informant false</span><span class="clo">)</span><span class="pln"> 
        </span><span class="opn">(</span><span class="pln">constraints </span><span class="lit">'</span><span class="opn">(</span><span class="clo">)))</span><span class="pln">
    </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">set-my-value newval setter</span><span class="clo">)</span><span class="pln">
      </span><span class="opn">(</span><span class="kwd">cond</span><span class="pln"> </span><span class="opn">((</span><span class="pln">not </span><span class="opn">(</span><span class="pln">has-value? me</span><span class="clo">))</span><span class="pln">
             </span><span class="opn">(</span><span class="kwd">set</span><span class="pun">!</span><span class="pln"> value newval</span><span class="clo">)</span><span class="pln">
             </span><span class="opn">(</span><span class="kwd">set</span><span class="pun">!</span><span class="pln"> informant setter</span><span class="clo">)</span><span class="pln">
             </span><span class="opn">(</span><span class="pln">for-each-except 
              setter
              inform-about-value
              constraints</span><span class="clo">))</span><span class="pln">
            </span><span class="opn">((</span><span class="pln">not </span><span class="opn">(</span><span class="pun">=</span><span class="pln"> value newval</span><span class="clo">))</span><span class="pln">
             </span><span class="opn">(</span><span class="err">error</span><span class="pln"> </span><span class="str">"Contradiction"</span><span class="pln"> 
                    </span><span class="opn">(</span><span class="pln">list value newval</span><span class="clo">)))</span><span class="pln">
            </span><span class="opn">(</span><span class="kwd">else</span><span class="pln"> </span><span class="lit">'ignored</span><span class="clo">)))</span><span class="pln">
    </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">forget-my-value retractor</span><span class="clo">)</span><span class="pln">
      </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> </span><span class="opn">(</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> retractor informant</span><span class="clo">)</span><span class="pln">
          </span><span class="opn">(</span><span class="kwd">begin</span><span class="pln"> </span><span class="opn">(</span><span class="kwd">set</span><span class="pun">!</span><span class="pln"> informant false</span><span class="clo">)</span><span class="pln">
                 </span><span class="opn">(</span><span class="pln">for-each-except 
                  retractor
                  inform-about-no-value
                  constraints</span><span class="clo">))</span><span class="pln">
          </span><span class="lit">'ignored</span><span class="clo">))</span><span class="pln">
    </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">connect new-constraint</span><span class="clo">)</span><span class="pln">
      </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> </span><span class="opn">(</span><span class="pln">not </span><span class="opn">(</span><span class="pln">memq new-constraint 
                     constraints</span><span class="clo">))</span><span class="pln">
          </span><span class="opn">(</span><span class="kwd">set</span><span class="pun">!</span><span class="pln"> constraints
                </span><span class="opn">(</span><span class="kwd">cons</span><span class="pln"> new-constraint 
                      constraints</span><span class="clo">)))</span><span class="pln">
      </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> </span><span class="opn">(</span><span class="pln">has-value? me</span><span class="clo">)</span><span class="pln">
          </span><span class="opn">(</span><span class="pln">inform-about-value new-constraint</span><span class="clo">))</span><span class="pln">
      </span><span class="lit">'done</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">me request</span><span class="clo">)</span><span class="pln">
      </span><span class="opn">(</span><span class="kwd">cond</span><span class="pln"> </span><span class="opn">((</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> request </span><span class="lit">'has-value?</span><span class="clo">)</span><span class="pln">
             </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> informant true false</span><span class="clo">))</span><span class="pln">
            </span><span class="opn">((</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> request </span><span class="lit">'value</span><span class="clo">)</span><span class="pln"> value</span><span class="clo">)</span><span class="pln">
            </span><span class="opn">((</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> request </span><span class="lit">'set-value!</span><span class="clo">)</span><span class="pln"> 
             set-my-value</span><span class="clo">)</span><span class="pln">
            </span><span class="opn">((</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> request </span><span class="lit">'forget</span><span class="clo">)</span><span class="pln"> 
             forget-my-value</span><span class="clo">)</span><span class="pln">
            </span><span class="opn">((</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> request </span><span class="lit">'connect</span><span class="clo">)</span><span class="pln"> connect</span><span class="clo">)</span><span class="pln">
            </span><span class="opn">(</span><span class="kwd">else</span><span class="pln"> </span><span class="opn">(</span><span class="err">error</span><span class="pln"> </span><span class="str">"Unknown operation: 
                          CONNECTOR"</span><span class="pln">
                         request</span><span class="clo">))))</span><span class="pln">
    me</span><span class="clo">))</span></pre></div>

<p>The connector’s local procedure <code>set-my-value</code> is called when there is a
request to set the connector’s value.  If the connector does not currently have
a value, it will set its value and remember as <code>informant</code> the constraint
that requested the value to be set.<a class="footnote_link" id="DOCF160" href="#FOOT160"><sup>160</sup></a>  Then the connector will notify all of its participating
constraints except the constraint that requested the value to be set.  This is
accomplished using the following iterator, which applies a designated procedure
to all items in a list except a given one:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">for-each-except exception 
                         procedure 
                         list</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">loop items</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="kwd">cond</span><span class="pln"> </span><span class="opn">((</span><span class="pln">null? items</span><span class="clo">)</span><span class="pln"> </span><span class="lit">'done</span><span class="clo">)</span><span class="pln">
          </span><span class="opn">((</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> </span><span class="opn">(</span><span class="kwd">car</span><span class="pln"> items</span><span class="clo">)</span><span class="pln"> exception</span><span class="clo">)</span><span class="pln"> 
           </span><span class="opn">(</span><span class="pln">loop </span><span class="opn">(</span><span class="kwd">cdr</span><span class="pln"> items</span><span class="clo">)))</span><span class="pln">
          </span><span class="opn">(</span><span class="kwd">else</span><span class="pln"> </span><span class="opn">(</span><span class="pln">procedure </span><span class="opn">(</span><span class="kwd">car</span><span class="pln"> items</span><span class="clo">))</span><span class="pln">
                </span><span class="opn">(</span><span class="pln">loop </span><span class="opn">(</span><span class="kwd">cdr</span><span class="pln"> items</span><span class="clo">)))))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">loop list</span><span class="clo">))</span></pre></div>

<p>If a connector is asked to forget its value, it runs the local procedure
<code>forget-my-value</code>, which first checks to make sure that the request is
coming from the same object that set the value originally.  If so, the
connector informs its associated constraints about the loss of the value.
</p>
<p>The local procedure <code>connect</code> adds the designated new constraint to the
list of constraints if it is not already in that list.  Then, if the connector
has a value, it informs the new constraint of this fact.
</p>
<p>The connector’s procedure <code>me</code> serves as a dispatch to the other internal
procedures and also represents the connector as an object.  The following
procedures provide a syntax interface for the dispatch:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">has-value? connector</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">connector </span><span class="lit">'has-value?</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">get-value connector</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">connector </span><span class="lit">'value</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">set-value! connector 
                    new-value 
                    informant</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">((</span><span class="pln">connector </span><span class="lit">'set-value!</span><span class="clo">)</span><span class="pln"> 
   new-value 
   informant</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">forget-value! connector retractor</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">((</span><span class="pln">connector </span><span class="lit">'forget</span><span class="clo">)</span><span class="pln"> retractor</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">connect connector new-constraint</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">((</span><span class="pln">connector </span><span class="lit">'connect</span><span class="clo">)</span><span class="pln"> new-constraint</span><span class="clo">))</span></pre></div>

<blockquote>
<p><strong><a id="Exercise-3_002e33"></a>Exercise 3.33:</strong> Using primitive multiplier,
adder, and constant constraints, define a procedure <code>averager</code> that takes
three connectors <code>a</code>, <code>b</code>, and <code>c</code> as inputs and establishes the
constraint that the value of <code>c</code> is the average of the values of <code>a</code>
and <code>b</code>.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-3_002e34"></a>Exercise 3.34:</strong> Louis Reasoner wants to build a
squarer, a constraint device with two terminals such that the value of
connector <code>b</code> on the second terminal will always be the square of the
value <code>a</code> on the first terminal.  He proposes the following simple device
made from a multiplier:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">squarer a b</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">multiplier a a b</span><span class="clo">))</span></pre></div>

<p>There is a serious flaw in this idea.  Explain.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-3_002e35"></a>Exercise 3.35:</strong> Ben Bitdiddle tells Louis that
one way to avoid the trouble in <a href="#Exercise-3_002e34">Exercise 3.34</a> is to define a squarer as a
new primitive constraint.  Fill in the missing portions in Ben’s outline for a
procedure to implement such a constraint:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">squarer a b</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">process-new-value</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> </span><span class="opn">(</span><span class="pln">has-value? b</span><span class="clo">)</span><span class="pln">
        </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> </span><span class="opn">(</span><span class="pun">&lt;</span><span class="pln"> </span><span class="opn">(</span><span class="pln">get-value b</span><span class="clo">)</span><span class="pln"> </span><span class="lit">0</span><span class="clo">)</span><span class="pln">
            </span><span class="opn">(</span><span class="err">error</span><span class="pln"> </span><span class="str">"square less than 0: 
                    SQUARER"</span><span class="pln"> 
                   </span><span class="opn">(</span><span class="pln">get-value b</span><span class="clo">))</span><span class="pln">
            ⟨</span><var><span class="pln">alternative1</span></var><span class="pln">⟩</span><span class="clo">)</span><span class="pln">
        ⟨</span><var><span class="pln">alternative2</span></var><span class="pln">⟩</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">process-forget-value</span><span class="clo">)</span><span class="pln"> ⟨</span><var><span class="pln">body1</span></var><span class="pln">⟩</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">me request</span><span class="clo">)</span><span class="pln"> ⟨</span><var><span class="pln">body2</span></var><span class="pln">⟩</span><span class="clo">)</span><span class="pln">
  ⟨</span><var><span class="pln">rest of definition</span></var><span class="pln">⟩
  me</span><span class="clo">)</span></pre></div>
</blockquote>

<blockquote>
<p><strong><a id="Exercise-3_002e36"></a>Exercise 3.36:</strong> Suppose we evaluate the following
sequence of expressions in the global environment:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> a </span><span class="opn">(</span><span class="pln">make-connector</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> b </span><span class="opn">(</span><span class="pln">make-connector</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="pln">set-value! a </span><span class="lit">10</span><span class="pln"> </span><span class="lit">'user</span><span class="clo">)</span></pre></div>

<p>At some time during evaluation of the <code>set-value!</code>, the following
expression from the connector’s local procedure is evaluated:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="pln">for-each-except 
  setter inform-about-value constraints</span><span class="clo">)</span></pre></div>

<p>Draw an environment diagram showing the environment in which the above
expression is evaluated.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-3_002e37"></a>Exercise 3.37:</strong> The
<code>celsius-fahrenheit-converter</code> procedure is cumbersome when compared with
a more expression-oriented style of definition, such as
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">celsius-fahrenheit-converter x</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">c</span><span class="pun">+</span><span class="pln"> </span><span class="opn">(</span><span class="pln">c</span><span class="pun">*</span><span class="pln"> </span><span class="opn">(</span><span class="pln">c</span><span class="pun">/</span><span class="pln"> </span><span class="opn">(</span><span class="pln">cv </span><span class="lit">9</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">cv </span><span class="lit">5</span><span class="clo">))</span><span class="pln">
          x</span><span class="clo">)</span><span class="pln">
      </span><span class="opn">(</span><span class="pln">cv </span><span class="lit">32</span><span class="clo">)))</span><span class="pln">

</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> C </span><span class="opn">(</span><span class="pln">make-connector</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> F </span><span class="opn">(</span><span class="pln">celsius-fahrenheit-converter C</span><span class="clo">))</span></pre></div>

<p>Here <code>c+</code>, <code>c*</code>, etc. are the “constraint” versions of the
arithmetic operations.  For example, <code>c+</code> takes two connectors as
arguments and returns a connector that is related to these by an adder
constraint:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">c</span><span class="pun">+</span><span class="pln"> x y</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">let</span><span class="pln"> </span><span class="opn">((</span><span class="pln">z </span><span class="opn">(</span><span class="pln">make-connector</span><span class="clo">)))</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">adder x y z</span><span class="clo">)</span><span class="pln">
    z</span><span class="clo">))</span></pre></div>

<p>Define analogous procedures <code>c-</code>, <code>c*</code>, <code>c/</code>, and <code>cv</code>
(constant value) that enable us to define compound constraints as in the
converter example above.<a class="footnote_link" id="DOCF161" href="#FOOT161"><sup>161</sup></a>
</p></blockquote>

<div class="footnote">
<hr />

<h4 class="footnotes-heading">Footnotes</h4>

<div id="FOOT159"><p><a class="footnote_backlink" href="#DOCF159"><sup>159</sup></a>
Constraint propagation first appeared in the incredibly
forward-looking <abbr>SKETCHPAD</abbr> system of Ivan <a href="References.xhtml#Sutherland-_00281963_0029">Sutherland (1963)</a>.  A
beautiful constraint-propagation system based on the Smalltalk language was
developed by Alan <a href="References.xhtml#Borning-_00281977_0029">Borning (1977)</a> at Xerox Palo Alto Research Center.  Sussman,
Stallman, and Steele applied constraint propagation to electrical circuit
analysis (<a href="References.xhtml#Sussman-and-Stallman-1975">Sussman and Stallman 1975</a>; <a href="References.xhtml#Sussman-and-Steele-1980">Sussman and Steele 1980</a>). TK!Solver
(<a href="References.xhtml#Konopasek-and-Jayaraman-1984">Konopasek and Jayaraman 1984</a>) is an extensive modeling environment based on
constraints.</p>
</div>
<div id="FOOT160"><p><a class="footnote_backlink" href="#DOCF160"><sup>160</sup></a>
The <code>setter</code> might not be a
constraint.  In our temperature example, we used <code>user</code> as the
<code>setter</code>.</p>
</div>
<div id="FOOT161"><p><a class="footnote_backlink" href="#DOCF161"><sup>161</sup></a>
The expression-oriented format is convenient
because it avoids the need to name the intermediate expressions in a
computation.  Our original formulation of the constraint language is cumbersome
in the same way that many languages are cumbersome when dealing with operations
on compound data.  For example, if we wanted to compute the product 
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>+</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
    <mo>⋅<!-- ⋅ --></mo>
    <mo stretchy="false">(</mo>
    <mi>c</mi>
    <mo>+</mo>
    <mi>d</mi>
    <mo stretchy="false">)</mo>
  </mrow>
</math>, where the variables represent vectors, we could work
in “imperative style,” using procedures that set the values of designated
vector arguments but do not themselves return vectors as values:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="pln">v-sum a b temp1</span><span class="clo">)</span><span class="pln">
</span><span class="opn">(</span><span class="pln">v-sum c d temp2</span><span class="clo">)</span><span class="pln">
</span><span class="opn">(</span><span class="pln">v-prod temp1 temp2 answer</span><span class="clo">)</span></pre></div>

<p>Alternatively, we could deal with expressions, using procedures that return
vectors as values, and thus avoid explicitly mentioning <code>temp1</code> and
<code>temp2</code>:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> answer 
  </span><span class="opn">(</span><span class="pln">v-prod </span><span class="opn">(</span><span class="pln">v-sum a b</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">v-sum c d</span><span class="clo">)))</span></pre></div>

<p>Since Lisp allows us to return compound objects as values of procedures, we can
transform our imperative-style constraint language into an expression-oriented
style as shown in this exercise.  In languages that are impoverished in
handling compound objects, such as Algol, Basic, and Pascal (unless one
explicitly uses Pascal pointer variables), one is usually stuck with the
imperative style when manipulating compound objects.  Given the advantage of
the expression-oriented format, one might ask if there is any reason to have
implemented the system in imperative style, as we did in this section.  One
reason is that the non-expression-oriented constraint language provides a
handle on constraint objects (e.g., the value of the <code>adder</code> procedure) as
well as on connector objects.  This is useful if we wish to extend the system
with new operations that communicate with constraints directly rather than only
indirectly via operations on connectors.  Although it is easy to implement the
expression-oriented style in terms of the imperative implementation, it is very
difficult to do the converse.</p>
</div>
</div>
<hr />
<nav class="header">
<p>
Next: <a href="3_002e4.xhtml#g_t3_002e4" accesskey="n" rel="next">3.4</a>, Previous: <a href="3_002e3_002e4.xhtml#g_t3_002e3_002e4" accesskey="p" rel="prev">3.3.4</a>, Up: <a href="3_002e3.xhtml#g_t3_002e3" accesskey="u" rel="prev">3.3</a>   [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>


</section>
</body>
</html>