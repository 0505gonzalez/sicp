<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Structure and Interpretation of Computer Programs, 2e: 3.5.2</title>

<meta name="description" content="Structure and Interpretation of Computer Programs, 2e: 3.5.2" />
<meta name="keywords" content="Structure and Interpretation of Computer Programs, 2e: 3.5.2" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="Generator" content="texi2any" />
<meta charset="utf-8" />
<link href="index.xhtml#Top" rel="start" title="Top" />
<link href="Term-Index.xhtml#Term-Index" rel="index" title="Term Index" />
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents" />
<link href="3_002e5.xhtml#g_t3_002e5" rel="prev" title="3.5" />
<link href="3_002e5_002e3.xhtml#g_t3_002e5_002e3" rel="next" title="3.5.3" />
<link href="3_002e5_002e1.xhtml#g_t3_002e5_002e1" rel="prev" title="3.5.1" />

<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />

<script src="js/jquery.min.js" type="text/javascript"></script>
<script src="js/footnotes.js" type="text/javascript"></script>
<script src="js/browsertest.js" type="text/javascript"></script>
</head>

<body>
<section><a id="g_t3_002e5_002e2"></a>
<nav class="header">
<p>
Next: <a href="3_002e5_002e3.xhtml#g_t3_002e5_002e3" accesskey="n" rel="next">3.5.3</a>, Previous: <a href="3_002e5_002e1.xhtml#g_t3_002e5_002e1" accesskey="p" rel="prev">3.5.1</a>, Up: <a href="3_002e5.xhtml#g_t3_002e5" accesskey="u" rel="prev">3.5</a>   [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>
<hr />

<a id="Infinite-Streams"></a>
<h4 class="subsection"><span class="secnum">3.5.2</span><span class="sectitle">Infinite Streams</span></h4>

<p>We have seen how to support the illusion of manipulating streams as complete
entities even though, in actuality, we compute only as much of the stream as we
need to access.  We can exploit this technique to represent sequences
efficiently as streams, even if the sequences are very long.  What is more
striking, we can use streams to represent sequences that are infinitely long.
For instance, consider the following definition of the stream of positive
integers:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">integers-starting-from n</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">cons-stream 
   n </span><span class="opn">(</span><span class="pln">integers-starting-from </span><span class="opn">(</span><span class="pun">+</span><span class="pln"> n </span><span class="lit">1</span><span class="clo">))))</span><span class="pln">
</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> integers </span><span class="opn">(</span><span class="pln">integers-starting-from </span><span class="lit">1</span><span class="clo">))</span></pre></div>

<p>This makes sense because <code>integers</code> will be a pair whose <code>car</code> is 1
and whose <code>cdr</code> is a promise to produce the integers beginning with 2.
This is an infinitely long stream, but in any given time we can examine only a
finite portion of it.  Thus, our programs will never know that the entire
infinite stream is not there.
</p>
<p>Using <code>integers</code> we can define other infinite streams, such as the stream
of integers that are not divisible by 7:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">divisible? x y</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pun">=</span><span class="pln"> </span><span class="opn">(</span><span class="pln">remainder x y</span><span class="clo">)</span><span class="pln"> </span><span class="lit">0</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> no-sevens
  </span><span class="opn">(</span><span class="pln">stream-filter </span><span class="opn">(</span><span class="kwd">lambda</span><span class="pln"> </span><span class="opn">(</span><span class="pln">x</span><span class="clo">)</span><span class="pln"> 
                   </span><span class="opn">(</span><span class="pln">not </span><span class="opn">(</span><span class="pln">divisible? x </span><span class="lit">7</span><span class="clo">)))</span><span class="pln">
                 integers</span><span class="clo">))</span></pre></div>

<p>Then we can find integers not divisible by 7 simply by accessing elements of
this stream:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="pln">stream-ref no-sevens </span><span class="lit">100</span><span class="clo">)</span><span class="pln">
</span><i><span class="lit">117</span></i>
</pre></div>

<p>In analogy with <code>integers</code>, we can define the infinite stream of Fibonacci
numbers:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">fibgen a b</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">cons-stream a </span><span class="opn">(</span><span class="pln">fibgen b </span><span class="opn">(</span><span class="pun">+</span><span class="pln"> a b</span><span class="clo">))))</span><span class="pln">
</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> fibs </span><span class="opn">(</span><span class="pln">fibgen </span><span class="lit">0</span><span class="pln"> </span><span class="lit">1</span><span class="clo">))</span></pre></div>

<p><code>Fibs</code> is a pair whose <code>car</code> is 0 and whose <code>cdr</code> is a promise
to evaluate <code>(fibgen 1 1)</code>.  When we evaluate this delayed <code>(fibgen 1
1)</code>, it will produce a pair whose <code>car</code> is 1 and whose <code>cdr</code> is a
promise to evaluate <code>(fibgen 1 2)</code>, and so on.
</p>
<p>For a look at a more exciting infinite stream, we can generalize the
<code>no-sevens</code> example to construct the infinite stream of prime numbers,
using a method known as the <a id="index-sieve-of-Eratosthenes"></a>
<em>sieve of Eratosthenes</em>.<a class="footnote_link" id="DOCF188" href="#FOOT188"><sup>188</sup></a>
We start with the integers beginning with 2, which is the first prime.  To get
the rest of the primes, we start by filtering the multiples of 2 from the rest
of the integers.  This leaves a stream beginning with 3, which is the next
prime.  Now we filter the multiples of 3 from the rest of this stream.  This
leaves a stream beginning with 5, which is the next prime, and so on.  In other
words, we construct the primes by a sieving process, described as follows: To
sieve a stream <code>S</code>, form a stream whose first element is the first element
of <code>S</code> and the rest of which is obtained by filtering all multiples of the
first element of <code>S</code> out of the rest of <code>S</code> and sieving the
result. This process is readily described in terms of stream operations:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">sieve stream</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">cons-stream
   </span><span class="opn">(</span><span class="pln">stream-car stream</span><span class="clo">)</span><span class="pln">
   </span><span class="opn">(</span><span class="pln">sieve </span><span class="opn">(</span><span class="pln">stream-filter
           </span><span class="opn">(</span><span class="kwd">lambda</span><span class="pln"> </span><span class="opn">(</span><span class="pln">x</span><span class="clo">)</span><span class="pln">
             </span><span class="opn">(</span><span class="pln">not </span><span class="opn">(</span><span class="pln">divisible? 
                   x </span><span class="opn">(</span><span class="pln">stream-car stream</span><span class="clo">))))</span><span class="pln">
           </span><span class="opn">(</span><span class="pln">stream-cdr stream</span><span class="clo">)))))</span><span class="pln">

</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> primes 
  </span><span class="opn">(</span><span class="pln">sieve </span><span class="opn">(</span><span class="pln">integers-starting-from </span><span class="lit">2</span><span class="clo">)))</span></pre></div>

<p>Now to find a particular prime we need only ask for it:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="pln">stream-ref primes </span><span class="lit">50</span><span class="clo">)</span><span class="pln">
</span><i><span class="lit">233</span></i>
</pre></div>

<p>It is interesting to contemplate the signal-processing system set up by
<code>sieve</code>, shown in the “Henderson diagram” in 
<a href="#Figure-3_002e31">Figure 3.31</a>.<a class="footnote_link" id="DOCF189" href="#FOOT189"><sup>189</sup></a>  The input stream
feeds into an “un<code>cons</code>er” that separates the first element of the
stream from the rest of the stream.  The first element is used to construct a
divisibility filter, through which the rest is passed, and the output of the
filter is fed to another sieve box.  Then the original first element is
<code>cons</code>ed onto the output of the internal sieve to form the output stream.
Thus, not only is the stream infinite, but the signal processor is also
infinite, because the sieve contains a sieve within it.
</p>
<figure class="float">
<a id="Figure-3_002e31"></a>
<object style="width: 54.05ex; height: 27.89ex;" data="fig/chap3/Fig3.31a.std.svg" type="image/svg+xml">SVG</object>

<figcaption class="float-caption">
<p><strong>Figure 3.31:</strong> The prime sieve viewed as a signal-processing system.</p>
</figcaption>
</figure>

<a id="Defining-streams-implicitly"></a>
<h5 class="subsubheading">Defining streams implicitly</h5>

<p>The <code>integers</code> and <code>fibs</code> streams above were defined by specifying
“generating” procedures that explicitly compute the stream elements one by
one. An alternative way to specify streams is to take advantage of delayed
evaluation to define streams implicitly.  For example, the following expression
defines the stream <code>ones</code> to be an infinite stream of ones:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> ones </span><span class="opn">(</span><span class="pln">cons-stream </span><span class="lit">1</span><span class="pln"> ones</span><span class="clo">))</span></pre></div>

<p>This works much like the definition of a recursive procedure: <code>ones</code> is a
pair whose <code>car</code> is 1 and whose <code>cdr</code> is a promise to evaluate
<code>ones</code>.  Evaluating the <code>cdr</code> gives us again a 1 and a promise to
evaluate <code>ones</code>, and so on.
</p>
<p>We can do more interesting things by manipulating streams with operations such
as <code>add-streams</code>, which produces the elementwise sum of two given
streams:<a class="footnote_link" id="DOCF190" href="#FOOT190"><sup>190</sup></a>
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">add-streams s1 s2</span><span class="clo">)</span><span class="pln"> 
  </span><span class="opn">(</span><span class="pln">stream-map </span><span class="pun">+</span><span class="pln"> s1 s2</span><span class="clo">))</span></pre></div>

<p>Now we can define the integers as follows:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> integers 
  </span><span class="opn">(</span><span class="pln">cons-stream </span><span class="lit">1</span><span class="pln"> </span><span class="opn">(</span><span class="pln">add-streams ones integers</span><span class="clo">)))</span></pre></div>

<p>This defines <code>integers</code> to be a stream whose first element is 1 and the
rest of which is the sum of <code>ones</code> and <code>integers</code>.  Thus, the second
element of <code>integers</code> is 1 plus the first element of <code>integers</code>, or
2; the third element of <code>integers</code> is 1 plus the second element of
<code>integers</code>, or 3; and so on.  This definition works because, at any point,
enough of the <code>integers</code> stream has been generated so that we can feed it
back into the definition to produce the next integer.
</p>
<p>We can define the Fibonacci numbers in the same style:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> fibs 
  </span><span class="opn">(</span><span class="pln">cons-stream 
   </span><span class="lit">0</span><span class="pln"> </span><span class="opn">(</span><span class="pln">cons-stream </span><span class="lit">1</span><span class="pln"> </span><span class="opn">(</span><span class="pln">add-streams 
                     </span><span class="opn">(</span><span class="pln">stream-cdr fibs</span><span class="clo">)</span><span class="pln"> fibs</span><span class="clo">))))</span></pre></div>

<p>This definition says that <code>fibs</code> is a stream beginning with 0 and 1, such
that the rest of the stream can be generated by adding <code>fibs</code> to itself
shifted by one place:
</p>
<div class="example">
<pre class="example">    1 1 2 3 5  8 13 21 <span class="roman">…</span> = <code>(stream-cdr fibs)</code>
    0 1 1 2 3  5  8 13 <span class="roman">…</span> = <code>fibs</code>
0 1 1 2 3 5 8 13 21 34 <span class="roman">…</span> = <code>fibs</code>
</pre></div>

<p><code>Scale-stream</code> is another useful procedure in formulating such stream
definitions.  This multiplies each item in a stream by a given constant:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">scale-stream stream factor</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">stream-map
   </span><span class="opn">(</span><span class="kwd">lambda</span><span class="pln"> </span><span class="opn">(</span><span class="pln">x</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pun">*</span><span class="pln"> x factor</span><span class="clo">))</span><span class="pln"> stream</span><span class="clo">))</span></pre></div>

<p>For example,
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> double 
  </span><span class="opn">(</span><span class="pln">cons-stream </span><span class="lit">1</span><span class="pln"> </span><span class="opn">(</span><span class="pln">scale-stream double </span><span class="lit">2</span><span class="clo">)))</span></pre></div>

<p>produces the stream of powers of 2: 1, 2, 4, 8, 16, 32, ….
</p>
<p>An alternate definition of the stream of primes can be given by starting with
the integers and filtering them by testing for primality.  We will need the
first prime, 2, to get started:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> primes
  </span><span class="opn">(</span><span class="pln">cons-stream
   </span><span class="lit">2</span><span class="pln"> </span><span class="opn">(</span><span class="pln">stream-filter 
      prime? </span><span class="opn">(</span><span class="pln">integers-starting-from </span><span class="lit">3</span><span class="clo">))))</span></pre></div>

<p>This definition is not so straightforward as it appears, because we will test
whether a number <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>n</mi>
</math> is prime by checking whether <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>n</mi>
</math> is divisible by a
prime (not by just any integer) less than or equal to <math xmlns="http://www.w3.org/1998/Math/MathML">
  <msqrt>
    <mi>n</mi>
  </msqrt>
</math>:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">prime? n</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">iter ps</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="kwd">cond</span><span class="pln"> </span><span class="opn">((</span><span class="pun">&gt;</span><span class="pln"> </span><span class="opn">(</span><span class="pln">square </span><span class="opn">(</span><span class="pln">stream-car ps</span><span class="clo">))</span><span class="pln"> n</span><span class="clo">)</span><span class="pln"> true</span><span class="clo">)</span><span class="pln">
          </span><span class="opn">((</span><span class="pln">divisible? n </span><span class="opn">(</span><span class="pln">stream-car ps</span><span class="clo">))</span><span class="pln"> 
           false</span><span class="clo">)</span><span class="pln">
          </span><span class="opn">(</span><span class="kwd">else</span><span class="pln"> </span><span class="opn">(</span><span class="pln">iter </span><span class="opn">(</span><span class="pln">stream-cdr ps</span><span class="clo">)))))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">iter primes</span><span class="clo">))</span></pre></div>

<p>This is a recursive definition, since <code>primes</code> is defined in terms of the
<code>prime?</code> predicate, which itself uses the <code>primes</code> stream.  The
reason this procedure works is that, at any point, enough of the <code>primes</code>
stream has been generated to test the primality of the numbers we need to check
next.  That is, for every <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>n</mi>
</math> we test for primality, either <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>n</mi>
</math> is not
prime (in which case there is a prime already generated that divides it) or
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>n</mi>
</math> is prime (in which case there is a prime already generated—i.e., a
prime less than <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>n</mi>
</math>—that is greater than
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <msqrt>
    <mi>n</mi>
  </msqrt>
</math>).<a class="footnote_link" id="DOCF191" href="#FOOT191"><sup>191</sup></a>
</p>
<blockquote>
<p><strong><a id="Exercise-3_002e53"></a>Exercise 3.53:</strong> Without running the program,
describe the elements of the stream defined by
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> s </span><span class="opn">(</span><span class="pln">cons-stream </span><span class="lit">1</span><span class="pln"> </span><span class="opn">(</span><span class="pln">add-streams s s</span><span class="clo">)))</span></pre></div>
</blockquote>

<blockquote>
<p><strong><a id="Exercise-3_002e54"></a>Exercise 3.54:</strong> Define a procedure
<code>mul-streams</code>, analogous to <code>add-streams</code>, that produces the
elementwise product of its two input streams.  Use this together with the
stream of <code>integers</code> to complete the following definition of the stream
whose <math xmlns="http://www.w3.org/1998/Math/MathML">
  <msup>
    <mi>n</mi>
    <mrow class="MJX-TeXAtom-ORD">
      <mtext>th</mtext>
    </mrow>
  </msup>
</math> element (counting from 0) is <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
  </mrow>
</math> factorial:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> factorials 
  </span><span class="opn">(</span><span class="pln">cons-stream </span><span class="lit">1</span><span class="pln"> </span><span class="opn">(</span><span class="pln">mul-streams ⟨</span><span class="pun">??</span><span class="pln">⟩ ⟨</span><span class="pun">??</span><span class="pln">⟩</span><span class="clo">)))</span></pre></div>
</blockquote>

<blockquote>
<p><strong><a id="Exercise-3_002e55"></a>Exercise 3.55:</strong> Define a procedure
<code>partial-sums</code> that takes as argument a stream <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>S</mi>
</math> and returns the
stream whose elements are <math xmlns="http://www.w3.org/1998/Math/MathML">
  <msub>
    <mi>S</mi>
    <mn>0</mn>
  </msub>
</math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <msub>
      <mi>S</mi>
      <mn>0</mn>
    </msub>
    <mo>+</mo>
    <msub>
      <mi>S</mi>
      <mn>1</mn>
    </msub>
  </mrow>
</math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <msub>
      <mi>S</mi>
      <mn>0</mn>
    </msub>
    <mo>+</mo>
    <msub>
      <mi>S</mi>
      <mn>1</mn>
    </msub>
  </mrow>
  <mo>+</mo>
  <mrow class="MJX-TeXAtom-ORD">
    <msub>
      <mi>S</mi>
      <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mo>…<!-- … --></mo>
  </mrow>
</math>.  
For example, <code>(partial-sums integers)</code> should be the
stream 1, 3, 6, 10, 15, ….
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-3_002e56"></a>Exercise 3.56:</strong> A famous problem, first raised by
R. Hamming, is to enumerate, in ascending order with no repetitions, all
positive integers with no prime factors other than 2, 3, or 5.  One obvious way
to do this is to simply test each integer in turn to see whether it has any
factors other than 2, 3, and 5.  But this is very inefficient, since, as the
integers get larger, fewer and fewer of them fit the requirement.  As an
alternative, let us call the required stream of numbers <code>S</code> and notice the
following facts about it.
</p>
<ul>
<li> <code>S</code> begins with 1.

</li><li> The elements of <code>(scale-stream S 2)</code> are also
elements of <code>S</code>.

</li><li> The same is true for <code>(scale-stream S 3)</code>
and <code>(scale-stream 5 S)</code>.

</li><li> These are all the elements of <code>S</code>.

</li></ul>

<p>Now all we have to do is combine elements from these sources.  For this we
define a procedure <code>merge</code> that combines two ordered streams into one
ordered result stream, eliminating repetitions:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">merge s1 s2</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">cond</span><span class="pln"> </span><span class="opn">((</span><span class="pln">stream-null? s1</span><span class="clo">)</span><span class="pln"> s2</span><span class="clo">)</span><span class="pln">
        </span><span class="opn">((</span><span class="pln">stream-null? s2</span><span class="clo">)</span><span class="pln"> s1</span><span class="clo">)</span><span class="pln">
        </span><span class="opn">(</span><span class="kwd">else</span><span class="pln">
         </span><span class="opn">(</span><span class="kwd">let</span><span class="pln"> </span><span class="opn">((</span><span class="pln">s1car </span><span class="opn">(</span><span class="pln">stream-car s1</span><span class="clo">))</span><span class="pln">
               </span><span class="opn">(</span><span class="pln">s2car </span><span class="opn">(</span><span class="pln">stream-car s2</span><span class="clo">)))</span><span class="pln">
           </span><span class="opn">(</span><span class="kwd">cond</span><span class="pln"> </span><span class="opn">((</span><span class="pun">&lt;</span><span class="pln"> s1car s2car</span><span class="clo">)</span><span class="pln">
                  </span><span class="opn">(</span><span class="pln">cons-stream 
                   s1car 
                   </span><span class="opn">(</span><span class="pln">merge </span><span class="opn">(</span><span class="pln">stream-cdr s1</span><span class="clo">)</span><span class="pln"> 
                          s2</span><span class="clo">)))</span><span class="pln">
                 </span><span class="opn">((</span><span class="pun">&gt;</span><span class="pln"> s1car s2car</span><span class="clo">)</span><span class="pln">
                  </span><span class="opn">(</span><span class="pln">cons-stream 
                   s2car 
                   </span><span class="opn">(</span><span class="pln">merge s1 
                          </span><span class="opn">(</span><span class="pln">stream-cdr s2</span><span class="clo">))))</span><span class="pln">
                 </span><span class="opn">(</span><span class="kwd">else</span><span class="pln">
                  </span><span class="opn">(</span><span class="pln">cons-stream 
                   s1car
                   </span><span class="opn">(</span><span class="pln">merge 
                    </span><span class="opn">(</span><span class="pln">stream-cdr s1</span><span class="clo">)</span><span class="pln">
                    </span><span class="opn">(</span><span class="pln">stream-cdr s2</span><span class="clo">)))))))))</span></pre></div>

<p>Then the required stream may be constructed with <code>merge</code>, as follows:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> S </span><span class="opn">(</span><span class="pln">cons-stream </span><span class="lit">1</span><span class="pln"> </span><span class="opn">(</span><span class="pln">merge ⟨</span><span class="pun">??</span><span class="pln">⟩ ⟨</span><span class="pun">??</span><span class="pln">⟩</span><span class="clo">)))</span></pre></div>

<p>Fill in the missing expressions in the places marked <code>⟨??⟩</code> above.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-3_002e57"></a>Exercise 3.57:</strong> How many additions are performed
when we compute the <math xmlns="http://www.w3.org/1998/Math/MathML">
  <msup>
    <mi>n</mi>
    <mrow class="MJX-TeXAtom-ORD">
      <mtext>th</mtext>
    </mrow>
  </msup>
</math> Fibonacci number using the definition of
<code>fibs</code> based on the <code>add-streams</code> procedure?  Show that the number of
additions would be exponentially greater if we had implemented <code>(delay ⟨<var>exp</var>⟩)</code> 
simply as <code>(lambda () ⟨<var>exp</var>⟩)</code>, without using the
optimization provided by the <code>memo-proc</code> procedure described in 
<a href="3_002e5_002e1.xhtml#g_t3_002e5_002e1">3.5.1</a>.<a class="footnote_link" id="DOCF192" href="#FOOT192"><sup>192</sup></a>
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-3_002e58"></a>Exercise 3.58:</strong> Give an interpretation of the
stream computed by the following procedure:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">expand num den radix</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">cons-stream
   </span><span class="opn">(</span><span class="pln">quotient </span><span class="opn">(</span><span class="pun">*</span><span class="pln"> num radix</span><span class="clo">)</span><span class="pln"> den</span><span class="clo">)</span><span class="pln">
   </span><span class="opn">(</span><span class="pln">expand </span><span class="opn">(</span><span class="pln">remainder </span><span class="opn">(</span><span class="pun">*</span><span class="pln"> num radix</span><span class="clo">)</span><span class="pln"> den</span><span class="clo">)</span><span class="pln"> 
           den 
           radix</span><span class="clo">)))</span></pre></div>

<p>(<code>Quotient</code> is a primitive that returns the integer quotient of two
integers.)  What are the successive elements produced by <code>(expand 1 7
10)</code>?  What is produced by <code>(expand 3 8 10)</code>?
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-3_002e59"></a>Exercise 3.59:</strong> In <a href="2_002e5_002e3.xhtml#g_t2_002e5_002e3">2.5.3</a> we saw how
to implement a polynomial arithmetic system representing polynomials as lists
of terms.  In a similar way, we can work with <a id="index-power-series"></a>
<em>power series</em>, such as
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mtable columnalign="right center left" rowspacing="3pt" columnspacing="thickmathspace">
    <mtr>
      <mtd>
        <msup>
          <mi>e</mi>
          <mi>x</mi>
        </msup>
      </mtd>
      <mtd>
        <mo>=</mo>
      </mtd>
      <mtd>
        <mn>1</mn>
        <mo>+</mo>
        <mi>x</mi>
        <mo>+</mo>
        <mrow class="MJX-TeXAtom-ORD">
          <mfrac>
            <msup>
              <mi>x</mi>
              <mn>2</mn>
            </msup>
            <mn>2</mn>
          </mfrac>
        </mrow>
        <mo>+</mo>
        <mrow class="MJX-TeXAtom-ORD">
          <mfrac>
            <msup>
              <mi>x</mi>
              <mn>3</mn>
            </msup>
            <mrow>
              <mn>3</mn>
              <mo>⋅<!-- ⋅ --></mo>
              <mn>2</mn>
            </mrow>
          </mfrac>
        </mrow>
        <mo>+</mo>
        <mrow class="MJX-TeXAtom-ORD">
          <mfrac>
            <msup>
              <mi>x</mi>
              <mn>4</mn>
            </msup>
            <mrow>
              <mn>4</mn>
              <mo>⋅<!-- ⋅ --></mo>
              <mn>3</mn>
              <mo>⋅<!-- ⋅ --></mo>
              <mn>2</mn>
            </mrow>
          </mfrac>
        </mrow>
        <mo>+</mo>
        <mo>…<!-- … --></mo>
        <mo>,</mo>
      </mtd>
    </mtr>
    <mtr>
      <mtd>
        <mi>cos</mi>
        <mo>⁡<!-- ⁡ --></mo>
        <mi>x</mi>
      </mtd>
      <mtd>
        <mo>=</mo>
      </mtd>
      <mtd>
        <mn>1</mn>
        <mo>−<!-- − --></mo>
        <mrow class="MJX-TeXAtom-ORD">
          <mfrac>
            <msup>
              <mi>x</mi>
              <mn>2</mn>
            </msup>
            <mn>2</mn>
          </mfrac>
        </mrow>
        <mo>+</mo>
        <mrow class="MJX-TeXAtom-ORD">
          <mfrac>
            <msup>
              <mi>x</mi>
              <mn>4</mn>
            </msup>
            <mrow>
              <mn>4</mn>
              <mo>⋅<!-- ⋅ --></mo>
              <mn>3</mn>
              <mo>⋅<!-- ⋅ --></mo>
              <mn>2</mn>
            </mrow>
          </mfrac>
        </mrow>
        <mo>−<!-- − --></mo>
        <mo>…<!-- … --></mo>
        <mo>,</mo>
      </mtd>
    </mtr>
    <mtr>
      <mtd>
        <mi>sin</mi>
        <mo>⁡<!-- ⁡ --></mo>
        <mi>x</mi>
      </mtd>
      <mtd>
        <mo>=</mo>
      </mtd>
      <mtd>
        <mi>x</mi>
        <mo>−<!-- − --></mo>
        <mrow class="MJX-TeXAtom-ORD">
          <mfrac>
            <msup>
              <mi>x</mi>
              <mn>3</mn>
            </msup>
            <mrow>
              <mn>3</mn>
              <mo>⋅<!-- ⋅ --></mo>
              <mn>2</mn>
            </mrow>
          </mfrac>
        </mrow>
        <mo>+</mo>
        <mrow class="MJX-TeXAtom-ORD">
          <mfrac>
            <msup>
              <mi>x</mi>
              <mn>5</mn>
            </msup>
            <mrow>
              <mn>5</mn>
              <mo>⋅<!-- ⋅ --></mo>
              <mn>4</mn>
              <mo>⋅<!-- ⋅ --></mo>
              <mn>3</mn>
              <mo>⋅<!-- ⋅ --></mo>
              <mn>2</mn>
            </mrow>
          </mfrac>
        </mrow>
        <mo>−<!-- − --></mo>
        <mo>…<!-- … --></mo>
      </mtd>
    </mtr>
  </mtable>
</math>
represented as infinite streams.  We will represent the series <math xmlns="http://www.w3.org/1998/Math/MathML">
  <msub>
    <mi>a</mi>
    <mn>0</mn>
  </msub>
  <mo>+</mo>
  <msub>
    <mi>a</mi>
    <mn>1</mn>
  </msub>
  <mi>x</mi>
  <mo>+</mo>
  <msub>
    <mi>a</mi>
    <mn>2</mn>
  </msub>
  <msup>
    <mi>x</mi>
    <mn>2</mn>
  </msup>
  <mo>+</mo>
  <msub>
    <mi>a</mi>
    <mn>3</mn>
  </msub>
  <msup>
    <mi>x</mi>
    <mn>3</mn>
  </msup>
  <mo>+</mo>
  <mo>…<!-- … --></mo>
</math> as the stream whose
elements are the coefficients <math xmlns="http://www.w3.org/1998/Math/MathML">
  <msub>
    <mi>a</mi>
    <mn>0</mn>
  </msub>
</math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
  <msub>
    <mi>a</mi>
    <mn>1</mn>
  </msub>
</math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
  <msub>
    <mi>a</mi>
    <mn>2</mn>
  </msub>
</math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
  <msub>
    <mi>a</mi>
    <mn>3</mn>
  </msub>
</math>, ….
</p>
<ol>
<li> The integral of the series <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <msub>
      <mi>a</mi>
      <mn>0</mn>
    </msub>
    <mo>+</mo>
    <msub>
      <mi>a</mi>
      <mn>1</mn>
    </msub>
    <mi>x</mi>
  </mrow>
  <mo>+</mo>
  <mrow class="MJX-TeXAtom-ORD">
    <msub>
      <mi>a</mi>
      <mn>2</mn>
    </msub>
    <msup>
      <mi>x</mi>
      <mn>2</mn>
    </msup>
  </mrow>
  <mo>+</mo>
  <mrow class="MJX-TeXAtom-ORD">
    <msub>
      <mi>a</mi>
      <mn>3</mn>
    </msub>
    <msup>
      <mi>x</mi>
      <mn>3</mn>
    </msup>
    <mo>+</mo>
    <mo>…<!-- … --></mo>
  </mrow>
</math> is the series
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mi>c</mi>
  <mo>+</mo>
  <mrow class="MJX-TeXAtom-ORD">
    <msub>
      <mi>a</mi>
      <mn>0</mn>
    </msub>
    <mi>x</mi>
  </mrow>
  <mo>+</mo>
  <mrow class="MJX-TeXAtom-ORD">
    <mrow class="MJX-TeXAtom-ORD">
      <mfrac>
        <mn>1</mn>
        <mn>2</mn>
      </mfrac>
    </mrow>
    <msub>
      <mi>a</mi>
      <mn>1</mn>
    </msub>
    <msup>
      <mi>x</mi>
      <mn>2</mn>
    </msup>
  </mrow>
  <mo>+</mo>
  <mrow class="MJX-TeXAtom-ORD">
    <mrow class="MJX-TeXAtom-ORD">
      <mfrac>
        <mn>1</mn>
        <mn>3</mn>
      </mfrac>
    </mrow>
    <msub>
      <mi>a</mi>
      <mn>2</mn>
    </msub>
    <msup>
      <mi>x</mi>
      <mn>3</mn>
    </msup>
  </mrow>
  <mo>+</mo>
  <mrow class="MJX-TeXAtom-ORD">
    <mrow class="MJX-TeXAtom-ORD">
      <mfrac>
        <mn>1</mn>
        <mn>4</mn>
      </mfrac>
    </mrow>
    <msub>
      <mi>a</mi>
      <mn>3</mn>
    </msub>
    <msup>
      <mi>x</mi>
      <mn>4</mn>
    </msup>
    <mo>+</mo>
    <mo>…<!-- … --></mo>
    <mo>,</mo>
  </mrow>
</math>
where <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>c</mi>
</math> is any constant.  Define a procedure <code>integrate-series</code> that
takes as input a stream <math xmlns="http://www.w3.org/1998/Math/MathML">
  <msub>
    <mi>a</mi>
    <mn>0</mn>
  </msub>
</math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
  <msub>
    <mi>a</mi>
    <mn>1</mn>
  </msub>
</math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
  <msub>
    <mi>a</mi>
    <mn>2</mn>
  </msub>
</math>, … representing a power
series and returns the stream <math xmlns="http://www.w3.org/1998/Math/MathML">
  <msub>
    <mi>a</mi>
    <mn>0</mn>
  </msub>
</math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mrow class="MJX-TeXAtom-ORD">
      <mfrac>
        <mn>1</mn>
        <mn>2</mn>
      </mfrac>
    </mrow>
    <msub>
      <mi>a</mi>
      <mn>1</mn>
    </msub>
  </mrow>
</math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mrow class="MJX-TeXAtom-ORD">
      <mfrac>
        <mn>1</mn>
        <mn>3</mn>
      </mfrac>
    </mrow>
    <msub>
      <mi>a</mi>
      <mn>2</mn>
    </msub>
  </mrow>
</math>, … of
coefficients of the non-constant terms of the integral of the series.  (Since
the result has no constant term, it doesn’t represent a power series; when we
use <code>integrate-series</code>, we will <code>cons</code> on the appropriate constant.)

</li><li> The function <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mi>x</mi>
    <mo stretchy="false">↦<!-- ↦ --></mo>
    <msup>
      <mi>e</mi>
      <mi>x</mi>
    </msup>
  </mrow>
</math> is its own derivative.  This implies that
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <msup>
    <mi>e</mi>
    <mi>x</mi>
  </msup>
</math> and the integral of <math xmlns="http://www.w3.org/1998/Math/MathML">
  <msup>
    <mi>e</mi>
    <mi>x</mi>
  </msup>
</math> are the same series, except for the
constant term, which is <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <msup>
      <mi>e</mi>
      <mn>0</mn>
    </msup>
    <mo>=</mo>
    <mn>1</mn>
  </mrow>
</math>.  Accordingly, we can generate the series
for <math xmlns="http://www.w3.org/1998/Math/MathML">
  <msup>
    <mi>e</mi>
    <mi>x</mi>
  </msup>
</math> as

<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> exp-series
  </span><span class="opn">(</span><span class="pln">cons-stream 
   </span><span class="lit">1</span><span class="pln"> 
   </span><span class="opn">(</span><span class="pln">integrate-series exp-series</span><span class="clo">)))</span></pre></div>

<p>Show how to generate the series for sine and cosine, starting from the facts
that the derivative of sine is cosine and the derivative of cosine is the
negative of sine:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> cosine-series 
  </span><span class="opn">(</span><span class="pln">cons-stream </span><span class="lit">1</span><span class="pln"> ⟨</span><span class="pun">??</span><span class="pln">⟩</span><span class="clo">))</span><span class="pln">

</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> sine-series
  </span><span class="opn">(</span><span class="pln">cons-stream </span><span class="lit">0</span><span class="pln"> ⟨</span><span class="pun">??</span><span class="pln">⟩</span><span class="clo">))</span></pre></div>
</li></ol>
</blockquote>

<blockquote>
<p><strong><a id="Exercise-3_002e60"></a>Exercise 3.60:</strong> With power series represented as
streams of coefficients as in <a href="#Exercise-3_002e59">Exercise 3.59</a>, adding series is implemented
by <code>add-streams</code>.  Complete the definition of the following procedure for
multiplying series:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">mul-series s1 s2</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">cons-stream ⟨</span><span class="pun">??</span><span class="pln">⟩ </span><span class="opn">(</span><span class="pln">add-streams ⟨</span><span class="pun">??</span><span class="pln">⟩ ⟨</span><span class="pun">??</span><span class="pln">⟩</span><span class="clo">)))</span></pre></div>

<p>You can test your procedure by verifying that <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <msup>
      <mi>sin</mi>
      <mn>2</mn>
    </msup>
    <mo>⁡<!-- ⁡ --></mo>
    <mi>x</mi>
    <mo>+</mo>
    <msup>
      <mi>cos</mi>
      <mn>2</mn>
    </msup>
    <mo>⁡<!-- ⁡ --></mo>
    <mi>x</mi>
    <mo>=</mo>
    <mn>1</mn>
    <mo>,</mo>
  </mrow>
</math>
using the series from <a href="#Exercise-3_002e59">Exercise 3.59</a>.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-3_002e61"></a>Exercise 3.61:</strong> Let <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>S</mi>
</math> be a power series
(<a href="#Exercise-3_002e59">Exercise 3.59</a>) whose constant term is 1.  Suppose we want to find the
power series <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mn>1</mn>
    <mrow class="MJX-TeXAtom-ORD">
      <mo>/</mo>
    </mrow>
    <mi>S</mi>
  </mrow>
</math>, that is, the series <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>X</mi>
</math> such that <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mi>S</mi>
    <mi>X</mi>
    <mo>=</mo>
    <mn>1</mn>
  </mrow>
</math>.
Write <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mi>S</mi>
    <mo>=</mo>
    <mn>1</mn>
    <mo>+</mo>
    <msub>
      <mi>S</mi>
      <mi>R</mi>
    </msub>
  </mrow>
</math> where <math xmlns="http://www.w3.org/1998/Math/MathML">
  <msub>
    <mi>S</mi>
    <mi>R</mi>
  </msub>
</math> is the part of <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>S</mi>
</math> after the
constant term.  Then we can solve for <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>X</mi>
</math> as follows:
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mtable columnalign="right center left" rowspacing="3pt" columnspacing="thickmathspace">
    <mtr>
      <mtd>
        <mi>S</mi>
        <mo>⋅<!-- ⋅ --></mo>
        <mi>X</mi>
      </mtd>
      <mtd>
        <mo>=</mo>
      </mtd>
      <mtd>
        <mn>1</mn>
        <mo>,</mo>
      </mtd>
    </mtr>
    <mtr>
      <mtd>
        <mo stretchy="false">(</mo>
        <mn>1</mn>
        <mo>+</mo>
        <msub>
          <mi>S</mi>
          <mi>R</mi>
        </msub>
        <mo stretchy="false">)</mo>
        <mo>⋅<!-- ⋅ --></mo>
        <mi>X</mi>
      </mtd>
      <mtd>
        <mo>=</mo>
      </mtd>
      <mtd>
        <mn>1</mn>
        <mo>,</mo>
      </mtd>
    </mtr>
    <mtr>
      <mtd>
        <mi>X</mi>
        <mo>+</mo>
        <msub>
          <mi>S</mi>
          <mi>R</mi>
        </msub>
        <mo>⋅<!-- ⋅ --></mo>
        <mi>X</mi>
      </mtd>
      <mtd>
        <mo>=</mo>
      </mtd>
      <mtd>
        <mn>1</mn>
        <mo>,</mo>
      </mtd>
    </mtr>
    <mtr>
      <mtd>
        <mi>X</mi>
      </mtd>
      <mtd>
        <mo>=</mo>
      </mtd>
      <mtd>
        <mn>1</mn>
        <mo>−<!-- − --></mo>
        <msub>
          <mi>S</mi>
          <mi>R</mi>
        </msub>
        <mo>⋅<!-- ⋅ --></mo>
        <mi>X</mi>
        <mo>.</mo>
      </mtd>
    </mtr>
  </mtable>
</math>
In other words, <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>X</mi>
</math> is the power series whose constant term is 1 and whose
higher-order terms are given by the negative of <math xmlns="http://www.w3.org/1998/Math/MathML">
  <msub>
    <mi>S</mi>
    <mi>R</mi>
  </msub>
</math> times <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>X</mi>
</math>.  Use
this idea to write a procedure <code>invert-unit-series</code> that computes <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mn>1</mn>
    <mrow class="MJX-TeXAtom-ORD">
      <mo>/</mo>
    </mrow>
    <mi>S</mi>
  </mrow>
</math>
for a power series <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>S</mi>
</math> with constant term 1.  You will need to use
<code>mul-series</code> from <a href="#Exercise-3_002e60">Exercise 3.60</a>.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-3_002e62"></a>Exercise 3.62:</strong> Use the results of <a href="#Exercise-3_002e60">Exercise 3.60</a> 
and <a href="#Exercise-3_002e61">Exercise 3.61</a> to define a procedure <code>div-series</code> that
divides two power series.  <code>Div-series</code> should work for any two series,
provided that the denominator series begins with a nonzero constant term.  (If
the denominator has a zero constant term, then <code>div-series</code> should signal
an error.)  Show how to use <code>div-series</code> together with the result of
<a href="#Exercise-3_002e59">Exercise 3.59</a> to generate the power series for tangent.
</p></blockquote>

<div class="footnote">
<hr />

<h4 class="footnotes-heading">Footnotes</h4>

<div id="FOOT188"><p><a class="footnote_backlink" href="#DOCF188"><sup>188</sup></a>
Eratosthenes, a third-century <abbr>B.C.</abbr>
Alexandrian Greek philosopher, is famous for giving the first accurate estimate
of the circumference of the Earth, which he computed by observing shadows cast
at noon on the day of the summer solstice.  Eratosthenes’s sieve method,
although ancient, has formed the basis for special-purpose hardware “sieves”
that, until recently, were the most powerful tools in existence for locating
large primes.  Since the 70s, however, these methods have been superseded by
outgrowths of the probabilistic techniques discussed in <a href="1_002e2_002e6.xhtml#g_t1_002e2_002e6">1.2.6</a>.</p>
</div>
<div id="FOOT189"><p><a class="footnote_backlink" href="#DOCF189"><sup>189</sup></a>
We have named these figures after Peter Henderson, who was the
first person to show us diagrams of this sort as a way of thinking about stream
processing.  Each solid line represents a stream of values being transmitted.
The dashed line from the <code>car</code> to the <code>cons</code> and the <code>filter</code>
indicates that this is a single value rather than a stream.</p>
</div>
<div id="FOOT190"><p><a class="footnote_backlink" href="#DOCF190"><sup>190</sup></a>
This uses the generalized version of <code>stream-map</code> from
<a href="3_002e5_002e1.xhtml#Exercise-3_002e50">Exercise 3.50</a>.</p>
</div>
<div id="FOOT191"><p><a class="footnote_backlink" href="#DOCF191"><sup>191</sup></a>
This last point is very subtle and relies on
the fact that <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <msub>
      <mi>p</mi>
      <mrow class="MJX-TeXAtom-ORD">
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
      </mrow>
    </msub>
    <mo>≤<!-- ≤ --></mo>
    <msubsup>
      <mi>p</mi>
      <mi>n</mi>
      <mn>2</mn>
    </msubsup>
  </mrow>
  <mo>.</mo>
</math>  (Here, <math xmlns="http://www.w3.org/1998/Math/MathML">
  <msub>
    <mi>p</mi>
    <mi>k</mi>
  </msub>
</math> denotes the
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <msup>
    <mi>k</mi>
    <mrow class="MJX-TeXAtom-ORD">
      <mtext>th</mtext>
    </mrow>
  </msup>
</math> prime.)  Estimates such as these are very difficult to establish.  The
ancient proof by Euclid that there are an infinite number of primes shows that
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <msub>
    <mi>p</mi>
    <mrow class="MJX-TeXAtom-ORD">
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
    </mrow>
  </msub>
  <mo>≤<!-- ≤ --></mo>
  <mrow class="MJX-TeXAtom-ORD">
    <msub>
      <mi>p</mi>
      <mn>1</mn>
    </msub>
    <msub>
      <mi>p</mi>
      <mn>2</mn>
    </msub>
    <mo>⋯<!-- ⋯ --></mo>
    <msub>
      <mi>p</mi>
      <mi>n</mi>
    </msub>
    <mo>+</mo>
    <mn>1</mn>
  </mrow>
</math>, and no substantially
better result was proved until 1851, when the Russian mathematician
P. L. Chebyshev established that <math xmlns="http://www.w3.org/1998/Math/MathML">
  <msub>
    <mi>p</mi>
    <mrow class="MJX-TeXAtom-ORD">
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
    </mrow>
  </msub>
  <mo>≤<!-- ≤ --></mo>
  <mn>2</mn>
  <msub>
    <mi>p</mi>
    <mi>n</mi>
  </msub>
</math> for all <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>n</mi>
</math>.
This result, originally conjectured in 1845, is known as <a id="index-Bertrand_0027s-hypothesis"></a>
<em>Bertrand’s hypothesis</em>.  
A proof can be found in section 22.3 of <a href="References.xhtml#Hardy-and-Wright-1960">Hardy and Wright 1960</a>.</p>
</div>
<div id="FOOT192"><p><a class="footnote_backlink" href="#DOCF192"><sup>192</sup></a>
This exercise shows how call-by-need is closely related
to ordinary memoization as described in <a href="3_002e3_002e3.xhtml#Exercise-3_002e27">Exercise 3.27</a>.  In that exercise,
we used assignment to explicitly construct a local table.  Our call-by-need
stream optimization effectively constructs such a table automatically, storing
values in the previously forced parts of the stream.</p>
</div>
</div>
<hr />
<nav class="header">
<p>
Next: <a href="3_002e5_002e3.xhtml#g_t3_002e5_002e3" accesskey="n" rel="next">3.5.3</a>, Previous: <a href="3_002e5_002e1.xhtml#g_t3_002e5_002e1" accesskey="p" rel="prev">3.5.1</a>, Up: <a href="3_002e5.xhtml#g_t3_002e5" accesskey="u" rel="prev">3.5</a>   [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>


</section>
</body>
</html>