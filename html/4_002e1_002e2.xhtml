<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Structure and Interpretation of Computer Programs, 2e: 4.1.2</title>

<meta name="description" content="Structure and Interpretation of Computer Programs, 2e: 4.1.2" />
<meta name="keywords" content="Structure and Interpretation of Computer Programs, 2e: 4.1.2" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="Generator" content="texi2any" />
<meta charset="utf-8" />
<link href="index.xhtml#Top" rel="start" title="Top" />
<link href="Term-Index.xhtml#Term-Index" rel="index" title="Term Index" />
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents" />
<link href="4_002e1.xhtml#g_t4_002e1" rel="prev" title="4.1" />
<link href="4_002e1_002e3.xhtml#g_t4_002e1_002e3" rel="next" title="4.1.3" />
<link href="4_002e1_002e1.xhtml#g_t4_002e1_002e1" rel="prev" title="4.1.1" />

<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />

<script src="js/jquery.min.js" type="text/javascript"></script>
<script src="js/footnotes.js" type="text/javascript"></script>
<script src="js/browsertest.js" type="text/javascript"></script>
</head>

<body>
<section><a id="g_t4_002e1_002e2"></a>
<nav class="header">
<p>
Next: <a href="4_002e1_002e3.xhtml#g_t4_002e1_002e3" accesskey="n" rel="next">4.1.3</a>, Previous: <a href="4_002e1_002e1.xhtml#g_t4_002e1_002e1" accesskey="p" rel="prev">4.1.1</a>, Up: <a href="4_002e1.xhtml#g_t4_002e1" accesskey="u" rel="prev">4.1</a>   [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>
<hr />

<a id="Representing-Expressions"></a>
<h4 class="subsection"><span class="secnum">4.1.2</span><span class="sectitle">Representing Expressions</span></h4>

<p>The evaluator is reminiscent of the symbolic differentiation program discussed
in <a href="2_002e3_002e2.xhtml#g_t2_002e3_002e2">2.3.2</a>.  Both programs operate on symbolic expressions.  In
both programs, the result of operating on a compound expression is determined
by operating recursively on the pieces of the expression and combining the
results in a way that depends on the type of the expression.  In both programs
we used data abstraction to decouple the general rules of operation from the
details of how expressions are represented.  In the differentiation program
this meant that the same differentiation procedure could deal with algebraic
expressions in prefix form, in infix form, or in some other form.  For the
evaluator, this means that the syntax of the language being evaluated is
determined solely by the procedures that classify and extract pieces of
expressions.
</p>
<p>Here is the specification of the syntax of our language:
</p>
<ul>
<li> The only self-evaluating items are numbers and strings:

<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">self-evaluating? exp</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">cond</span><span class="pln"> </span><span class="opn">((</span><span class="pln">number? exp</span><span class="clo">)</span><span class="pln"> true</span><span class="clo">)</span><span class="pln">
        </span><span class="opn">((</span><span class="pln">string? exp</span><span class="clo">)</span><span class="pln"> true</span><span class="clo">)</span><span class="pln">
        </span><span class="opn">(</span><span class="kwd">else</span><span class="pln"> false</span><span class="clo">)))</span></pre></div>

</li><li> Variables are represented by symbols:

<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">variable? exp</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">symbol? exp</span><span class="clo">))</span></pre></div>

</li><li> Quotations have the form <code>(quote ⟨<var>text-of-quotation</var>⟩)</code>:<a class="footnote_link" id="DOCF213" href="#FOOT213"><sup>213</sup></a>

<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">quoted? exp</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">tagged-list? exp </span><span class="lit">'quote</span><span class="clo">))</span><span class="pln">

</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">text-of-quotation exp</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">cadr</span><span class="pln"> exp</span><span class="clo">))</span></pre></div>

<p><code>Quoted?</code> is defined in terms of the procedure <code>tagged-list?</code>, which
identifies lists beginning with a designated symbol:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">tagged-list? exp tag</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> </span><span class="opn">(</span><span class="pln">pair? exp</span><span class="clo">)</span><span class="pln">
      </span><span class="opn">(</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> </span><span class="opn">(</span><span class="kwd">car</span><span class="pln"> exp</span><span class="clo">)</span><span class="pln"> tag</span><span class="clo">)</span><span class="pln">
      false</span><span class="clo">))</span></pre></div>

</li><li> Assignments have the form <code>(set! ⟨<var>var</var>⟩ ⟨<var>value</var>⟩)</code>:

<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">assignment? exp</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">tagged-list? exp </span><span class="lit">'set!</span><span class="clo">))</span><span class="pln">

</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">assignment-variable exp</span><span class="clo">)</span><span class="pln"> 
  </span><span class="opn">(</span><span class="kwd">cadr</span><span class="pln"> exp</span><span class="clo">))</span><span class="pln">

</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">assignment-value exp</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="kwd">caddr</span><span class="pln"> exp</span><span class="clo">))</span></pre></div>

</li><li> Definitions have the form

<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> ⟨</span><var><span class="pln">var</span></var><span class="pln">⟩ ⟨</span><var><span class="pln">value</span></var><span class="pln">⟩</span><span class="clo">)</span></pre></div>

<p>or the form
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">⟨</span><var><span class="pln">var</span></var><span class="pln">⟩ ⟨</span><var><span class="pln">param</span><span class="pun">₁</span></var><span class="pln">⟩ </span><span class="roman"><span class="pun">…</span></span><span class="pln"> ⟨</span><var><span class="pln">param</span><span class="pun">ₙ</span></var><span class="pln">⟩</span><span class="clo">)</span><span class="pln">
  ⟨</span><var><span class="pln">body</span></var><span class="pln">⟩</span><span class="clo">)</span></pre></div>

<p>The latter form (standard procedure definition) is syntactic sugar for
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> ⟨</span><var><span class="pln">var</span></var><span class="pln">⟩
  </span><span class="opn">(</span><span class="kwd">lambda</span><span class="pln"> </span><span class="opn">(</span><span class="pln">⟨</span><var><span class="pln">param</span><span class="pun">₁</span></var><span class="pln">⟩ </span><span class="roman"><span class="pun">…</span></span><span class="pln"> ⟨</span><var><span class="pln">param</span><span class="pun">ₙ</span></var><span class="pln">⟩</span><span class="clo">)</span><span class="pln">
    ⟨</span><var><span class="pln">body</span></var><span class="pln">⟩</span><span class="clo">))</span></pre></div>

<p>The corresponding syntax procedures are the following:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">definition? exp</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">tagged-list? exp </span><span class="lit">'define</span><span class="clo">))</span><span class="pln">

</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">definition-variable exp</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> </span><span class="opn">(</span><span class="pln">symbol? </span><span class="opn">(</span><span class="kwd">cadr</span><span class="pln"> exp</span><span class="clo">))</span><span class="pln">
      </span><span class="opn">(</span><span class="kwd">cadr</span><span class="pln"> exp</span><span class="clo">)</span><span class="pln">
      </span><span class="opn">(</span><span class="kwd">caadr</span><span class="pln"> exp</span><span class="clo">)))</span><span class="pln">

</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">definition-value exp</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> </span><span class="opn">(</span><span class="pln">symbol? </span><span class="opn">(</span><span class="kwd">cadr</span><span class="pln"> exp</span><span class="clo">))</span><span class="pln">
      </span><span class="opn">(</span><span class="kwd">caddr</span><span class="pln"> exp</span><span class="clo">)</span><span class="pln">
      </span><span class="opn">(</span><span class="pln">make-lambda 
       </span><span class="opn">(</span><span class="kwd">cdadr</span><span class="pln"> exp</span><span class="clo">)</span><span class="pln">   </span><span class="roman"><span class="com">; formal parameters</span></span><span class="pln">
       </span><span class="opn">(</span><span class="kwd">cddr</span><span class="pln"> exp</span><span class="clo">))))</span><span class="pln"> </span><span class="roman"><span class="com">; body</span></span>
</pre></div>

</li><li> <code>Lambda</code> expressions are lists that begin with the symbol <code>lambda</code>:

<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="kwd">lambda</span><span class="pun">?</span><span class="pln"> exp</span><span class="clo">)</span><span class="pln"> 
  </span><span class="opn">(</span><span class="pln">tagged-list? exp </span><span class="lit">'lambda</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">lambda-parameters exp</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="kwd">cadr</span><span class="pln"> exp</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">lambda-body exp</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="kwd">cddr</span><span class="pln"> exp</span><span class="clo">))</span></pre></div>

<p>We also provide a constructor for <code>lambda</code> expressions, which is used by
<code>definition-value</code>, above:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">make-lambda parameters body</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">cons</span><span class="pln"> </span><span class="lit">'lambda</span><span class="pln"> </span><span class="opn">(</span><span class="kwd">cons</span><span class="pln"> parameters body</span><span class="clo">)))</span></pre></div>

</li><li> Conditionals begin with <code>if</code> and have a predicate, a consequent, and an
(optional) alternative.  If the expression has no alternative part, we provide
<code>false</code> as the alternative.<a class="footnote_link" id="DOCF214" href="#FOOT214"><sup>214</sup></a>

<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="kwd">if</span><span class="pun">?</span><span class="pln"> exp</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">tagged-list? exp </span><span class="lit">'if</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">if-predicate exp</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="kwd">cadr</span><span class="pln"> exp</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">if-consequent exp</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="kwd">caddr</span><span class="pln"> exp</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">if-alternative exp</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> </span><span class="opn">(</span><span class="pln">not </span><span class="opn">(</span><span class="pln">null? </span><span class="opn">(</span><span class="kwd">cdddr</span><span class="pln"> exp</span><span class="clo">)))</span><span class="pln">
      </span><span class="opn">(</span><span class="kwd">cadddr</span><span class="pln"> exp</span><span class="clo">)</span><span class="pln">
      </span><span class="lit">'false</span><span class="clo">))</span></pre></div>

<p>We also provide a constructor for <code>if</code> expressions, to be used by
<code>cond-&gt;if</code> to transform <code>cond</code> expressions into <code>if</code>
expressions:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">make-if predicate 
                 consequent 
                 alternative</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">list </span><span class="lit">'if</span><span class="pln"> 
        predicate 
        consequent 
        alternative</span><span class="clo">))</span></pre></div>

</li><li> <code>Begin</code> packages a sequence of expressions into a single expression.  We
include syntax operations on <code>begin</code> expressions to extract the actual
sequence from the <code>begin</code> expression, as well as selectors that return the
first expression and the rest of the expressions in the
sequence.<a class="footnote_link" id="DOCF215" href="#FOOT215"><sup>215</sup></a>

<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="kwd">begin</span><span class="pun">?</span><span class="pln"> exp</span><span class="clo">)</span><span class="pln"> 
  </span><span class="opn">(</span><span class="pln">tagged-list? exp </span><span class="lit">'begin</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">begin-actions exp</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="kwd">cdr</span><span class="pln"> exp</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">last-exp? seq</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">null? </span><span class="opn">(</span><span class="kwd">cdr</span><span class="pln"> seq</span><span class="clo">)))</span><span class="pln">
</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">first-exp seq</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="kwd">car</span><span class="pln"> seq</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">rest-exps seq</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="kwd">cdr</span><span class="pln"> seq</span><span class="clo">))</span></pre></div>

<p>We also include a constructor <code>sequence-&gt;exp</code> (for use by <code>cond-&gt;if</code>)
that transforms a sequence into a single expression, using <code>begin</code> if
necessary:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">sequence-</span><span class="pun">&gt;</span><span class="pln">exp seq</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">cond</span><span class="pln"> </span><span class="opn">((</span><span class="pln">null? seq</span><span class="clo">)</span><span class="pln"> seq</span><span class="clo">)</span><span class="pln">
        </span><span class="opn">((</span><span class="pln">last-exp? seq</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">first-exp seq</span><span class="clo">))</span><span class="pln">
        </span><span class="opn">(</span><span class="kwd">else</span><span class="pln"> </span><span class="opn">(</span><span class="pln">make-begin seq</span><span class="clo">))))</span><span class="pln">

</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">make-begin seq</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="kwd">cons</span><span class="pln"> </span><span class="lit">'begin</span><span class="pln"> seq</span><span class="clo">))</span></pre></div>

</li><li> A procedure application is any compound expression that is not one of the above
expression types.  The <code>car</code> of the expression is the operator, and the
<code>cdr</code> is the list of operands:

<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">application? exp</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">pair? exp</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">operator exp</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="kwd">car</span><span class="pln"> exp</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">operands exp</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="kwd">cdr</span><span class="pln"> exp</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">no-operands? ops</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">null? ops</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">first-operand ops</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="kwd">car</span><span class="pln"> ops</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">rest-operands ops</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="kwd">cdr</span><span class="pln"> ops</span><span class="clo">))</span></pre></div>

</li></ul>

<a id="Derived-expressions"></a>
<h5 class="subsubheading">Derived expressions</h5>

<p>Some special forms in our language can be defined in terms of expressions
involving other special forms, rather than being implemented directly.  One
example is <code>cond</code>, which can be implemented as a nest of <code>if</code>
expressions.  For example, we can reduce the problem of evaluating the
expression
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">cond</span><span class="pln"> </span><span class="opn">((</span><span class="pun">&gt;</span><span class="pln"> x </span><span class="lit">0</span><span class="clo">)</span><span class="pln"> x</span><span class="clo">)</span><span class="pln">
      </span><span class="opn">((</span><span class="pun">=</span><span class="pln"> x </span><span class="lit">0</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">display </span><span class="lit">'zero</span><span class="clo">)</span><span class="pln"> </span><span class="lit">0</span><span class="clo">)</span><span class="pln">
      </span><span class="opn">(</span><span class="kwd">else</span><span class="pln"> </span><span class="opn">(</span><span class="pun">-</span><span class="pln"> x</span><span class="clo">)))</span></pre></div>

<p>to the problem of evaluating the following expression involving <code>if</code> and
<code>begin</code> expressions:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">if</span><span class="pln"> </span><span class="opn">(</span><span class="pun">&gt;</span><span class="pln"> x </span><span class="lit">0</span><span class="clo">)</span><span class="pln">
    x
    </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> </span><span class="opn">(</span><span class="pun">=</span><span class="pln"> x </span><span class="lit">0</span><span class="clo">)</span><span class="pln">
        </span><span class="opn">(</span><span class="kwd">begin</span><span class="pln"> </span><span class="opn">(</span><span class="pln">display </span><span class="lit">'zero</span><span class="clo">)</span><span class="pln"> </span><span class="lit">0</span><span class="clo">)</span><span class="pln">
        </span><span class="opn">(</span><span class="pun">-</span><span class="pln"> x</span><span class="clo">)))</span></pre></div>

<p>Implementing the evaluation of <code>cond</code> in this way simplifies the evaluator
because it reduces the number of special forms for which the evaluation process
must be explicitly specified.
</p>
<p>We include syntax procedures that extract the parts of a <code>cond</code>
expression, and a procedure <code>cond-&gt;if</code> that transforms <code>cond</code>
expressions into <code>if</code> expressions.  A case analysis begins with
<code>cond</code> and has a list of predicate-action clauses.  A clause is an
<code>else</code> clause if its predicate is the symbol <code>else</code>.<a class="footnote_link" id="DOCF216" href="#FOOT216"><sup>216</sup></a>
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="kwd">cond</span><span class="pun">?</span><span class="pln"> exp</span><span class="clo">)</span><span class="pln"> 
  </span><span class="opn">(</span><span class="pln">tagged-list? exp </span><span class="lit">'cond</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">cond-clauses exp</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="kwd">cdr</span><span class="pln"> exp</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">cond-else-clause? clause</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> </span><span class="opn">(</span><span class="pln">cond-predicate clause</span><span class="clo">)</span><span class="pln"> </span><span class="lit">'else</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">cond-predicate clause</span><span class="clo">)</span><span class="pln"> 
  </span><span class="opn">(</span><span class="kwd">car</span><span class="pln"> clause</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">cond-actions clause</span><span class="clo">)</span><span class="pln"> 
  </span><span class="opn">(</span><span class="kwd">cdr</span><span class="pln"> clause</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">cond-</span><span class="pun">&gt;</span><span class="kwd">if</span><span class="pln"> exp</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">expand-clauses </span><span class="opn">(</span><span class="pln">cond-clauses exp</span><span class="clo">)))</span><span class="pln">
</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">expand-clauses clauses</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> </span><span class="opn">(</span><span class="pln">null? clauses</span><span class="clo">)</span><span class="pln">
      </span><span class="lit">'false</span><span class="pln">     </span><span class="roman"><span class="com">; no </span><code><span class="com">else</span></code><span class="com"> clause</span></span><span class="pln">
      </span><span class="opn">(</span><span class="kwd">let</span><span class="pln"> </span><span class="opn">((</span><span class="pln">first </span><span class="opn">(</span><span class="kwd">car</span><span class="pln"> clauses</span><span class="clo">))</span><span class="pln">
            </span><span class="opn">(</span><span class="pln">rest </span><span class="opn">(</span><span class="kwd">cdr</span><span class="pln"> clauses</span><span class="clo">)))</span><span class="pln">
        </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> </span><span class="opn">(</span><span class="pln">cond-else-clause? first</span><span class="clo">)</span><span class="pln">
            </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> </span><span class="opn">(</span><span class="pln">null? rest</span><span class="clo">)</span><span class="pln">
                </span><span class="opn">(</span><span class="pln">sequence-</span><span class="pun">&gt;</span><span class="pln">exp 
                 </span><span class="opn">(</span><span class="pln">cond-actions first</span><span class="clo">))</span><span class="pln">
                </span><span class="opn">(</span><span class="err">error</span><span class="pln"> </span><span class="str">"ELSE clause isn't 
                        last: COND-&gt;IF"</span><span class="pln">
                       clauses</span><span class="clo">))</span><span class="pln">
            </span><span class="opn">(</span><span class="pln">make-if </span><span class="opn">(</span><span class="pln">cond-predicate first</span><span class="clo">)</span><span class="pln">
                     </span><span class="opn">(</span><span class="pln">sequence-</span><span class="pun">&gt;</span><span class="pln">exp 
                      </span><span class="opn">(</span><span class="pln">cond-actions first</span><span class="clo">))</span><span class="pln">
                     </span><span class="opn">(</span><span class="pln">expand-clauses 
                      rest</span><span class="clo">))))))</span></pre></div>

<p>Expressions (such as <code>cond</code>) that we choose to implement as syntactic
transformations are called <a id="index-derived-expressions"></a>
<em>derived expressions</em>.  <code>Let</code>
expressions are also derived expressions (see 
<a href="#Exercise-4_002e6">Exercise 4.6</a>).<a class="footnote_link" id="DOCF217" href="#FOOT217"><sup>217</sup></a>
</p>
<blockquote>
<p><strong><a id="Exercise-4_002e2"></a>Exercise 4.2:</strong> Louis Reasoner plans to reorder the
<code>cond</code> clauses in <code>eval</code> so that the clause for procedure
applications appears before the clause for assignments.  He argues that this
will make the interpreter more efficient: Since programs usually contain more
applications than assignments, definitions, and so on, his modified <code>eval</code>
will usually check fewer clauses than the original <code>eval</code> before
identifying the type of an expression.
</p>
<ol>
<li> What is wrong with Louis’s plan?  (Hint: What will Louis’s evaluator do with
the expression <code>(define x 3)</code>?)

</li><li> Louis is upset that his plan didn’t work.  He is willing to go to any lengths
to make his evaluator recognize procedure applications before it checks for
most other kinds of expressions.  Help him by changing the syntax of the
evaluated language so that procedure applications start with <code>call</code>.  For
example, instead of <code>(factorial 3)</code> we will now have to write <code>(call
factorial 3)</code> and instead of <code>(+ 1 2)</code> we will have to write <code>(call +
1 2)</code>.

</li></ol>
</blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e3"></a>Exercise 4.3:</strong> Rewrite <code>eval</code> so that the
dispatch is done in data-directed style.  Compare this with the data-directed
differentiation procedure of <a href="2_002e4_002e3.xhtml#Exercise-2_002e73">Exercise 2.73</a>.  (You may use the <code>car</code>
of a compound expression as the type of the expression, as is appropriate for
the syntax implemented in this section.)
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e4"></a>Exercise 4.4:</strong> Recall the definitions of the
special forms <code>and</code> and <code>or</code> from <a href="Chapter-1.xhtml#Chapter-1">Chapter 1</a>:
</p>
<ul>
<li> <code>and</code>: The expressions are evaluated from left to right.  If any
expression evaluates to false, false is returned; any remaining expressions are
not evaluated.  If all the expressions evaluate to true values, the value of
the last expression is returned.  If there are no expressions then true is
returned.

</li><li> <code>or</code>: The expressions are evaluated from left to right.  If any expression
evaluates to a true value, that value is returned; any remaining expressions
are not evaluated.  If all expressions evaluate to false, or if there are no
expressions, then false is returned.

</li></ul>

<p>Install <code>and</code> and <code>or</code> as new special forms for the evaluator by
defining appropriate syntax procedures and evaluation procedures
<code>eval-and</code> and <code>eval-or</code>.  Alternatively, show how to implement
<code>and</code> and <code>or</code> as derived expressions.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e5"></a>Exercise 4.5:</strong> Scheme allows an additional syntax
for <code>cond</code> clauses, <code>(⟨<var>test</var>⟩ =&gt; ⟨<var>recipient</var>⟩)</code>.  If
<code>⟨</code><var>test</var><code>⟩</code> evaluates to a true value, then <code>⟨</code><var>recipient</var><code>⟩</code> is evaluated.
Its value must be a procedure of one argument; this procedure is then invoked
on the value of the <code>⟨</code><var>test</var><code>⟩</code>, and the result is returned as the value of
the <code>cond</code> expression.  For example
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">cond</span><span class="pln"> </span><span class="opn">((</span><span class="pln">assoc </span><span class="lit">'b</span><span class="pln"> </span><span class="lit">'</span><span class="opn">((</span><span class="pln">a </span><span class="lit">1</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">b </span><span class="lit">2</span><span class="clo">)))</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="kwd">cadr</span><span class="clo">)</span><span class="pln">
      </span><span class="opn">(</span><span class="kwd">else</span><span class="pln"> false</span><span class="clo">))</span></pre></div>

<p>returns 2.  Modify the handling of <code>cond</code> so that it supports this
extended syntax.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e6"></a>Exercise 4.6:</strong> <code>Let</code> expressions are derived
expressions, because
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">let</span><span class="pln"> </span><span class="opn">((</span><span class="pln">⟨</span><var><span class="pln">var</span><span class="pun">₁</span></var><span class="pln">⟩ ⟨</span><var><span class="pln">exp</span><span class="pun">₁</span></var><span class="pln">⟩</span><span class="clo">)</span><span class="pln"> </span><span class="roman"><span class="pun">…</span></span><span class="pln"> </span><span class="opn">(</span><span class="pln">⟨</span><var><span class="pln">var</span><span class="pun">ₙ</span></var><span class="pln">⟩ ⟨</span><var><span class="pln">exp</span><span class="pun">ₙ</span></var><span class="pln">⟩</span><span class="clo">))</span><span class="pln">
  ⟨</span><var><span class="pln">body</span></var><span class="pln">⟩</span><span class="clo">)</span></pre></div>

<p>is equivalent to
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">((</span><span class="kwd">lambda</span><span class="pln"> </span><span class="opn">(</span><span class="pln">⟨</span><var><span class="pln">var</span><span class="pun">₁</span></var><span class="pln">⟩ </span><span class="roman"><span class="pun">…</span></span><span class="pln"> ⟨</span><var><span class="pln">var</span><span class="pun">ₙ</span></var><span class="pln">⟩</span><span class="clo">)</span><span class="pln">
   ⟨</span><var><span class="pln">body</span></var><span class="pln">⟩</span><span class="clo">)</span><span class="pln">
 ⟨</span><var><span class="pln">exp</span><span class="pun">₁</span></var><span class="pln">⟩
 </span><span class="roman"><span class="pun">…</span></span><span class="pln">
 ⟨</span><var><span class="pln">exp</span><span class="pun">ₙ</span></var><span class="pln">⟩</span><span class="clo">)</span></pre></div>

<p>Implement a syntactic transformation <code>let-&gt;combination</code> that reduces
evaluating <code>let</code> expressions to evaluating combinations of the type shown
above, and add the appropriate clause to <code>eval</code> to handle <code>let</code>
expressions.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e7"></a>Exercise 4.7:</strong> <code>Let*</code> is similar to
<code>let</code>, except that the bindings of the <code>let*</code> variables are performed
sequentially from left to right, and each binding is made in an environment in
which all of the preceding bindings are visible.  For example
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">let</span><span class="pun">*</span><span class="pln"> </span><span class="opn">((</span><span class="pln">x </span><span class="lit">3</span><span class="clo">)</span><span class="pln">
       </span><span class="opn">(</span><span class="pln">y </span><span class="opn">(</span><span class="pun">+</span><span class="pln"> x </span><span class="lit">2</span><span class="clo">))</span><span class="pln">
       </span><span class="opn">(</span><span class="pln">z </span><span class="opn">(</span><span class="pun">+</span><span class="pln"> x y </span><span class="lit">5</span><span class="clo">)))</span><span class="pln">
  </span><span class="opn">(</span><span class="pun">*</span><span class="pln"> x z</span><span class="clo">))</span></pre></div>

<p>returns 39.  Explain how a <code>let*</code> expression can be rewritten as a set of
nested <code>let</code> expressions, and write a procedure <code>let*-&gt;nested-lets</code>
that performs this transformation.  If we have already implemented <code>let</code>
(<a href="#Exercise-4_002e6">Exercise 4.6</a>) and we want to extend the evaluator to handle <code>let*</code>,
is it sufficient to add a clause to <code>eval</code> whose action is
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="pln">eval </span><span class="opn">(</span><span class="kwd">let</span><span class="pun">*-&gt;</span><span class="pln">nested-lets exp</span><span class="clo">)</span><span class="pln"> env</span><span class="clo">)</span></pre></div>

<p>or must we explicitly expand <code>let*</code> in terms of non-derived expressions?
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e8"></a>Exercise 4.8:</strong> “Named <code>let</code>” is a variant
of <code>let</code> that has the form 
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">let</span><span class="pln"> ⟨</span><var><span class="pln">var</span></var><span class="pln">⟩ ⟨</span><var><span class="pln">bindings</span></var><span class="pln">⟩ ⟨</span><var><span class="pln">body</span></var><span class="pln">⟩</span><span class="clo">)</span></pre></div>

<p>The <code>⟨</code><var>bindings</var><code>⟩</code> and <code>⟨</code><var>body</var><code>⟩</code> are just as in ordinary <code>let</code>,
except that <code>⟨</code><var>var</var><code>⟩</code> is bound within <code>⟨</code><var>body</var><code>⟩</code> to a procedure whose body
is <code>⟨</code><var>body</var><code>⟩</code> and whose parameters are the variables in the <code>⟨</code><var>bindings</var><code>⟩</code>.
Thus, one can repeatedly execute the <code>⟨</code><var>body</var><code>⟩</code> by invoking the procedure
named <code>⟨</code><var>var</var><code>⟩</code>.  For example, the iterative Fibonacci procedure 
(<a href="1_002e2_002e2.xhtml#g_t1_002e2_002e2">1.2.2</a>) can be rewritten using named <code>let</code> as follows:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">fib n</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">let</span><span class="pln"> fib-iter </span><span class="opn">((</span><span class="pln">a </span><span class="lit">1</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">b </span><span class="lit">0</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">count n</span><span class="clo">))</span><span class="pln">
    </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> </span><span class="opn">(</span><span class="pun">=</span><span class="pln"> count </span><span class="lit">0</span><span class="clo">)</span><span class="pln">
        b
        </span><span class="opn">(</span><span class="pln">fib-iter </span><span class="opn">(</span><span class="pun">+</span><span class="pln"> a b</span><span class="clo">)</span><span class="pln"> 
                  a 
                  </span><span class="opn">(</span><span class="pun">-</span><span class="pln"> count </span><span class="lit">1</span><span class="clo">)))))</span></pre></div>

<p>Modify <code>let-&gt;combination</code> of <a href="#Exercise-4_002e6">Exercise 4.6</a> to also support named
<code>let</code>.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e9"></a>Exercise 4.9:</strong> Many languages support a variety of
iteration constructs, such as <code>do</code>, <code>for</code>, <code>while</code>, and
<code>until</code>.  In Scheme, iterative processes can be expressed in terms of
ordinary procedure calls, so special iteration constructs provide no essential
gain in computational power.  On the other hand, such constructs are often
convenient.  Design some iteration constructs, give examples of their use, and
show how to implement them as derived expressions.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e10"></a>Exercise 4.10:</strong> By using data abstraction, we
were able to write an <code>eval</code> procedure that is independent of the
particular syntax of the language to be evaluated.  To illustrate this, design
and implement a new syntax for Scheme by modifying the procedures in this
section, without changing <code>eval</code> or <code>apply</code>.
</p></blockquote>

<div class="footnote">
<hr />

<h4 class="footnotes-heading">Footnotes</h4>

<div id="FOOT213"><p><a class="footnote_backlink" href="#DOCF213"><sup>213</sup></a>
As
mentioned in <a href="2_002e3_002e1.xhtml#g_t2_002e3_002e1">2.3.1</a>, the evaluator sees a quoted expression as a
list beginning with <code>quote</code>, even if the expression is typed with the
quotation mark.  For example, the expression <code>'a</code> would be seen by the
evaluator as <code>(quote a)</code>.  See <a href="2_002e3_002e1.xhtml#Exercise-2_002e55">Exercise 2.55</a>.</p>
</div>
<div id="FOOT214"><p><a class="footnote_backlink" href="#DOCF214"><sup>214</sup></a>
The value of an <code>if</code> expression
when the predicate is false and there is no alternative is unspecified in
Scheme; we have chosen here to make it false.  We will support the use of the
variables <code>true</code> and <code>false</code> in expressions to be evaluated by
binding them in the global environment.  See <a href="4_002e1_002e4.xhtml#g_t4_002e1_002e4">4.1.4</a>.</p>
</div>
<div id="FOOT215"><p><a class="footnote_backlink" href="#DOCF215"><sup>215</sup></a>
These selectors for a list of expressions—and the
corresponding ones for a list of operands—are not intended as a data
abstraction.  They are introduced as mnemonic names for the basic list
operations in order to make it easier to understand the explicit-control
evaluator in <a href="5_002e4.xhtml#g_t5_002e4">5.4</a>.</p>
</div>
<div id="FOOT216"><p><a class="footnote_backlink" href="#DOCF216"><sup>216</sup></a>
The
value of a <code>cond</code> expression when all the predicates are false and there
is no <code>else</code> clause is unspecified in Scheme; we have chosen here to make
it false.</p>
</div>
<div id="FOOT217"><p><a class="footnote_backlink" href="#DOCF217"><sup>217</sup></a>
Practical Lisp systems provide a mechanism that allows a user
to add new derived expressions and specify their implementation as syntactic
transformations without modifying the evaluator.  Such a user-defined
transformation is called a <a id="index-macro"></a>
<em>macro</em>.  Although it is easy to add an
elementary mechanism for defining macros, the resulting language has subtle
name-conflict problems.  There has been much research on mechanisms for macro
definition that do not cause these difficulties.  See, for example, <a href="References.xhtml#Kohlbecker-1986">Kohlbecker 1986</a>, 
<a href="References.xhtml#Clinger-and-Rees-1991">Clinger and Rees 1991</a>, and <a href="References.xhtml#Hanson-1991">Hanson 1991</a>.</p>
</div>
</div>
<hr />
<nav class="header">
<p>
Next: <a href="4_002e1_002e3.xhtml#g_t4_002e1_002e3" accesskey="n" rel="next">4.1.3</a>, Previous: <a href="4_002e1_002e1.xhtml#g_t4_002e1_002e1" accesskey="p" rel="prev">4.1.1</a>, Up: <a href="4_002e1.xhtml#g_t4_002e1" accesskey="u" rel="prev">4.1</a>   [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>


</section>
</body>
</html>