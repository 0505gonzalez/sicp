<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Structure and Interpretation of Computer Programs, 2e: 3.5.3</title>

<meta name="description" content="Structure and Interpretation of Computer Programs, 2e: 3.5.3" />
<meta name="keywords" content="Structure and Interpretation of Computer Programs, 2e: 3.5.3" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="Generator" content="texi2any" />
<meta charset="utf-8" />
<link href="index.xhtml#Top" rel="start" title="Top" />
<link href="Term-Index.xhtml#Term-Index" rel="index" title="Term Index" />
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents" />
<link href="3_002e5.xhtml#g_t3_002e5" rel="prev" title="3.5" />
<link href="3_002e5_002e4.xhtml#g_t3_002e5_002e4" rel="next" title="3.5.4" />
<link href="3_002e5_002e2.xhtml#g_t3_002e5_002e2" rel="prev" title="3.5.2" />

<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />

<script src="js/jquery.min.js" type="text/javascript"></script>
<script src="js/footnotes.js" type="text/javascript"></script>
<script src="js/browsertest.js" type="text/javascript"></script>
</head>

<body>
<section><a id="g_t3_002e5_002e3"></a>
<nav class="header">
<p>
Next: <a href="3_002e5_002e4.xhtml#g_t3_002e5_002e4" accesskey="n" rel="next">3.5.4</a>, Previous: <a href="3_002e5_002e2.xhtml#g_t3_002e5_002e2" accesskey="p" rel="prev">3.5.2</a>, Up: <a href="3_002e5.xhtml#g_t3_002e5" accesskey="u" rel="prev">3.5</a>   [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>
<hr />

<a id="Exploiting-the-Stream-Paradigm"></a>
<h4 class="subsection"><span class="secnum">3.5.3</span><span class="sectitle">Exploiting the Stream Paradigm</span></h4>

<p>Streams with delayed evaluation can be a powerful modeling tool, providing many
of the benefits of local state and assignment.  Moreover, they avoid some of
the theoretical tangles that accompany the introduction of assignment into a
programming language.
</p>
<p>The stream approach can be illuminating because it allows us to build systems
with different module boundaries than systems organized around assignment to
state variables.  For example, we can think of an entire time series (or
signal) as a focus of interest, rather than the values of the state variables
at individual moments.  This makes it convenient to combine and compare
components of state from different moments.
</p>
<a id="Formulating-iterations-as-stream-processes"></a>
<h5 class="subsubheading">Formulating iterations as stream processes</h5>

<p>In section <a href="1_002e2_002e1.xhtml#g_t1_002e2_002e1">1.2.1</a>, we introduced iterative processes, which proceed by
updating state variables.  We know now that we can represent state as a
“timeless” stream of values rather than as a set of variables to be updated.
Let’s adopt this perspective in revisiting the square-root procedure from
<a href="1_002e1_002e7.xhtml#g_t1_002e1_002e7">1.1.7</a>.  Recall that the idea is to generate a sequence of better
and better guesses for the square root of <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>x</mi>
</math> by applying over and over again
the procedure that improves guesses:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">sqrt-improve guess x</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">average guess </span><span class="opn">(</span><span class="pun">/</span><span class="pln"> x guess</span><span class="clo">)))</span></pre></div>

<p>In our original <code>sqrt</code> procedure, we made these guesses be the successive
values of a state variable. Instead we can generate the infinite stream of
guesses, starting with an initial guess of 1:<a class="footnote_link" id="DOCF193" href="#FOOT193"><sup>193</sup></a>
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">sqrt-stream x</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> guesses
    </span><span class="opn">(</span><span class="pln">cons-stream 
     </span><span class="lit">1.0</span><span class="pln"> </span><span class="opn">(</span><span class="pln">stream-map
          </span><span class="opn">(</span><span class="kwd">lambda</span><span class="pln"> </span><span class="opn">(</span><span class="pln">guess</span><span class="clo">)</span><span class="pln">
            </span><span class="opn">(</span><span class="pln">sqrt-improve guess x</span><span class="clo">))</span><span class="pln">
          guesses</span><span class="clo">)))</span><span class="pln">
  guesses</span><span class="clo">)</span><span class="pln">

</span><span class="opn">(</span><span class="pln">display-stream </span><span class="opn">(</span><span class="pln">sqrt-stream </span><span class="lit">2</span><span class="clo">))</span><span class="pln">
</span><i><span class="lit">1.</span></i><span class="pln">
</span><i><span class="lit">1.5</span></i><span class="pln">
</span><i><span class="lit">1.4166666666666665</span></i><span class="pln">
</span><i><span class="lit">1.4142156862745097</span></i><span class="pln">
</span><i><span class="lit">1.4142135623746899</span></i><span class="pln">
</span><span class="roman"><span class="pun">…</span></span>
</pre></div>

<p>We can generate more and more terms of the stream to get better and better
guesses.  If we like, we can write a procedure that keeps generating terms
until the answer is good enough.  (See <a href="#Exercise-3_002e64">Exercise 3.64</a>.)
</p>
<p>Another iteration that we can treat in the same way is to generate an
approximation to <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>π<!-- π --></mi>
</math>, based upon the alternating series that we saw in
<a href="1_002e3_002e1.xhtml#g_t1_002e3_002e1">1.3.1</a>:
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mrow class="MJX-TeXAtom-ORD">
    <mfrac>
      <mi>π<!-- π --></mi>
      <mn>4</mn>
    </mfrac>
  </mrow>
  <mspace width="thinmathspace"/>
  <mo>=</mo>
  <mspace width="thinmathspace"/>
  <mn>1</mn>
  <mo>−<!-- − --></mo>
  <mrow class="MJX-TeXAtom-ORD">
    <mfrac>
      <mn>1</mn>
      <mn>3</mn>
    </mfrac>
  </mrow>
  <mo>+</mo>
  <mrow class="MJX-TeXAtom-ORD">
    <mfrac>
      <mn>1</mn>
      <mn>5</mn>
    </mfrac>
  </mrow>
  <mo>−<!-- − --></mo>
  <mrow class="MJX-TeXAtom-ORD">
    <mfrac>
      <mn>1</mn>
      <mn>7</mn>
    </mfrac>
  </mrow>
  <mo>+</mo>
  <mrow class="MJX-TeXAtom-ORD">
    <mo>…<!-- … --></mo>
    <mo>.</mo>
  </mrow>
</math>
We first generate the stream of summands of the series (the reciprocals of the
odd integers, with alternating signs).  Then we take the stream of sums of more
and more terms (using the <code>partial-sums</code> procedure of <a href="3_002e5_002e2.xhtml#Exercise-3_002e55">Exercise 3.55</a>)
and scale the result by 4:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">pi-summands n</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">cons-stream 
   </span><span class="opn">(</span><span class="pun">/</span><span class="pln"> </span><span class="lit">1.0</span><span class="pln"> n</span><span class="clo">)</span><span class="pln">
   </span><span class="opn">(</span><span class="pln">stream-map </span><span class="pun">-</span><span class="pln"> </span><span class="opn">(</span><span class="pln">pi-summands </span><span class="opn">(</span><span class="pun">+</span><span class="pln"> n </span><span class="lit">2</span><span class="clo">)))))</span><span class="pln">

</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> pi-stream
  </span><span class="opn">(</span><span class="pln">scale-stream 
   </span><span class="opn">(</span><span class="pln">partial-sums </span><span class="opn">(</span><span class="pln">pi-summands </span><span class="lit">1</span><span class="clo">))</span><span class="pln"> </span><span class="lit">4</span><span class="clo">))</span><span class="pln">

</span><span class="opn">(</span><span class="pln">display-stream pi-stream</span><span class="clo">)</span><span class="pln">
</span><i><span class="lit">4.</span></i><span class="pln">
</span><i><span class="lit">2.666666666666667</span></i><span class="pln">
</span><i><span class="lit">3.466666666666667</span></i><span class="pln">
</span><i><span class="lit">2.8952380952380956</span></i><span class="pln">
</span><i><span class="lit">3.3396825396825403</span></i><span class="pln">
</span><i><span class="lit">2.9760461760461765</span></i><span class="pln">
</span><i><span class="lit">3.2837384837384844</span></i><span class="pln">
</span><i><span class="lit">3.017071817071818</span></i><span class="pln">
</span><span class="roman"><span class="pun">…</span></span>
</pre></div>

<p>This gives us a stream of better and better approximations to <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>π<!-- π --></mi>
</math>,
although the approximations converge rather slowly.  Eight terms of the
sequence bound the value of <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>π<!-- π --></mi>
</math> between 3.284 and 3.017.
</p>
<p>So far, our use of the stream of states approach is not much different from
updating state variables.  But streams give us an opportunity to do some
interesting tricks.  For example, we can transform a stream with a
<a id="index-sequence-accelerator"></a>
<em>sequence accelerator</em> that converts a sequence of approximations to a
new sequence that converges to the same value as the original, only faster.
</p>
<p>One such accelerator, due to the eighteenth-century Swiss mathematician
Leonhard Euler, works well with sequences that are partial sums of alternating
series (series of terms with alternating signs).  In Euler’s technique, if
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <msub>
    <mi>S</mi>
    <mi>n</mi>
  </msub>
</math> is the <math xmlns="http://www.w3.org/1998/Math/MathML">
  <msup>
    <mi>n</mi>
    <mrow class="MJX-TeXAtom-ORD">
      <mtext>th</mtext>
    </mrow>
  </msup>
</math> term of the original sum sequence, then the
accelerated sequence has terms
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <msub>
    <mi>S</mi>
    <mrow class="MJX-TeXAtom-ORD">
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
    </mrow>
  </msub>
  <mo>−<!-- − --></mo>
  <mrow class="MJX-TeXAtom-ORD">
    <mrow class="MJX-TeXAtom-ORD">
      <mfrac>
        <mrow>
          <mo stretchy="false">(</mo>
          <msub>
            <mi>S</mi>
            <mrow class="MJX-TeXAtom-ORD">
              <mi>n</mi>
              <mo>+</mo>
              <mn>1</mn>
            </mrow>
          </msub>
          <mo>−<!-- − --></mo>
          <msub>
            <mi>S</mi>
            <mi>n</mi>
          </msub>
          <msup>
            <mo stretchy="false">)</mo>
            <mn>2</mn>
          </msup>
        </mrow>
        <mrow>
          <msub>
            <mi>S</mi>
            <mrow class="MJX-TeXAtom-ORD">
              <mi>n</mi>
              <mo>−<!-- − --></mo>
              <mn>1</mn>
            </mrow>
          </msub>
          <mo>−<!-- − --></mo>
          <mn>2</mn>
          <msub>
            <mi>S</mi>
            <mi>n</mi>
          </msub>
          <mo>+</mo>
          <msub>
            <mi>S</mi>
            <mrow class="MJX-TeXAtom-ORD">
              <mi>n</mi>
              <mo>+</mo>
              <mn>1</mn>
            </mrow>
          </msub>
        </mrow>
      </mfrac>
    </mrow>
    <mo>.</mo>
  </mrow>
</math>
Thus, if the original sequence is represented as a stream of values, the
transformed sequence is given by
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">euler-transform s</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">let</span><span class="pln"> </span><span class="opn">((</span><span class="pln">s0 </span><span class="opn">(</span><span class="pln">stream-ref s </span><span class="lit">0</span><span class="clo">))</span><span class="pln">     </span><span class="com">; </span><var><span class="com">Sₙ</span></var><span class="com">₋₁</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">s1 </span><span class="opn">(</span><span class="pln">stream-ref s </span><span class="lit">1</span><span class="clo">))</span><span class="pln">     </span><span class="com">; </span><var><span class="com">Sₙ</span></var><span class="pln">
        </span><span class="opn">(</span><span class="pln">s2 </span><span class="opn">(</span><span class="pln">stream-ref s </span><span class="lit">2</span><span class="clo">)))</span><span class="pln">    </span><span class="com">; </span><var><span class="com">Sₙ</span></var><span class="com">₊₁</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">cons-stream 
     </span><span class="opn">(</span><span class="pun">-</span><span class="pln"> s2 </span><span class="opn">(</span><span class="pun">/</span><span class="pln"> </span><span class="opn">(</span><span class="pln">square </span><span class="opn">(</span><span class="pun">-</span><span class="pln"> s2 s1</span><span class="clo">))</span><span class="pln">
              </span><span class="opn">(</span><span class="pun">+</span><span class="pln"> s0 </span><span class="opn">(</span><span class="pun">*</span><span class="pln"> </span><span class="lit">-2</span><span class="pln"> s1</span><span class="clo">)</span><span class="pln"> s2</span><span class="clo">)))</span><span class="pln">
     </span><span class="opn">(</span><span class="pln">euler-transform </span><span class="opn">(</span><span class="pln">stream-cdr s</span><span class="clo">)))))</span></pre></div>

<p>We can demonstrate Euler acceleration with our sequence of approximations to
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>π<!-- π --></mi>
</math>:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="pln">display-stream 
 </span><span class="opn">(</span><span class="pln">euler-transform pi-stream</span><span class="clo">))</span><span class="pln">
</span><i><span class="lit">3.166666666666667</span></i><span class="pln">
</span><i><span class="lit">3.1333333333333337</span></i><span class="pln">
</span><i><span class="lit">3.1452380952380956</span></i><span class="pln">
</span><i><span class="lit">3.13968253968254</span></i><span class="pln">
</span><i><span class="lit">3.1427128427128435</span></i><span class="pln">
</span><i><span class="lit">3.1408813408813416</span></i><span class="pln">
</span><i><span class="lit">3.142071817071818</span></i><span class="pln">
</span><i><span class="lit">3.1412548236077655</span></i><span class="pln">
</span><span class="roman"><span class="pun">…</span></span>
</pre></div>

<p>Even better, we can accelerate the accelerated sequence, and recursively
accelerate that, and so on.  Namely, we create a stream of streams (a structure
we’ll call a <a id="index-tableau"></a>
<em>tableau</em>) in which each stream is the transform of the
preceding one:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">make-tableau transform s</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">cons-stream 
   s
   </span><span class="opn">(</span><span class="pln">make-tableau
    transform
    </span><span class="opn">(</span><span class="pln">transform s</span><span class="clo">))))</span></pre></div>

<p>The tableau has the form
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mtable columnalign="center center center center center center" rowspacing="4pt" columnspacing="1em">
    <mtr>
      <mtd>
        <msub>
          <mi>s</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>00</mn>
          </mrow>
        </msub>
      </mtd>
      <mtd>
        <msub>
          <mi>s</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>01</mn>
          </mrow>
        </msub>
      </mtd>
      <mtd>
        <msub>
          <mi>s</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>02</mn>
          </mrow>
        </msub>
      </mtd>
      <mtd>
        <msub>
          <mi>s</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>03</mn>
          </mrow>
        </msub>
      </mtd>
      <mtd>
        <msub>
          <mi>s</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>04</mn>
          </mrow>
        </msub>
      </mtd>
      <mtd>
        <mo>…<!-- … --></mo>
      </mtd>
    </mtr>
    <mtr>
      <mtd/>
      <mtd>
        <msub>
          <mi>s</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>10</mn>
          </mrow>
        </msub>
      </mtd>
      <mtd>
        <msub>
          <mi>s</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>11</mn>
          </mrow>
        </msub>
      </mtd>
      <mtd>
        <msub>
          <mi>s</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>12</mn>
          </mrow>
        </msub>
      </mtd>
      <mtd>
        <msub>
          <mi>s</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>13</mn>
          </mrow>
        </msub>
      </mtd>
      <mtd>
        <mo>…<!-- … --></mo>
      </mtd>
    </mtr>
    <mtr>
      <mtd/>
      <mtd/>
      <mtd>
        <msub>
          <mi>s</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>20</mn>
          </mrow>
        </msub>
      </mtd>
      <mtd>
        <msub>
          <mi>s</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>21</mn>
          </mrow>
        </msub>
      </mtd>
      <mtd>
        <msub>
          <mi>s</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>22</mn>
          </mrow>
        </msub>
      </mtd>
      <mtd>
        <mo>…<!-- … --></mo>
      </mtd>
    </mtr>
    <mtr>
      <mtd/>
      <mtd/>
      <mtd/>
      <mtd>
        <mo>…<!-- … --></mo>
      </mtd>
      <mtd/>
      <mtd/>
    </mtr>
  </mtable>
</math>
Finally, we form a sequence by taking the first term in each row of the
tableau:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">accelerated-sequence transform s</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">stream-map stream-car
              </span><span class="opn">(</span><span class="pln">make-tableau transform s</span><span class="clo">)))</span></pre></div>

<p>We can demonstrate this kind of “super-acceleration” of the <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>π<!-- π --></mi>
</math>
sequence:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="pln">display-stream 
 </span><span class="opn">(</span><span class="pln">accelerated-sequence euler-transform
                       pi-stream</span><span class="clo">))</span><span class="pln">
</span><i><span class="lit">4.</span></i><span class="pln">
</span><i><span class="lit">3.166666666666667</span></i><span class="pln">
</span><i><span class="lit">3.142105263157895</span></i><span class="pln">
</span><i><span class="lit">3.141599357319005</span></i><span class="pln">
</span><i><span class="lit">3.1415927140337785</span></i><span class="pln">
</span><i><span class="lit">3.1415926539752927</span></i><span class="pln">
</span><i><span class="lit">3.1415926535911765</span></i><span class="pln">
</span><i><span class="lit">3.141592653589778</span></i><span class="pln">
</span><span class="roman"><span class="pun">…</span></span>
</pre></div>

<p>The result is impressive.  Taking eight terms of the sequence yields the
correct value of <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>π<!-- π --></mi>
</math> to 14 decimal places.  If we had used only the
original <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>π<!-- π --></mi>
</math> sequence, we would need to compute on the order of <math xmlns="http://www.w3.org/1998/Math/MathML">
  <msup>
    <mn>10</mn>
    <mrow class="MJX-TeXAtom-ORD">
      <mn>13</mn>
    </mrow>
  </msup>
</math>
terms (i.e., expanding the series far enough so that the individual terms are
less than <math xmlns="http://www.w3.org/1998/Math/MathML">
  <msup>
    <mn>10</mn>
    <mrow class="MJX-TeXAtom-ORD">
      <mo>−<!-- − --></mo>
      <mn>13</mn>
    </mrow>
  </msup>
</math>) to get that much accuracy!
</p>
<p>We could have implemented these acceleration techniques without using streams.
But the stream formulation is particularly elegant and convenient because the
entire sequence of states is available to us as a data structure that can be
manipulated with a uniform set of operations.
</p>
<blockquote>
<p><strong><a id="Exercise-3_002e63"></a>Exercise 3.63:</strong> Louis Reasoner asks why the
<code>sqrt-stream</code> procedure was not written in the following more
straightforward way, without the local variable <code>guesses</code>:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">sqrt-stream x</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">cons-stream 
   </span><span class="lit">1.0</span><span class="pln">
   </span><span class="opn">(</span><span class="pln">stream-map </span><span class="opn">(</span><span class="kwd">lambda</span><span class="pln"> </span><span class="opn">(</span><span class="pln">guess</span><span class="clo">)</span><span class="pln">
                 </span><span class="opn">(</span><span class="pln">sqrt-improve guess x</span><span class="clo">))</span><span class="pln">
               </span><span class="opn">(</span><span class="pln">sqrt-stream x</span><span class="clo">))))</span></pre></div>

<p>Alyssa P. Hacker replies that this version of the procedure is considerably
less efficient because it performs redundant computation.  Explain Alyssa’s
answer.  Would the two versions still differ in efficiency if our
implementation of <code>delay</code> used only <code>(lambda () ⟨<var>exp</var>⟩)</code> without
using the optimization provided by <code>memo-proc</code> (<a href="3_002e5_002e1.xhtml#g_t3_002e5_002e1">3.5.1</a>)?
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-3_002e64"></a>Exercise 3.64:</strong> Write a procedure
<code>stream-limit</code> that takes as arguments a stream and a number (the
tolerance).  It should examine the stream until it finds two successive
elements that differ in absolute value by less than the tolerance, and return
the second of the two elements.  Using this, we could compute square roots up
to a given tolerance by
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">sqrt x tolerance</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">stream-limit </span><span class="opn">(</span><span class="pln">sqrt-stream x</span><span class="clo">)</span><span class="pln"> tolerance</span><span class="clo">))</span></pre></div>
</blockquote>

<blockquote>
<p><strong><a id="Exercise-3_002e65"></a>Exercise 3.65:</strong> Use the series
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mi>ln</mi>
  <mo>⁡<!-- ⁡ --></mo>
  <mn>2</mn>
  <mspace width="thinmathspace"/>
  <mo>=</mo>
  <mspace width="thinmathspace"/>
  <mn>1</mn>
  <mo>−<!-- − --></mo>
  <mrow class="MJX-TeXAtom-ORD">
    <mfrac>
      <mn>1</mn>
      <mn>2</mn>
    </mfrac>
  </mrow>
  <mo>+</mo>
  <mrow class="MJX-TeXAtom-ORD">
    <mfrac>
      <mn>1</mn>
      <mn>3</mn>
    </mfrac>
  </mrow>
  <mo>−<!-- − --></mo>
  <mrow class="MJX-TeXAtom-ORD">
    <mfrac>
      <mn>1</mn>
      <mn>4</mn>
    </mfrac>
  </mrow>
  <mo>+</mo>
  <mo>…<!-- … --></mo>
</math>
to compute three sequences of approximations to the natural logarithm of 2, in
the same way we did above for <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>π<!-- π --></mi>
</math>.  How rapidly do these sequences
converge?
</p></blockquote>

<a id="Infinite-streams-of-pairs"></a>
<h5 class="subsubheading">Infinite streams of pairs</h5>

<p>In <a href="2_002e2_002e3.xhtml#g_t2_002e2_002e3">2.2.3</a>, we saw how the sequence paradigm handles traditional
nested loops as processes defined on sequences of pairs.  If we generalize this
technique to infinite streams, then we can write programs that are not easily
represented as loops, because the “looping” must range over an infinite set.
</p>
<p>For example, suppose we want to generalize the <code>prime-sum-pairs</code> procedure
of <a href="2_002e2_002e3.xhtml#g_t2_002e2_002e3">2.2.3</a> to produce the stream of pairs of <em>all</em> integers
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
  </mrow>
</math> with <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mi>i</mi>
    <mo>≤<!-- ≤ --></mo>
    <mi>j</mi>
  </mrow>
</math> such that <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mi>i</mi>
    <mo>+</mo>
    <mi>j</mi>
  </mrow>
</math> is prime.  If
<code>int-pairs</code> is the sequence of all pairs of integers <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
  </mrow>
</math> with
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mi>i</mi>
    <mo>≤<!-- ≤ --></mo>
    <mi>j</mi>
  </mrow>
</math>, then our required stream is simply<a class="footnote_link" id="DOCF194" href="#FOOT194"><sup>194</sup></a>
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="pln">stream-filter 
 </span><span class="opn">(</span><span class="kwd">lambda</span><span class="pln"> </span><span class="opn">(</span><span class="pln">pair</span><span class="clo">)</span><span class="pln">
   </span><span class="opn">(</span><span class="pln">prime? </span><span class="opn">(</span><span class="pun">+</span><span class="pln"> </span><span class="opn">(</span><span class="kwd">car</span><span class="pln"> pair</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="kwd">cadr</span><span class="pln"> pair</span><span class="clo">))))</span><span class="pln">
 int-pairs</span><span class="clo">)</span></pre></div>

<p>Our problem, then, is to produce the stream <code>int-pairs</code>.  More generally,
suppose we have two streams <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mi>S</mi>
    <mo>=</mo>
    <mo stretchy="false">(</mo>
    <msub>
      <mi>S</mi>
      <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
  </mrow>
</math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mi>T</mi>
    <mo>=</mo>
    <mo stretchy="false">(</mo>
    <msub>
      <mi>T</mi>
      <mi>j</mi>
    </msub>
    <mo stretchy="false">)</mo>
  </mrow>
</math>,
and imagine the infinite rectangular array
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mtable columnalign="center center center center" rowspacing="4pt" columnspacing="1em">
    <mtr>
      <mtd>
        <mo stretchy="false">(</mo>
        <msub>
          <mi>S</mi>
          <mn>0</mn>
        </msub>
        <mo>,</mo>
        <msub>
          <mi>T</mi>
          <mn>0</mn>
        </msub>
        <mo stretchy="false">)</mo>
      </mtd>
      <mtd>
        <mo stretchy="false">(</mo>
        <msub>
          <mi>S</mi>
          <mn>0</mn>
        </msub>
        <mo>,</mo>
        <msub>
          <mi>T</mi>
          <mn>1</mn>
        </msub>
        <mo stretchy="false">)</mo>
      </mtd>
      <mtd>
        <mo stretchy="false">(</mo>
        <msub>
          <mi>S</mi>
          <mn>0</mn>
        </msub>
        <mo>,</mo>
        <msub>
          <mi>T</mi>
          <mn>2</mn>
        </msub>
        <mo stretchy="false">)</mo>
      </mtd>
      <mtd>
        <mo>…<!-- … --></mo>
      </mtd>
    </mtr>
    <mtr>
      <mtd>
        <mo stretchy="false">(</mo>
        <msub>
          <mi>S</mi>
          <mn>1</mn>
        </msub>
        <mo>,</mo>
        <msub>
          <mi>T</mi>
          <mn>0</mn>
        </msub>
        <mo stretchy="false">)</mo>
      </mtd>
      <mtd>
        <mo stretchy="false">(</mo>
        <msub>
          <mi>S</mi>
          <mn>1</mn>
        </msub>
        <mo>,</mo>
        <msub>
          <mi>T</mi>
          <mn>1</mn>
        </msub>
        <mo stretchy="false">)</mo>
      </mtd>
      <mtd>
        <mo stretchy="false">(</mo>
        <msub>
          <mi>S</mi>
          <mn>1</mn>
        </msub>
        <mo>,</mo>
        <msub>
          <mi>T</mi>
          <mn>2</mn>
        </msub>
        <mo stretchy="false">)</mo>
      </mtd>
      <mtd>
        <mo>…<!-- … --></mo>
      </mtd>
    </mtr>
    <mtr>
      <mtd>
        <mo stretchy="false">(</mo>
        <msub>
          <mi>S</mi>
          <mn>2</mn>
        </msub>
        <mo>,</mo>
        <msub>
          <mi>T</mi>
          <mn>0</mn>
        </msub>
        <mo stretchy="false">)</mo>
      </mtd>
      <mtd>
        <mo stretchy="false">(</mo>
        <msub>
          <mi>S</mi>
          <mn>2</mn>
        </msub>
        <mo>,</mo>
        <msub>
          <mi>T</mi>
          <mn>1</mn>
        </msub>
        <mo stretchy="false">)</mo>
      </mtd>
      <mtd>
        <mo stretchy="false">(</mo>
        <msub>
          <mi>S</mi>
          <mn>2</mn>
        </msub>
        <mo>,</mo>
        <msub>
          <mi>T</mi>
          <mn>2</mn>
        </msub>
        <mo stretchy="false">)</mo>
      </mtd>
      <mtd>
        <mo>…<!-- … --></mo>
      </mtd>
    </mtr>
    <mtr>
      <mtd>
        <mo>…<!-- … --></mo>
      </mtd>
      <mtd/>
      <mtd/>
      <mtd/>
    </mtr>
  </mtable>
</math>
We wish to generate a stream that contains all the pairs in the array that lie
on or above the diagonal, i.e., the pairs
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mtable columnalign="center center center center" rowspacing="4pt" columnspacing="1em">
    <mtr>
      <mtd>
        <mo stretchy="false">(</mo>
        <msub>
          <mi>S</mi>
          <mn>0</mn>
        </msub>
        <mo>,</mo>
        <msub>
          <mi>T</mi>
          <mn>0</mn>
        </msub>
        <mo stretchy="false">)</mo>
      </mtd>
      <mtd>
        <mo stretchy="false">(</mo>
        <msub>
          <mi>S</mi>
          <mn>0</mn>
        </msub>
        <mo>,</mo>
        <msub>
          <mi>T</mi>
          <mn>1</mn>
        </msub>
        <mo stretchy="false">)</mo>
      </mtd>
      <mtd>
        <mo stretchy="false">(</mo>
        <msub>
          <mi>S</mi>
          <mn>0</mn>
        </msub>
        <mo>,</mo>
        <msub>
          <mi>T</mi>
          <mn>2</mn>
        </msub>
        <mo stretchy="false">)</mo>
      </mtd>
      <mtd>
        <mo>…<!-- … --></mo>
      </mtd>
    </mtr>
    <mtr>
      <mtd/>
      <mtd>
        <mo stretchy="false">(</mo>
        <msub>
          <mi>S</mi>
          <mn>1</mn>
        </msub>
        <mo>,</mo>
        <msub>
          <mi>T</mi>
          <mn>1</mn>
        </msub>
        <mo stretchy="false">)</mo>
      </mtd>
      <mtd>
        <mo stretchy="false">(</mo>
        <msub>
          <mi>S</mi>
          <mn>1</mn>
        </msub>
        <mo>,</mo>
        <msub>
          <mi>T</mi>
          <mn>2</mn>
        </msub>
        <mo stretchy="false">)</mo>
      </mtd>
      <mtd>
        <mo>…<!-- … --></mo>
      </mtd>
    </mtr>
    <mtr>
      <mtd/>
      <mtd/>
      <mtd>
        <mo stretchy="false">(</mo>
        <msub>
          <mi>S</mi>
          <mn>2</mn>
        </msub>
        <mo>,</mo>
        <msub>
          <mi>T</mi>
          <mn>2</mn>
        </msub>
        <mo stretchy="false">)</mo>
      </mtd>
      <mtd>
        <mo>…<!-- … --></mo>
      </mtd>
    </mtr>
    <mtr>
      <mtd/>
      <mtd/>
      <mtd/>
      <mtd>
        <mo>…<!-- … --></mo>
      </mtd>
    </mtr>
  </mtable>
</math>
(If we take both <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>S</mi>
</math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>T</mi>
</math> to be the stream of integers, then this will
be our desired stream <code>int-pairs</code>.)
</p>
<p>Call the general stream of pairs <code>(pairs S T)</code>, and consider it to be
composed of three parts: the pair <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mo stretchy="false">(</mo>
    <msub>
      <mi>S</mi>
      <mn>0</mn>
    </msub>
    <mo>,</mo>
    <msub>
      <mi>T</mi>
      <mn>0</mn>
    </msub>
    <mo stretchy="false">)</mo>
  </mrow>
</math>, the rest of the pairs in
the first row, and the remaining pairs:<a class="footnote_link" id="DOCF195" href="#FOOT195"><sup>195</sup></a>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mtable columnalign="center center center center" rowspacing="4pt" columnspacing="1em" rowlines="solid none" columnlines="solid none none">
    <mtr>
      <mtd>
        <mo stretchy="false">(</mo>
        <msub>
          <mi>S</mi>
          <mn>0</mn>
        </msub>
        <mo>,</mo>
        <msub>
          <mi>T</mi>
          <mn>0</mn>
        </msub>
        <mo stretchy="false">)</mo>
      </mtd>
      <mtd>
        <mo stretchy="false">(</mo>
        <msub>
          <mi>S</mi>
          <mn>0</mn>
        </msub>
        <mo>,</mo>
        <msub>
          <mi>T</mi>
          <mn>1</mn>
        </msub>
        <mo stretchy="false">)</mo>
      </mtd>
      <mtd>
        <mo stretchy="false">(</mo>
        <msub>
          <mi>S</mi>
          <mn>0</mn>
        </msub>
        <mo>,</mo>
        <msub>
          <mi>T</mi>
          <mn>2</mn>
        </msub>
        <mo stretchy="false">)</mo>
      </mtd>
      <mtd>
        <mo>…<!-- … --></mo>
      </mtd>
    </mtr>
    <mtr>
      <mtd/>
      <mtd>
        <mo stretchy="false">(</mo>
        <msub>
          <mi>S</mi>
          <mn>1</mn>
        </msub>
        <mo>,</mo>
        <msub>
          <mi>T</mi>
          <mn>1</mn>
        </msub>
        <mo stretchy="false">)</mo>
      </mtd>
      <mtd>
        <mo stretchy="false">(</mo>
        <msub>
          <mi>S</mi>
          <mn>1</mn>
        </msub>
        <mo>,</mo>
        <msub>
          <mi>T</mi>
          <mn>2</mn>
        </msub>
        <mo stretchy="false">)</mo>
      </mtd>
      <mtd>
        <mo>…<!-- … --></mo>
      </mtd>
    </mtr>
    <mtr>
      <mtd/>
      <mtd/>
      <mtd>
        <mo stretchy="false">(</mo>
        <msub>
          <mi>S</mi>
          <mn>2</mn>
        </msub>
        <mo>,</mo>
        <msub>
          <mi>T</mi>
          <mn>2</mn>
        </msub>
        <mo stretchy="false">)</mo>
      </mtd>
      <mtd>
        <mo>…<!-- … --></mo>
      </mtd>
    </mtr>
    <mtr>
      <mtd/>
      <mtd/>
      <mtd/>
      <mtd>
        <mo>…<!-- … --></mo>
      </mtd>
    </mtr>
  </mtable>
</math>
Observe that the third piece in this decomposition (pairs that are not in the
first row) is (recursively) the pairs formed from <code>(stream-cdr S)</code> and
<code>(stream-cdr T)</code>.  Also note that the second piece (the rest of the first
row) is
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="pln">stream-map </span><span class="opn">(</span><span class="kwd">lambda</span><span class="pln"> </span><span class="opn">(</span><span class="pln">x</span><span class="clo">)</span><span class="pln"> 
              </span><span class="opn">(</span><span class="pln">list </span><span class="opn">(</span><span class="pln">stream-car s</span><span class="clo">)</span><span class="pln"> x</span><span class="clo">))</span><span class="pln">
            </span><span class="opn">(</span><span class="pln">stream-cdr t</span><span class="clo">))</span></pre></div>

<p>Thus we can form our stream of pairs as follows:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">pairs s t</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">cons-stream
   </span><span class="opn">(</span><span class="pln">list </span><span class="opn">(</span><span class="pln">stream-car s</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">stream-car t</span><span class="clo">))</span><span class="pln">
   </span><span class="opn">(</span><span class="pln">⟨</span><var><span class="pln">combine-in-some-way</span></var><span class="pln">⟩
    </span><span class="opn">(</span><span class="pln">stream-map </span><span class="opn">(</span><span class="kwd">lambda</span><span class="pln"> </span><span class="opn">(</span><span class="pln">x</span><span class="clo">)</span><span class="pln"> 
                  </span><span class="opn">(</span><span class="pln">list </span><span class="opn">(</span><span class="pln">stream-car s</span><span class="clo">)</span><span class="pln"> x</span><span class="clo">))</span><span class="pln">
                </span><span class="opn">(</span><span class="pln">stream-cdr t</span><span class="clo">))</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">pairs </span><span class="opn">(</span><span class="pln">stream-cdr s</span><span class="clo">)</span><span class="pln">
           </span><span class="opn">(</span><span class="pln">stream-cdr t</span><span class="clo">)))))</span></pre></div>

<p>In order to complete the procedure, we must choose some way to combine the two
inner streams.  One idea is to use the stream analog of the <code>append</code>
procedure from <a href="2_002e2_002e1.xhtml#g_t2_002e2_002e1">2.2.1</a>:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">stream-append s1 s2</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> </span><span class="opn">(</span><span class="pln">stream-null? s1</span><span class="clo">)</span><span class="pln">
      s2
      </span><span class="opn">(</span><span class="pln">cons-stream 
       </span><span class="opn">(</span><span class="pln">stream-car s1</span><span class="clo">)</span><span class="pln">
       </span><span class="opn">(</span><span class="pln">stream-append </span><span class="opn">(</span><span class="pln">stream-cdr s1</span><span class="clo">)</span><span class="pln"> s2</span><span class="clo">))))</span></pre></div>

<p>This is unsuitable for infinite streams, however, because it takes all the
elements from the first stream before incorporating the second stream.  In
particular, if we try to generate all pairs of positive integers using
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="pln">pairs integers integers</span><span class="clo">)</span></pre></div>

<p>our stream of results will first try to run through all pairs with the first
integer equal to 1, and hence will never produce pairs with any other value of
the first integer.
</p>
<p>To handle infinite streams, we need to devise an order of combination that
ensures that every element will eventually be reached if we let our program run
long enough.  An elegant way to accomplish this is with the following
<code>interleave</code> procedure:<a class="footnote_link" id="DOCF196" href="#FOOT196"><sup>196</sup></a>
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">interleave s1 s2</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> </span><span class="opn">(</span><span class="pln">stream-null? s1</span><span class="clo">)</span><span class="pln">
      s2
      </span><span class="opn">(</span><span class="pln">cons-stream 
       </span><span class="opn">(</span><span class="pln">stream-car s1</span><span class="clo">)</span><span class="pln">
       </span><span class="opn">(</span><span class="pln">interleave s2 </span><span class="opn">(</span><span class="pln">stream-cdr s1</span><span class="clo">)))))</span></pre></div>

<p>Since <code>interleave</code> takes elements alternately from the two streams, every
element of the second stream will eventually find its way into the interleaved
stream, even if the first stream is infinite.
</p>
<p>We can thus generate the required stream of pairs as
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">pairs s t</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">cons-stream
   </span><span class="opn">(</span><span class="pln">list </span><span class="opn">(</span><span class="pln">stream-car s</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">stream-car t</span><span class="clo">))</span><span class="pln">
   </span><span class="opn">(</span><span class="pln">interleave
    </span><span class="opn">(</span><span class="pln">stream-map </span><span class="opn">(</span><span class="kwd">lambda</span><span class="pln"> </span><span class="opn">(</span><span class="pln">x</span><span class="clo">)</span><span class="pln"> 
                  </span><span class="opn">(</span><span class="pln">list </span><span class="opn">(</span><span class="pln">stream-car s</span><span class="clo">)</span><span class="pln"> x</span><span class="clo">))</span><span class="pln">
                </span><span class="opn">(</span><span class="pln">stream-cdr t</span><span class="clo">))</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">pairs </span><span class="opn">(</span><span class="pln">stream-cdr s</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">stream-cdr t</span><span class="clo">)))))</span></pre></div>

<blockquote>
<p><strong><a id="Exercise-3_002e66"></a>Exercise 3.66:</strong> Examine the stream <code>(pairs
integers integers)</code>. Can you make any general comments about the order in which
the pairs are placed into the stream? For example, approximately how many pairs precede
the pair (1, 100)?  the pair (99, 100)? the pair (100, 100)? (If you can make
precise mathematical statements here, all the better. But feel free to give
more qualitative answers if you find yourself getting bogged down.)
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-3_002e67"></a>Exercise 3.67:</strong> Modify the <code>pairs</code> procedure
so that <code>(pairs integers integers)</code> will produce the stream of <em>all</em>
pairs of integers <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
  </mrow>
</math> (without the condition <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mi>i</mi>
    <mo>≤<!-- ≤ --></mo>
    <mi>j</mi>
  </mrow>
</math>).  Hint:
You will need to mix in an additional stream.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-3_002e68"></a>Exercise 3.68:</strong> Louis Reasoner thinks that
building a stream of pairs from three parts is unnecessarily complicated.
Instead of separating the pair <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mo stretchy="false">(</mo>
    <msub>
      <mi>S</mi>
      <mn>0</mn>
    </msub>
    <mo>,</mo>
    <msub>
      <mi>T</mi>
      <mn>0</mn>
    </msub>
    <mo stretchy="false">)</mo>
  </mrow>
</math> from the rest of the pairs in
the first row, he proposes to work with the whole first row, as follows:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">pairs s t</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">interleave
   </span><span class="opn">(</span><span class="pln">stream-map
    </span><span class="opn">(</span><span class="kwd">lambda</span><span class="pln"> </span><span class="opn">(</span><span class="pln">x</span><span class="clo">)</span><span class="pln"> 
      </span><span class="opn">(</span><span class="pln">list </span><span class="opn">(</span><span class="pln">stream-car s</span><span class="clo">)</span><span class="pln"> x</span><span class="clo">))</span><span class="pln">
    t</span><span class="clo">)</span><span class="pln">
   </span><span class="opn">(</span><span class="pln">pairs </span><span class="opn">(</span><span class="pln">stream-cdr s</span><span class="clo">)</span><span class="pln">
          </span><span class="opn">(</span><span class="pln">stream-cdr t</span><span class="clo">))))</span></pre></div>

<p>Does this work?  Consider what happens if we evaluate <code>(pairs integers
integers)</code> using Louis’s definition of <code>pairs</code>.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-3_002e69"></a>Exercise 3.69:</strong> Write a procedure <code>triples</code>
that takes three infinite streams, <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>S</mi>
</math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>T</mi>
</math>, and <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>U</mi>
</math>, and produces the
stream of triples <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mo stretchy="false">(</mo>
    <msub>
      <mi>S</mi>
      <mi>i</mi>
    </msub>
    <mo>,</mo>
    <msub>
      <mi>T</mi>
      <mi>j</mi>
    </msub>
    <mo>,</mo>
    <msub>
      <mi>U</mi>
      <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
  </mrow>
</math> such that <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mi>i</mi>
    <mo>≤<!-- ≤ --></mo>
    <mi>j</mi>
    <mo>≤<!-- ≤ --></mo>
    <mi>k</mi>
  </mrow>
</math>.  
Use <code>triples</code> to generate the stream of all Pythagorean
triples of positive integers, i.e., the triples <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
  </mrow>
</math> such that
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mi>i</mi>
    <mo>≤<!-- ≤ --></mo>
    <mi>j</mi>
  </mrow>
</math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <msup>
      <mi>i</mi>
      <mn>2</mn>
    </msup>
    <mo>+</mo>
    <msup>
      <mi>j</mi>
      <mn>2</mn>
    </msup>
    <mo>=</mo>
    <msup>
      <mi>k</mi>
      <mn>2</mn>
    </msup>
  </mrow>
</math>.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-3_002e70"></a>Exercise 3.70:</strong> It would be nice to be able to
generate streams in which the pairs appear in some useful order, rather than in
the order that results from an <em>ad hoc</em> interleaving process.  We can use
a technique similar to the <code>merge</code> procedure of <a href="3_002e5_002e2.xhtml#Exercise-3_002e56">Exercise 3.56</a>, if we
define a way to say that one pair of integers is “less than” another.  One
way to do this is to define a “weighting function” <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mi>W</mi>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
  </mrow>
</math> and
stipulate that <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mo stretchy="false">(</mo>
    <msub>
      <mi>i</mi>
      <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
      <mi>j</mi>
      <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
  </mrow>
</math> is less than <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mo stretchy="false">(</mo>
    <msub>
      <mi>i</mi>
      <mn>2</mn>
    </msub>
    <mo>,</mo>
    <msub>
      <mi>j</mi>
      <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
  </mrow>
</math> if
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mi>W</mi>
    <mo stretchy="false">(</mo>
    <msub>
      <mi>i</mi>
      <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
      <mi>j</mi>
      <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
    <mo>&lt;</mo>
  </mrow>
  <mrow class="MJX-TeXAtom-ORD">
    <mi>W</mi>
    <mo stretchy="false">(</mo>
    <msub>
      <mi>i</mi>
      <mn>2</mn>
    </msub>
    <mo>,</mo>
    <msub>
      <mi>j</mi>
      <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
  </mrow>
</math>.  Write a procedure
<code>merge-weighted</code> that is like <code>merge</code>, except that
<code>merge-weighted</code> takes an additional argument <code>weight</code>, which is a
procedure that computes the weight of a pair, and is used to determine the
order in which elements should appear in the resulting merged
stream.<a class="footnote_link" id="DOCF197" href="#FOOT197"><sup>197</sup></a>  Using this, generalize <code>pairs</code> to a procedure
<code>weighted-pairs</code> that takes two streams, together with a procedure that
computes a weighting function, and generates the stream of pairs, ordered
according to weight.  Use your procedure to generate
</p>
<ol>
<li> the stream of all pairs of positive integers <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
  </mrow>
</math> with <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mi>i</mi>
    <mo>≤<!-- ≤ --></mo>
    <mi>j</mi>
  </mrow>
</math>
ordered according to the sum <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mi>i</mi>
    <mo>+</mo>
    <mi>j</mi>
  </mrow>
</math>,

</li><li> the stream of all pairs of positive integers <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
  </mrow>
</math> with <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mi>i</mi>
    <mo>≤<!-- ≤ --></mo>
    <mi>j</mi>
  </mrow>
</math>,
where neither <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>i</mi>
</math> nor <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>j</mi>
</math> is divisible by 2, 3, or 5, and the pairs are
ordered according to the sum <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mn>2</mn>
    <mi>i</mi>
    <mo>+</mo>
    <mn>3</mn>
    <mi>j</mi>
    <mo>+</mo>
    <mn>5</mn>
    <mi>i</mi>
    <mi>j</mi>
  </mrow>
</math>.

</li></ol>
</blockquote>

<blockquote>
<p><strong><a id="Exercise-3_002e71"></a>Exercise 3.71:</strong> Numbers that can be expressed as
the sum of two cubes in more than one way are sometimes called
<a id="index-Ramanujan-numbers"></a>
<em>Ramanujan numbers</em>, in honor of the mathematician Srinivasa
Ramanujan.<a class="footnote_link" id="DOCF198" href="#FOOT198"><sup>198</sup></a> Ordered streams of pairs provide an elegant
solution to the problem of computing these numbers.  To find a number that can
be written as the sum of two cubes in two different ways, we need only generate
the stream of pairs of integers <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
  </mrow>
</math> weighted according to the sum
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <msup>
      <mi>i</mi>
      <mn>3</mn>
    </msup>
    <mo>+</mo>
    <msup>
      <mi>j</mi>
      <mn>3</mn>
    </msup>
  </mrow>
</math> (see <a href="#Exercise-3_002e70">Exercise 3.70</a>), then search the stream for two
consecutive pairs with the same weight.  Write a procedure to generate the
Ramanujan numbers.  The first such number is 1,729.  What are the next five?
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-3_002e72"></a>Exercise 3.72:</strong> In a similar way to <a href="#Exercise-3_002e71">Exercise 3.71</a> 
generate a stream of all numbers that can be written as the sum of two
squares in three different ways (showing how they can be so written).
</p></blockquote>

<a id="Streams-as-signals"></a>
<h5 class="subsubheading">Streams as signals</h5>

<p>We began our discussion of streams by describing them as computational analogs
of the “signals” in signal-processing systems.  In fact, we can use streams
to model signal-processing systems in a very direct way, representing the
values of a signal at successive time intervals as consecutive elements of a
stream.  For instance, we can implement an <a id="index-integrator"></a>
<em>integrator</em> or
<a id="index-summer"></a>
<em>summer</em> that, for an input stream <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mi>x</mi>
    <mo>=</mo>
    <mo stretchy="false">(</mo>
    <msub>
      <mi>x</mi>
      <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
  </mrow>
</math>, an initial
value <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>C</mi>
</math>, and a small increment <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mi>d</mi>
    <mi>t</mi>
  </mrow>
</math>, accumulates the sum
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <msub>
    <mi>S</mi>
    <mi>i</mi>
  </msub>
  <mspace width="thinmathspace"/>
  <mo>=</mo>
  <mspace width="thinmathspace"/>
  <mi>C</mi>
  <mo>+</mo>
  <mrow class="MJX-TeXAtom-ORD">
    <munderover>
      <mo>∑<!-- ∑ --></mo>
      <mrow class="MJX-TeXAtom-ORD">
        <mi>j</mi>
        <mspace width="0.07em"/>
        <mo>=</mo>
        <mspace width="0.03em"/>
        <mn>1</mn>
      </mrow>
      <mi>i</mi>
    </munderover>
    <msub>
      <mi>x</mi>
      <mi>j</mi>
    </msub>
    <mspace width="0.1em"/>
    <mi>d</mi>
    <mi>t</mi>
  </mrow>
</math>
and returns the stream of values <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mi>S</mi>
    <mo>=</mo>
    <mo stretchy="false">(</mo>
    <msub>
      <mi>S</mi>
      <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
  </mrow>
</math>.  The following
<code>integral</code> procedure is reminiscent of the “implicit style” definition
of the stream of integers (<a href="3_002e5_002e2.xhtml#g_t3_002e5_002e2">3.5.2</a>):
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">integral integrand initial-value dt</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> int
    </span><span class="opn">(</span><span class="pln">cons-stream 
     initial-value
     </span><span class="opn">(</span><span class="pln">add-streams </span><span class="opn">(</span><span class="pln">scale-stream integrand dt</span><span class="clo">)</span><span class="pln">
                  int</span><span class="clo">)))</span><span class="pln">
  int</span><span class="clo">)</span></pre></div>

<p><a href="#Figure-3_002e32">Figure 3.32</a> is a picture of a signal-processing system that corresponds
to the <code>integral</code> procedure.  The input stream is scaled by <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mi>d</mi>
    <mi>t</mi>
  </mrow>
</math> and
passed through an adder, whose output is passed back through the same adder.
The self-reference in the definition of <code>int</code> is reflected in the figure
by the feedback loop that connects the output of the adder to one of the
inputs.
</p>
<figure class="float">
<a id="Figure-3_002e32"></a>
<object style="width: 59.32ex; height: 20.20ex;" data="fig/chap3/Fig3.32a.std.svg" type="image/svg+xml">SVG</object>

<figcaption class="float-caption">
<p><strong>Figure 3.32:</strong> The <code>integral</code> procedure viewed as a signal-processing system.</p>
</figcaption>
</figure>

<blockquote>
<p><strong><a id="Exercise-3_002e73"></a>Exercise 3.73:</strong> We can model electrical circuits
using streams to represent the values of currents or voltages at a sequence of
times.  For instance, suppose we have an <a id="index-RC-circuit"></a>
<em>RC circuit</em> consisting of a
resistor of resistance <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>R</mi>
</math> and a capacitor of capacitance <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>C</mi>
</math> in series.
The voltage response <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>v</mi>
</math> of the circuit to an injected current <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>i</mi>
</math> is
determined by the formula in <a href="#Figure-3_002e33">Figure 3.33</a>, whose structure is shown by the
accompanying signal-flow diagram.
</p>
<figure class="float">
<a id="Figure-3_002e33"></a>
<object style="width: 50.08ex; height: 37.47ex;" data="fig/chap3/Fig3.33a.std.svg" type="image/svg+xml">SVG</object>

<figcaption class="float-caption">
<p><strong>Figure 3.33:</strong> An RC circuit and the associated signal-flow diagram.</p>
</figcaption>
</figure>

<p>Write a procedure <code>RC</code> that models this circuit.  <code>RC</code> should take as
inputs the values of <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>R</mi>
</math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>C</mi>
</math>, and <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mi>d</mi>
    <mi>t</mi>
  </mrow>
</math> and should return a procedure
that takes as inputs a stream representing the current <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>i</mi>
</math> and an initial
value for the capacitor voltage <math xmlns="http://www.w3.org/1998/Math/MathML">
  <msub>
    <mi>v</mi>
    <mn>0</mn>
  </msub>
</math> and produces as output the stream of
voltages <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>v</mi>
</math>.  For example, you should be able to use <code>RC</code> to model an
RC circuit with <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>R</mi>
</math> = 5 ohms, <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>C</mi>
</math> = 1 farad, and a 0.5-second time step by
evaluating <code>(define RC1 (RC 5 1 0.5))</code>.  This defines <code>RC1</code> as a
procedure that takes a stream representing the time sequence of currents and an
initial capacitor voltage and produces the output stream of voltages.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-3_002e74"></a>Exercise 3.74:</strong> Alyssa P. Hacker is designing a
system to process signals coming from physical sensors.  One important feature
she wishes to produce is a signal that describes the <a id="index-zero-crossings"></a>
<em>zero crossings</em>
of the input signal.  That is, the resulting signal should be <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mo>+</mo>
    <mn>1</mn>
  </mrow>
</math> whenever the
input signal changes from negative to positive, <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mo>−<!-- − --></mo>
    <mn>1</mn>
  </mrow>
</math> whenever the input signal
changes from positive to negative, and <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mn>0</mn>
</math> otherwise.  (Assume that the sign of a
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mn>0</mn>
</math> input is positive.)  For example, a typical input signal with its associated
zero-crossing signal would be
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="roman"><span class="pun">…</span></span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="lit">1.5</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="lit">0.5</span><span class="pln"> </span><span class="lit">-0.1</span><span class="pln"> </span><span class="lit">-2</span><span class="pln"> </span><span class="lit">-3</span><span class="pln"> </span><span class="lit">-2</span><span class="pln"> </span><span class="lit">-0.5</span><span class="pln"> </span><span class="lit">0.2</span><span class="pln"> </span><span class="lit">3</span><span class="pln"> </span><span class="lit">4</span><span class="pln"> </span><span class="roman"><span class="pun">…</span></span><span class="pln">
</span><span class="roman"><span class="pun">…</span></span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="lit">0</span><span class="pln">  </span><span class="lit">0</span><span class="pln">  </span><span class="lit">0</span><span class="pln">  </span><span class="lit">0</span><span class="pln">   </span><span class="lit">-1</span><span class="pln">   </span><span class="lit">0</span><span class="pln">  </span><span class="lit">0</span><span class="pln">  </span><span class="lit">0</span><span class="pln">   </span><span class="lit">0</span><span class="pln">   </span><span class="lit">1</span><span class="pln">  </span><span class="lit">0</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="roman"><span class="pun">…</span></span>
</pre></div>

<p>In Alyssa’s system, the signal from the sensor is represented as a stream
<code>sense-data</code> and the stream <code>zero-crossings</code> is the corresponding
stream of zero crossings.  Alyssa first writes a procedure
<code>sign-change-detector</code> that takes two values as arguments and compares the
signs of the values to produce an appropriate <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mn>0</mn>
</math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mn>1</mn>
</math>, or <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mo>−<!-- − --></mo>
    <mn>1</mn>
  </mrow>
</math>.  She then
constructs her zero-crossing stream as follows:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">make-zero-crossings
         input-stream last-value</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">cons-stream
   </span><span class="opn">(</span><span class="pln">sign-change-detector 
    </span><span class="opn">(</span><span class="pln">stream-car input-stream</span><span class="clo">)</span><span class="pln"> 
    last-value</span><span class="clo">)</span><span class="pln">
   </span><span class="opn">(</span><span class="pln">make-zero-crossings 
    </span><span class="opn">(</span><span class="pln">stream-cdr input-stream</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">stream-car input-stream</span><span class="clo">))))</span><span class="pln">

</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> zero-crossings 
  </span><span class="opn">(</span><span class="pln">make-zero-crossings sense-data </span><span class="lit">0</span><span class="clo">))</span></pre></div>

<p>Alyssa’s boss, Eva Lu Ator, walks by and suggests that this program is
approximately equivalent to the following one, which uses the generalized
version of <code>stream-map</code> from <a href="3_002e5_002e1.xhtml#Exercise-3_002e50">Exercise 3.50</a>:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> zero-crossings
  </span><span class="opn">(</span><span class="pln">stream-map sign-change-detector 
              sense-data 
              ⟨</span><var><span class="pln">expression</span></var><span class="pln">⟩</span><span class="clo">))</span></pre></div>

<p>Complete the program by supplying the indicated <code>⟨</code><var>expression</var><code>⟩</code>.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-3_002e75"></a>Exercise 3.75:</strong> Unfortunately, Alyssa’s
zero-crossing detector in <a href="#Exercise-3_002e74">Exercise 3.74</a> proves to be insufficient,
because the noisy signal from the sensor leads to spurious zero crossings.  Lem
E.  Tweakit, a hardware specialist, suggests that Alyssa smooth the signal to
filter out the noise before extracting the zero crossings.  Alyssa takes his
advice and decides to extract the zero crossings from the signal constructed by
averaging each value of the sense data with the previous value.  She explains
the problem to her assistant, Louis Reasoner, who attempts to implement the
idea, altering Alyssa’s program as follows:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">make-zero-crossings 
         input-stream last-value</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">let</span><span class="pln"> </span><span class="opn">((</span><span class="pln">avpt 
         </span><span class="opn">(</span><span class="pun">/</span><span class="pln"> </span><span class="opn">(</span><span class="pun">+</span><span class="pln"> </span><span class="opn">(</span><span class="pln">stream-car input-stream</span><span class="clo">)</span><span class="pln"> 
               last-value</span><span class="clo">)</span><span class="pln"> 
            </span><span class="lit">2</span><span class="clo">)))</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">cons-stream 
     </span><span class="opn">(</span><span class="pln">sign-change-detector avpt last-value</span><span class="clo">)</span><span class="pln">
     </span><span class="opn">(</span><span class="pln">make-zero-crossings 
      </span><span class="opn">(</span><span class="pln">stream-cdr input-stream</span><span class="clo">)</span><span class="pln"> avpt</span><span class="clo">))))</span></pre></div>

<p>This does not correctly implement Alyssa’s plan.  Find the bug that Louis has
installed and fix it without changing the structure of the program.  (Hint: You
will need to increase the number of arguments to <code>make-zero-crossings</code>.)
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-3_002e76"></a>Exercise 3.76:</strong> Eva Lu Ator has a criticism of
Louis’s approach in <a href="#Exercise-3_002e75">Exercise 3.75</a>.  The program he wrote is not modular,
because it intermixes the operation of smoothing with the zero-crossing
extraction.  For example, the extractor should not have to be changed if Alyssa
finds a better way to condition her input signal.  Help Louis by writing a
procedure <code>smooth</code> that takes a stream as input and produces a stream in
which each element is the average of two successive input stream elements.
Then use <code>smooth</code> as a component to implement the zero-crossing detector
in a more modular style.
</p></blockquote>

<div class="footnote">
<hr />

<h4 class="footnotes-heading">Footnotes</h4>

<div id="FOOT193"><p><a class="footnote_backlink" href="#DOCF193"><sup>193</sup></a>
We can’t use <code>let</code>
to bind the local variable <code>guesses</code>, because the value of <code>guesses</code>
depends on <code>guesses</code> itself.  <a href="#Exercise-3_002e63">Exercise 3.63</a> addresses why we want a
local variable here.</p>
</div>
<div id="FOOT194"><p><a class="footnote_backlink" href="#DOCF194"><sup>194</sup></a>
As in 
<a href="2_002e2_002e3.xhtml#g_t2_002e2_002e3">2.2.3</a>, we represent a pair of integers as a list rather than a Lisp
pair.</p>
</div>
<div id="FOOT195"><p><a class="footnote_backlink" href="#DOCF195"><sup>195</sup></a>
See <a href="#Exercise-3_002e68">Exercise 3.68</a> for
some insight into why we chose this decomposition.</p>
</div>
<div id="FOOT196"><p><a class="footnote_backlink" href="#DOCF196"><sup>196</sup></a>
The precise statement of the required
property on the order of combination is as follows: There should be a function
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>f</mi>
</math> of two arguments such that the pair corresponding to element <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>i</mi>
</math> of the
first stream and element <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>j</mi>
</math> of the second stream will appear as element
number <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow class="MJX-TeXAtom-ORD">
    <mi>f</mi>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
  </mrow>
</math> of the output stream.  The trick of using
<code>interleave</code> to accomplish this was shown to us by David Turner, who
employed it in the language KRC (<a href="References.xhtml#Turner-1981">Turner 1981</a>).</p>
</div>
<div id="FOOT197"><p><a class="footnote_backlink" href="#DOCF197"><sup>197</sup></a>
We will require that the weighting function be such that the
weight of a pair increases as we move out along a row or down along a column of
the array of pairs.</p>
</div>
<div id="FOOT198"><p><a class="footnote_backlink" href="#DOCF198"><sup>198</sup></a>
To quote from G. H. Hardy’s obituary of Ramanujan (<a href="References.xhtml#Hardy-1921">Hardy 1921</a>): 
“It was Mr. Littlewood (I believe) who remarked that ‘every positive
integer was one of his friends.’  I remember once going to see him when he was
lying ill at Putney.  I had ridden in taxi-cab No. 1729, and remarked that the
number seemed to me a rather dull one, and that I hoped it was not an
unfavorable omen.  ‘No,’ he replied, ‘it is a very interesting number; it is
the smallest number expressible as the sum of two cubes in two different ways.’
” The trick of using weighted pairs to generate the Ramanujan numbers was
shown to us by Charles Leiserson.</p>
</div>
</div>
<hr />
<nav class="header">
<p>
Next: <a href="3_002e5_002e4.xhtml#g_t3_002e5_002e4" accesskey="n" rel="next">3.5.4</a>, Previous: <a href="3_002e5_002e2.xhtml#g_t3_002e5_002e2" accesskey="p" rel="prev">3.5.2</a>, Up: <a href="3_002e5.xhtml#g_t3_002e5" accesskey="u" rel="prev">3.5</a>   [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>


</section>
</body>
</html>