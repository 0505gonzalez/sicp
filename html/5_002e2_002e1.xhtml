<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Structure and Interpretation of Computer Programs, 2e: 5.2.1</title>

<meta name="description" content="Structure and Interpretation of Computer Programs, 2e: 5.2.1" />
<meta name="keywords" content="Structure and Interpretation of Computer Programs, 2e: 5.2.1" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="Generator" content="texi2any" />
<meta charset="utf-8" />
<link href="index.xhtml#Top" rel="start" title="Top" />
<link href="Term-Index.xhtml#Term-Index" rel="index" title="Term Index" />
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents" />
<link href="5_002e2.xhtml#g_t5_002e2" rel="prev" title="5.2" />
<link href="5_002e2_002e2.xhtml#g_t5_002e2_002e2" rel="next" title="5.2.2" />
<link href="5_002e2.xhtml#g_t5_002e2" rel="prev" title="5.2" />

<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />

<script src="js/jquery.min.js" type="text/javascript"></script>
<script src="js/footnotes.js" type="text/javascript"></script>
<script src="js/browsertest.js" type="text/javascript"></script>
</head>

<body>
<section><a id="g_t5_002e2_002e1"></a>
<nav class="header">
<p>
Next: <a href="5_002e2_002e2.xhtml#g_t5_002e2_002e2" accesskey="n" rel="next">5.2.2</a>, Previous: <a href="5_002e2.xhtml#g_t5_002e2" accesskey="p" rel="prev">5.2</a>, Up: <a href="5_002e2.xhtml#g_t5_002e2" accesskey="u" rel="prev">5.2</a>   [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>
<hr />

<a id="The-Machine-Model"></a>
<h4 class="subsection"><span class="secnum">5.2.1</span><span class="sectitle">The Machine Model</span></h4>

<p>The machine model generated by <code>make-machine</code> is represented as a
procedure with local state using the message-passing techniques developed in
<a href="Chapter-3.xhtml#Chapter-3">Chapter 3</a>.  To build this model, <code>make-machine</code> begins by calling
the procedure <code>make-new-machine</code> to construct the parts of the machine
model that are common to all register machines.  This basic machine model
constructed by <code>make-new-machine</code> is essentially a container for some
registers and a stack, together with an execution mechanism that processes the
controller instructions one by one.
</p>
<p><code>Make-machine</code> then extends this basic model (by sending it messages) to
include the registers, operations, and controller of the particular machine
being defined.  First it allocates a register in the new machine for each of
the supplied register names and installs the designated operations in the
machine.  Then it uses an <a id="index-assembler"></a>
<em>assembler</em> (described below in 
<a href="5_002e2_002e2.xhtml#g_t5_002e2_002e2">5.2.2</a>) to transform the controller list into instructions for the new
machine and installs these as the machine’s instruction sequence.
<code>Make-machine</code> returns as its value the modified machine model.
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">make-machine register-names 
                      ops 
                      controller-text</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">let</span><span class="pln"> </span><span class="opn">((</span><span class="pln">machine </span><span class="opn">(</span><span class="pln">make-new-machine</span><span class="clo">)))</span><span class="pln">
    </span><span class="opn">(</span><span class="pln">for-each </span><span class="opn">(</span><span class="kwd">lambda</span><span class="pln"> </span><span class="opn">(</span><span class="pln">register-name</span><span class="clo">)</span><span class="pln">
                </span><span class="opn">((</span><span class="pln">machine </span><span class="lit">'allocate-register</span><span class="clo">)</span><span class="pln"> 
                 register-name</span><span class="clo">))</span><span class="pln">
              register-names</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">((</span><span class="pln">machine </span><span class="lit">'install-operations</span><span class="clo">)</span><span class="pln"> ops</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">((</span><span class="pln">machine </span><span class="lit">'install-instruction-sequence</span><span class="clo">)</span><span class="pln">
     </span><span class="opn">(</span><span class="pln">assemble controller-text machine</span><span class="clo">))</span><span class="pln">
    machine</span><span class="clo">))</span></pre></div>

<a id="Registers"></a>
<h5 class="subsubheading">Registers</h5>

<p>We will represent a register as a procedure with local state, as in
<a href="Chapter-3.xhtml#Chapter-3">Chapter 3</a>.  The procedure <code>make-register</code> creates a register that
holds a value that can be accessed or changed:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">make-register name</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">let</span><span class="pln"> </span><span class="opn">((</span><span class="pln">contents </span><span class="lit">'</span><span class="pun">*</span><span class="pln">unassigned</span><span class="pun">*</span><span class="clo">))</span><span class="pln">
    </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">dispatch message</span><span class="clo">)</span><span class="pln">
      </span><span class="opn">(</span><span class="kwd">cond</span><span class="pln"> </span><span class="opn">((</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> message </span><span class="lit">'get</span><span class="clo">)</span><span class="pln"> contents</span><span class="clo">)</span><span class="pln">
            </span><span class="opn">((</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> message </span><span class="lit">'set</span><span class="clo">)</span><span class="pln">
             </span><span class="opn">(</span><span class="kwd">lambda</span><span class="pln"> </span><span class="opn">(</span><span class="pln">value</span><span class="clo">)</span><span class="pln"> 
               </span><span class="opn">(</span><span class="kwd">set</span><span class="pun">!</span><span class="pln"> contents value</span><span class="clo">)))</span><span class="pln">
            </span><span class="opn">(</span><span class="kwd">else</span><span class="pln">
             </span><span class="opn">(</span><span class="err">error</span><span class="pln"> </span><span class="str">"Unknown request: 
                     REGISTER"</span><span class="pln">
                    message</span><span class="clo">))))</span><span class="pln">
    dispatch</span><span class="clo">))</span></pre></div>

<p>The following procedures are used to access registers:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">get-contents register</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">register </span><span class="lit">'get</span><span class="clo">))</span><span class="pln">

</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">set-contents! register value</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">((</span><span class="pln">register </span><span class="lit">'set</span><span class="clo">)</span><span class="pln"> value</span><span class="clo">))</span></pre></div>

<a id="The-stack"></a>
<h5 class="subsubheading">The stack</h5>

<p>We can also represent a stack as a procedure with local state.  The procedure
<code>make-stack</code> creates a stack whose local state consists of a list of the
items on the stack.  A stack accepts requests to <code>push</code> an item onto the
stack, to <code>pop</code> the top item off the stack and return it, and to
<code>initialize</code> the stack to empty.
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">make-stack</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">let</span><span class="pln"> </span><span class="opn">((</span><span class="pln">s </span><span class="lit">'</span><span class="opn">(</span><span class="clo">)))</span><span class="pln">
    </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">push x</span><span class="clo">)</span><span class="pln">
      </span><span class="opn">(</span><span class="kwd">set</span><span class="pun">!</span><span class="pln"> s </span><span class="opn">(</span><span class="kwd">cons</span><span class="pln"> x s</span><span class="clo">)))</span><span class="pln">
    </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">pop</span><span class="clo">)</span><span class="pln">
      </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> </span><span class="opn">(</span><span class="pln">null? s</span><span class="clo">)</span><span class="pln">
          </span><span class="opn">(</span><span class="err">error</span><span class="pln"> </span><span class="str">"Empty stack: POP"</span><span class="clo">)</span><span class="pln">
          </span><span class="opn">(</span><span class="kwd">let</span><span class="pln"> </span><span class="opn">((</span><span class="pln">top </span><span class="opn">(</span><span class="kwd">car</span><span class="pln"> s</span><span class="clo">)))</span><span class="pln">
            </span><span class="opn">(</span><span class="kwd">set</span><span class="pun">!</span><span class="pln"> s </span><span class="opn">(</span><span class="kwd">cdr</span><span class="pln"> s</span><span class="clo">))</span><span class="pln">
            top</span><span class="clo">)))</span><span class="pln">
    </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">initialize</span><span class="clo">)</span><span class="pln">
      </span><span class="opn">(</span><span class="kwd">set</span><span class="pun">!</span><span class="pln"> s </span><span class="lit">'</span><span class="opn">(</span><span class="clo">))</span><span class="pln">
      </span><span class="lit">'done</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">dispatch message</span><span class="clo">)</span><span class="pln">
      </span><span class="opn">(</span><span class="kwd">cond</span><span class="pln"> </span><span class="opn">((</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> message </span><span class="lit">'push</span><span class="clo">)</span><span class="pln"> push</span><span class="clo">)</span><span class="pln">
            </span><span class="opn">((</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> message </span><span class="lit">'pop</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">pop</span><span class="clo">))</span><span class="pln">
            </span><span class="opn">((</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> message </span><span class="lit">'initialize</span><span class="clo">)</span><span class="pln"> 
             </span><span class="opn">(</span><span class="pln">initialize</span><span class="clo">))</span><span class="pln">
            </span><span class="opn">(</span><span class="kwd">else</span><span class="pln"> 
             </span><span class="opn">(</span><span class="err">error</span><span class="pln"> </span><span class="str">"Unknown request: STACK"</span><span class="pln">
                    message</span><span class="clo">))))</span><span class="pln">
    dispatch</span><span class="clo">))</span></pre></div>

<p>The following procedures are used to access stacks:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">pop stack</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">stack </span><span class="lit">'pop</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">push stack value</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">((</span><span class="pln">stack </span><span class="lit">'push</span><span class="clo">)</span><span class="pln"> value</span><span class="clo">))</span></pre></div>

<a id="The-basic-machine"></a>
<h5 class="subsubheading">The basic machine</h5>

<p>The <code>make-new-machine</code> procedure, shown in <a href="#Figure-5_002e13">Figure 5.13<!-- /@w --></a>, 
constructs
an object whose local state consists of a stack, an initially empty instruction
sequence, a list of operations that initially contains an operation to
initialize the stack, and a <a id="index-register-table"></a>
<em>register table</em> that initially contains
two registers, named <code>flag</code> and <code>pc</code> (for “program counter”).  The
internal procedure <code>allocate-register</code> adds new entries to the register
table, and the internal procedure <code>lookup-register</code> looks up registers in
the table.
</p>
<p><strong><a id="Figure-5_002e13"></a>Figure 5.13:</strong> <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mo stretchy="false">↓<!-- ↓ --></mo>
</math> The <code>make-new-machine</code>
procedure, which implements the basic machine model.
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">make-new-machine</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">let</span><span class="pln"> </span><span class="opn">((</span><span class="pln">pc </span><span class="opn">(</span><span class="pln">make-register </span><span class="lit">'pc</span><span class="clo">))</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">flag </span><span class="opn">(</span><span class="pln">make-register </span><span class="lit">'flag</span><span class="clo">))</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">stack </span><span class="opn">(</span><span class="pln">make-stack</span><span class="clo">))</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">the-instruction-sequence </span><span class="lit">'</span><span class="opn">(</span><span class="clo">)))</span><span class="pln">
    </span><span class="opn">(</span><span class="kwd">let</span><span class="pln"> </span><span class="opn">((</span><span class="pln">the-ops
           </span><span class="opn">(</span><span class="pln">list 
            </span><span class="opn">(</span><span class="pln">list </span><span class="lit">'initialize-stack</span><span class="pln">
                  </span><span class="opn">(</span><span class="kwd">lambda</span><span class="pln"> </span><span class="opn">(</span><span class="clo">)</span><span class="pln"> 
                    </span><span class="opn">(</span><span class="pln">stack </span><span class="lit">'initialize</span><span class="clo">)))))</span><span class="pln">
          </span><span class="opn">(</span><span class="pln">register-table
           </span><span class="opn">(</span><span class="pln">list </span><span class="opn">(</span><span class="pln">list </span><span class="lit">'pc</span><span class="pln"> pc</span><span class="clo">)</span><span class="pln"> 
                 </span><span class="opn">(</span><span class="pln">list </span><span class="lit">'flag</span><span class="pln"> flag</span><span class="clo">))))</span><span class="pln">
      </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">allocate-register name</span><span class="clo">)</span><span class="pln">
        </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> </span><span class="opn">(</span><span class="pln">assoc name register-table</span><span class="clo">)</span><span class="pln">
            </span><span class="opn">(</span><span class="err">error</span><span class="pln"> 
             </span><span class="str">"Multiply defined register: "</span><span class="pln"> 
             name</span><span class="clo">)</span><span class="pln">
            </span><span class="opn">(</span><span class="kwd">set</span><span class="pun">!</span><span class="pln"> register-table
                  </span><span class="opn">(</span><span class="kwd">cons</span><span class="pln"> 
                   </span><span class="opn">(</span><span class="pln">list name 
                         </span><span class="opn">(</span><span class="pln">make-register name</span><span class="clo">))</span><span class="pln">
                   register-table</span><span class="clo">)))</span><span class="pln">
        </span><span class="lit">'register-allocated</span><span class="clo">)</span><span class="pln">
      </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">lookup-register name</span><span class="clo">)</span><span class="pln">
        </span><span class="opn">(</span><span class="kwd">let</span><span class="pln"> </span><span class="opn">((</span><span class="pln">val 
               </span><span class="opn">(</span><span class="pln">assoc name register-table</span><span class="clo">)))</span><span class="pln">
          </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> val
              </span><span class="opn">(</span><span class="kwd">cadr</span><span class="pln"> val</span><span class="clo">)</span><span class="pln">
              </span><span class="opn">(</span><span class="err">error</span><span class="pln"> </span><span class="str">"Unknown register:"</span><span class="pln"> 
                     name</span><span class="clo">))))</span><span class="pln">
      </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">execute</span><span class="clo">)</span><span class="pln">
        </span><span class="opn">(</span><span class="kwd">let</span><span class="pln"> </span><span class="opn">((</span><span class="pln">insts </span><span class="opn">(</span><span class="pln">get-contents pc</span><span class="clo">)))</span><span class="pln">
          </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> </span><span class="opn">(</span><span class="pln">null? insts</span><span class="clo">)</span><span class="pln">
              </span><span class="lit">'done</span><span class="pln">
              </span><span class="opn">(</span><span class="kwd">begin</span><span class="pln">
                </span><span class="opn">((</span><span class="pln">instruction-execution-proc 
                  </span><span class="opn">(</span><span class="kwd">car</span><span class="pln"> insts</span><span class="clo">)))</span><span class="pln">
                </span><span class="opn">(</span><span class="pln">execute</span><span class="clo">)))))</span><span class="pln">
      </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">dispatch message</span><span class="clo">)</span><span class="pln">
        </span><span class="opn">(</span><span class="kwd">cond</span><span class="pln"> </span><span class="opn">((</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> message </span><span class="lit">'start</span><span class="clo">)</span><span class="pln">
               </span><span class="opn">(</span><span class="pln">set-contents! 
                pc
                the-instruction-sequence</span><span class="clo">)</span><span class="pln">
               </span><span class="opn">(</span><span class="pln">execute</span><span class="clo">))</span><span class="pln">
              </span><span class="opn">((</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> 
                message 
                </span><span class="lit">'install-instruction-sequence</span><span class="clo">)</span><span class="pln">
               </span><span class="opn">(</span><span class="kwd">lambda</span><span class="pln"> </span><span class="opn">(</span><span class="pln">seq</span><span class="clo">)</span><span class="pln"> 
                 </span><span class="opn">(</span><span class="kwd">set</span><span class="pun">!</span><span class="pln"> 
                  the-instruction-sequence 
                  seq</span><span class="clo">)))</span><span class="pln">
              </span><span class="opn">((</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> message 
                    </span><span class="lit">'allocate-register</span><span class="clo">)</span><span class="pln"> 
               allocate-register</span><span class="clo">)</span><span class="pln">
              </span><span class="opn">((</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> message </span><span class="lit">'get-register</span><span class="clo">)</span><span class="pln"> 
               lookup-register</span><span class="clo">)</span><span class="pln">
              </span><span class="opn">((</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> message 
                    </span><span class="lit">'install-operations</span><span class="clo">)</span><span class="pln">
               </span><span class="opn">(</span><span class="kwd">lambda</span><span class="pln"> </span><span class="opn">(</span><span class="pln">ops</span><span class="clo">)</span><span class="pln"> 
                 </span><span class="opn">(</span><span class="kwd">set</span><span class="pun">!</span><span class="pln"> the-ops 
                       </span><span class="opn">(</span><span class="pln">append the-ops ops</span><span class="clo">))))</span><span class="pln">
              </span><span class="opn">((</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> message </span><span class="lit">'stack</span><span class="clo">)</span><span class="pln"> stack</span><span class="clo">)</span><span class="pln">
              </span><span class="opn">((</span><span class="kwd">eq</span><span class="pun">?</span><span class="pln"> message </span><span class="lit">'operations</span><span class="clo">)</span><span class="pln"> 
               the-ops</span><span class="clo">)</span><span class="pln">
              </span><span class="opn">(</span><span class="kwd">else</span><span class="pln"> </span><span class="opn">(</span><span class="err">error</span><span class="pln"> </span><span class="str">"Unknown request: 
                            MACHINE"</span><span class="pln">
                           message</span><span class="clo">))))</span><span class="pln">
      dispatch</span><span class="clo">)))</span></pre></div>

<p>The <code>flag</code> register is used to control branching in the simulated machine.
<code>Test</code> instructions set the contents of <code>flag</code> to the result of the
test (true or false).  <code>Branch</code> instructions decide whether or not to
branch by examining the contents of <code>flag</code>.
</p>
<p>The <code>pc</code> register determines the sequencing of instructions as the machine
runs.  This sequencing is implemented by the internal procedure <code>execute</code>.
In the simulation model, each machine instruction is a data structure that
includes a procedure of no arguments, called the <a id="index-instruction-execution-procedure"></a>
<em>instruction execution procedure</em>, 
such that calling this procedure simulates executing the
instruction.  As the simulation runs, <code>pc</code> points to the place in the
instruction sequence beginning with the next instruction to be executed.
<code>Execute</code> gets that instruction, executes it by calling the instruction
execution procedure, and repeats this cycle until there are no more
instructions to execute (i.e., until <code>pc</code> points to the end of the
instruction sequence).
</p>
<p>As part of its operation, each instruction execution procedure modifies
<code>pc</code> to indicate the next instruction to be executed.  <code>Branch</code> and
<code>goto</code> instructions change <code>pc</code> to point to the new destination.  All
other instructions simply advance <code>pc</code>, making it point to the next
instruction in the sequence.  Observe that each call to <code>execute</code> calls
<code>execute</code> again, but this does not produce an infinite loop because
running the instruction execution procedure changes the contents of <code>pc</code>.
</p>
<p><code>Make-new-machine</code> returns a <code>dispatch</code> procedure that implements
message-passing access to the internal state.  Notice that starting the machine
is accomplished by setting <code>pc</code> to the beginning of the instruction
sequence and calling <code>execute</code>.
</p>
<p>For convenience, we provide an alternate procedural interface to a machine’s
<code>start</code> operation, as well as procedures to set and examine register
contents, as specified at the beginning of <a href="5_002e2.xhtml#g_t5_002e2">5.2</a>:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">start machine</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">machine </span><span class="lit">'start</span><span class="clo">))</span><span class="pln">

</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">get-register-contents 
         machine register-name</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">get-contents 
   </span><span class="opn">(</span><span class="pln">get-register machine register-name</span><span class="clo">)))</span><span class="pln">

</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">set-register-contents! 
         machine register-name value</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">set-contents! 
   </span><span class="opn">(</span><span class="pln">get-register machine register-name</span><span class="clo">)</span><span class="pln"> 
   value</span><span class="clo">)</span><span class="pln">
  </span><span class="lit">'done</span><span class="clo">)</span></pre></div>

<p>These procedures (and many procedures in <a href="5_002e2_002e2.xhtml#g_t5_002e2_002e2">5.2.2</a> and <a href="5_002e2_002e3.xhtml#g_t5_002e2_002e3">5.2.3</a>)
use the following to look up the register with a given name in a given machine:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">get-register machine reg-name</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">((</span><span class="pln">machine </span><span class="lit">'get-register</span><span class="clo">)</span><span class="pln"> reg-name</span><span class="clo">))</span></pre></div>

<hr />
<nav class="header">
<p>
Next: <a href="5_002e2_002e2.xhtml#g_t5_002e2_002e2" accesskey="n" rel="next">5.2.2</a>, Previous: <a href="5_002e2.xhtml#g_t5_002e2" accesskey="p" rel="prev">5.2</a>, Up: <a href="5_002e2.xhtml#g_t5_002e2" accesskey="u" rel="prev">5.2</a>   [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>


</section>
</body>
</html>