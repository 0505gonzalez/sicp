<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Structure and Interpretation of Computer Programs, 2e: 5.5.5</title>

<meta name="description" content="Structure and Interpretation of Computer Programs, 2e: 5.5.5" />
<meta name="keywords" content="Structure and Interpretation of Computer Programs, 2e: 5.5.5" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="Generator" content="texi2any" />
<meta charset="utf-8" />
<link href="index.xhtml#Top" rel="start" title="Top" />
<link href="Term-Index.xhtml#Term-Index" rel="index" title="Term Index" />
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents" />
<link href="5_002e5.xhtml#g_t5_002e5" rel="prev" title="5.5" />
<link href="5_002e5_002e6.xhtml#g_t5_002e5_002e6" rel="next" title="5.5.6" />
<link href="5_002e5_002e4.xhtml#g_t5_002e5_002e4" rel="prev" title="5.5.4" />

<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />

<script src="js/jquery.min.js" type="text/javascript"></script>
<script src="js/footnotes.js" type="text/javascript"></script>
<script src="js/browsertest.js" type="text/javascript"></script>
</head>

<body>
<section><a id="g_t5_002e5_002e5"></a>
<nav class="header">
<p>
Next: <a href="5_002e5_002e6.xhtml#g_t5_002e5_002e6" accesskey="n" rel="next">5.5.6</a>, Previous: <a href="5_002e5_002e4.xhtml#g_t5_002e5_002e4" accesskey="p" rel="prev">5.5.4</a>, Up: <a href="5_002e5.xhtml#g_t5_002e5" accesskey="u" rel="prev">5.5</a>   [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>
<hr />

<a id="An-Example-of-Compiled-Code"></a>
<h4 class="subsection"><span class="secnum">5.5.5</span><span class="sectitle">An Example of Compiled Code</span></h4>

<p>Now that we have seen all the elements of the compiler, let us examine an
example of compiled code to see how things fit together.  We will compile the
definition of a recursive <code>factorial</code> procedure by calling <code>compile</code>:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="pln">compile
 </span><span class="lit">'</span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">factorial n</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> </span><span class="opn">(</span><span class="pun">=</span><span class="pln"> n </span><span class="lit">1</span><span class="clo">)</span><span class="pln">
        </span><span class="lit">1</span><span class="pln">
        </span><span class="opn">(</span><span class="pun">*</span><span class="pln"> </span><span class="opn">(</span><span class="pln">factorial </span><span class="opn">(</span><span class="pun">-</span><span class="pln"> n </span><span class="lit">1</span><span class="clo">))</span><span class="pln"> n</span><span class="clo">)))</span><span class="pln">
 </span><span class="lit">'val</span><span class="pln">
 </span><span class="lit">'next</span><span class="clo">)</span></pre></div>

<p>We have specified that the value of the <code>define</code> expression should be
placed in the <code>val</code> register.  We don’t care what the compiled code does
after executing the <code>define</code>, so our choice of <code>next</code> as the linkage
descriptor is arbitrary.
</p>
<p><code>Compile</code> determines that the expression is a definition, so it calls
<code>compile-definition</code> to compile code to compute the value to be assigned
(targeted to <code>val</code>), followed by code to install the definition, followed
by code to put the value of the <code>define</code> (which is the symbol <code>ok</code>)
into the target register, followed finally by the linkage code.  <code>Env</code> is
preserved around the computation of the value, because it is needed in order to
install the definition.  Because the linkage is <code>next</code>, there is no
linkage code in this case.  The skeleton of the compiled code is thus
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="pln">⟨</span><em><span class="pln">save </span><code><span class="pln">env</span></code><span class="pln"> </span><span class="kwd">if</span><span class="pln"> modified by code to compute value</span></em><span class="pln">⟩
  ⟨</span><em><span class="pln">compilation of definition value</span><span class="pun">,</span><span class="pln"> 
   target </span><code><span class="pln">val</span></code><span class="pun">,</span><span class="pln"> linkage </span><code><span class="pln">next</span></code></em><span class="pln">⟩
  ⟨</span><em><span class="pln">restore </span><code><span class="pln">env</span></code><span class="pln"> </span><span class="kwd">if</span><span class="pln"> saved above</span></em><span class="pln">⟩
  </span><span class="opn">(</span><span class="pln">perform </span><span class="opn">(</span><span class="pln">op define-variable!</span><span class="clo">)</span><span class="pln">
           </span><span class="opn">(</span><span class="pln">const factorial</span><span class="clo">)</span><span class="pln">
           </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">)</span><span class="pln">
           </span><span class="opn">(</span><span class="pln">reg env</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign val </span><span class="opn">(</span><span class="pln">const ok</span><span class="clo">))</span></pre></div>

<p>The expression that is to be compiled to produce the value for the variable
<code>factorial</code> is a <code>lambda</code> expression whose value is the procedure
that computes factorials.  <code>Compile</code> handles this by calling
<code>compile-lambda</code>, which compiles the procedure body, labels it as a new
entry point, and generates the instruction that will combine the procedure body
at the new entry point with the run-time environment and assign the result to
<code>val</code>.  The sequence then skips around the compiled procedure code, which
is inserted at this point.  The procedure code itself begins by extending the
procedure’s definition environment by a frame that binds the formal parameter
<code>n</code> to the procedure argument.  Then comes the actual procedure body.
Since this code for the value of the variable doesn’t modify the <code>env</code>
register, the optional <code>save</code> and <code>restore</code> shown above aren’t
generated.  (The procedure code at <code>entry2</code> isn’t executed at this point,
so its use of <code>env</code> is irrelevant.)  Therefore, the skeleton for the
compiled code becomes
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="pln">  </span><span class="opn">(</span><span class="pln">assign val </span><span class="opn">(</span><span class="pln">op make-compiled-procedure</span><span class="clo">)</span><span class="pln">
              </span><span class="opn">(</span><span class="pln">label entry2</span><span class="clo">)</span><span class="pln">
              </span><span class="opn">(</span><span class="pln">reg env</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">goto </span><span class="opn">(</span><span class="pln">label after-lambda1</span><span class="clo">))</span><span class="pln">
entry2
  </span><span class="opn">(</span><span class="pln">assign env </span><span class="opn">(</span><span class="pln">op compiled-procedure-env</span><span class="clo">)</span><span class="pln">
              </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign env </span><span class="opn">(</span><span class="pln">op extend-environment</span><span class="clo">)</span><span class="pln">
              </span><span class="opn">(</span><span class="pln">const </span><span class="opn">(</span><span class="pln">n</span><span class="clo">))</span><span class="pln">
              </span><span class="opn">(</span><span class="pln">reg argl</span><span class="clo">)</span><span class="pln">
              </span><span class="opn">(</span><span class="pln">reg env</span><span class="clo">))</span><span class="pln">
  ⟨</span><em><span class="pln">compilation of procedure body</span></em><span class="pln">⟩
after-lambda1
  </span><span class="opn">(</span><span class="pln">perform </span><span class="opn">(</span><span class="pln">op define-variable!</span><span class="clo">)</span><span class="pln">
           </span><span class="opn">(</span><span class="pln">const factorial</span><span class="clo">)</span><span class="pln">
           </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">reg env</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign val </span><span class="opn">(</span><span class="pln">const ok</span><span class="clo">))</span></pre></div>

<p>A procedure body is always compiled (by <code>compile-lambda-body</code>) as a
sequence with target <code>val</code> and linkage <code>return</code>.  The sequence in
this case consists of a single <code>if</code> expression:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">if</span><span class="pln"> </span><span class="opn">(</span><span class="pun">=</span><span class="pln"> n </span><span class="lit">1</span><span class="clo">)</span><span class="pln">
    </span><span class="lit">1</span><span class="pln">
    </span><span class="opn">(</span><span class="pun">*</span><span class="pln"> </span><span class="opn">(</span><span class="pln">factorial </span><span class="opn">(</span><span class="pun">-</span><span class="pln"> n </span><span class="lit">1</span><span class="clo">))</span><span class="pln"> n</span><span class="clo">))</span></pre></div>

<p><code>Compile-if</code> generates code that first computes the predicate (targeted to
<code>val</code>), then checks the result and branches around the true branch if the
predicate is false.  <code>Env</code> and <code>continue</code> are preserved around the
predicate code, since they may be needed for the rest of the <code>if</code>
expression.  Since the <code>if</code> expression is the final expression (and only
expression) in the sequence making up the procedure body, its target is
<code>val</code> and its linkage is <code>return</code>, so the true and false branches are
both compiled with target <code>val</code> and linkage <code>return</code>.  (That is, the
value of the conditional, which is the value computed by either of its
branches, is the value of the procedure.)
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="pln">⟨</span><em><span class="pln">save </span><code><span class="pln">continue</span></code><span class="pun">,</span><span class="pln"> </span><code><span class="pln">env</span></code><span class="pln"> </span><span class="kwd">if</span><span class="pln"> modified by 
 predicate </span><span class="kwd">and</span><span class="pln"> needed by branches</span></em><span class="pln">⟩
  ⟨</span><em><span class="pln">compilation of predicate</span><span class="pun">,</span><span class="pln"> 
   target </span><code><span class="pln">val</span></code><span class="pun">,</span><span class="pln"> linkage </span><code><span class="pln">next</span></code></em><span class="pln">⟩
  ⟨</span><em><span class="pln">restore </span><code><span class="pln">continue</span></code><span class="pun">,</span><span class="pln"> </span><code><span class="pln">env</span></code><span class="pln"> </span><span class="kwd">if</span><span class="pln"> saved above</span></em><span class="pln">⟩
  </span><span class="opn">(</span><span class="pln">test </span><span class="opn">(</span><span class="pln">op false?</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">branch </span><span class="opn">(</span><span class="pln">label false-branch4</span><span class="clo">))</span><span class="pln">
true-branch5
  ⟨</span><em><span class="pln">compilation of true branch</span><span class="pun">,</span><span class="pln"> 
   target </span><code><span class="pln">val</span></code><span class="pun">,</span><span class="pln"> linkage </span><code><span class="pln">return</span></code></em><span class="pln">⟩
false-branch4
  ⟨</span><em><span class="pln">compilation of false branch</span><span class="pun">,</span><span class="pln"> 
   target </span><code><span class="pln">val</span></code><span class="pun">,</span><span class="pln"> linkage </span><code><span class="pln">return</span></code></em><span class="pln">⟩
after-if3</span></pre></div>

<p>The predicate <code>(= n 1)</code> is a procedure call.  This looks up the operator
(the symbol <code>=</code>) and places this value in <code>proc</code>.  It then assembles
the arguments <code>1</code> and the value of <code>n</code> into <code>argl</code>.  Then it
tests whether <code>proc</code> contains a primitive or a compound procedure, and
dispatches to a primitive branch or a compound branch accordingly.  Both
branches resume at the <code>after-call</code> label.  The requirements to preserve
registers around the evaluation of the operator and operands don’t result in
any saving of registers, because in this case those evaluations don’t modify
the registers in question.
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="pln">  </span><span class="opn">(</span><span class="pln">assign proc </span><span class="opn">(</span><span class="pln">op lookup-variable-value</span><span class="clo">)</span><span class="pln">
               </span><span class="opn">(</span><span class="pln">const </span><span class="pun">=</span><span class="clo">)</span><span class="pln"> 
               </span><span class="opn">(</span><span class="pln">reg env</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign val </span><span class="opn">(</span><span class="pln">const </span><span class="lit">1</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign argl </span><span class="opn">(</span><span class="pln">op list</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign val </span><span class="opn">(</span><span class="pln">op lookup-variable-value</span><span class="clo">)</span><span class="pln">
              </span><span class="opn">(</span><span class="pln">const n</span><span class="clo">)</span><span class="pln">
              </span><span class="opn">(</span><span class="pln">reg env</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign argl </span><span class="opn">(</span><span class="pln">op </span><span class="kwd">cons</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">reg argl</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">test </span><span class="opn">(</span><span class="pln">op primitive-procedure?</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">branch </span><span class="opn">(</span><span class="pln">label primitive-branch17</span><span class="clo">))</span><span class="pln">
compiled-branch16
  </span><span class="opn">(</span><span class="pln">assign continue </span><span class="opn">(</span><span class="pln">label after-call15</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign val </span><span class="opn">(</span><span class="pln">op compiled-procedure-entry</span><span class="clo">)</span><span class="pln">
              </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">goto </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">))</span><span class="pln">
primitive-branch17
  </span><span class="opn">(</span><span class="pln">assign val </span><span class="opn">(</span><span class="pln">op apply-primitive-procedure</span><span class="clo">)</span><span class="pln">
              </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">)</span><span class="pln">
              </span><span class="opn">(</span><span class="pln">reg argl</span><span class="clo">))</span><span class="pln">
after-call15</span></pre></div>

<p>The true branch, which is the constant 1, compiles (with target <code>val</code> and
linkage <code>return</code>) to
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="pln">assign val </span><span class="opn">(</span><span class="pln">const </span><span class="lit">1</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="pln">goto </span><span class="opn">(</span><span class="pln">reg continue</span><span class="clo">))</span></pre></div>

<p>The code for the false branch is another procedure call, where the procedure
is the value of the symbol <code>*</code>, and the arguments are <code>n</code> and the
result of another procedure call (a call to <code>factorial</code>).  Each of these
calls sets up <code>proc</code> and <code>argl</code> and its own primitive and compound
branches.  <a href="#Figure-5_002e17">Figure 5.17</a> shows the complete compilation of the definition
of the <code>factorial</code> procedure.  Notice that the possible <code>save</code> and
<code>restore</code> of <code>continue</code> and <code>env</code> around the predicate, shown
above, are in fact generated, because these registers are modified by the
procedure call in the predicate and needed for the procedure call and the
<code>return</code> linkage in the branches.
</p>
<blockquote>
<p><strong><a id="Figure-5_002e17"></a>Figure 5.17:</strong> <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mo stretchy="false">↓<!-- ↓ --></mo>
</math> Compilation of the definition of the <code>factorial</code> procedure.
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="roman"><span class="com">;; construct the procedure and skip over code</span></span><span class="pln">
</span><span class="roman"><span class="com">;; for the procedure body</span></span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign val
          </span><span class="opn">(</span><span class="pln">op make-compiled-procedure</span><span class="clo">)</span><span class="pln"> 
          </span><span class="opn">(</span><span class="pln">label entry2</span><span class="clo">)</span><span class="pln"> 
          </span><span class="opn">(</span><span class="pln">reg env</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">goto </span><span class="opn">(</span><span class="pln">label after-lambda1</span><span class="clo">))</span><span class="pln">
entry2     </span><span class="roman"><span class="com">; calls to </span><code><span class="com">factorial</span></code><span class="com"> will enter here</span></span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign env 
          </span><span class="opn">(</span><span class="pln">op compiled-procedure-env</span><span class="clo">)</span><span class="pln">
          </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign env
          </span><span class="opn">(</span><span class="pln">op extend-environment</span><span class="clo">)</span><span class="pln"> 
          </span><span class="opn">(</span><span class="pln">const </span><span class="opn">(</span><span class="pln">n</span><span class="clo">))</span><span class="pln"> 
          </span><span class="opn">(</span><span class="pln">reg argl</span><span class="clo">)</span><span class="pln"> 
          </span><span class="opn">(</span><span class="pln">reg env</span><span class="clo">))</span><span class="pln">
</span><span class="roman"><span class="com">;; begin actual procedure body</span></span><span class="pln">
  </span><span class="opn">(</span><span class="pln">save continue</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">save env</span><span class="clo">)</span><span class="pln">
</span><span class="roman"><span class="com">;; compute </span><code><span class="com">(= n 1)</span></code></span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign proc 
          </span><span class="opn">(</span><span class="pln">op lookup-variable-value</span><span class="clo">)</span><span class="pln"> 
          </span><span class="opn">(</span><span class="pln">const </span><span class="pun">=</span><span class="clo">)</span><span class="pln"> 
          </span><span class="opn">(</span><span class="pln">reg env</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign val </span><span class="opn">(</span><span class="pln">const </span><span class="lit">1</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign argl </span><span class="opn">(</span><span class="pln">op list</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign val 
          </span><span class="opn">(</span><span class="pln">op lookup-variable-value</span><span class="clo">)</span><span class="pln"> 
          </span><span class="opn">(</span><span class="pln">const n</span><span class="clo">)</span><span class="pln"> 
          </span><span class="opn">(</span><span class="pln">reg env</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign argl </span><span class="opn">(</span><span class="pln">op </span><span class="kwd">cons</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">reg argl</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">test </span><span class="opn">(</span><span class="pln">op primitive-procedure?</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">branch </span><span class="opn">(</span><span class="pln">label primitive-branch17</span><span class="clo">))</span><span class="pln">
compiled-branch16
  </span><span class="opn">(</span><span class="pln">assign continue </span><span class="opn">(</span><span class="pln">label after-call15</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign val
          </span><span class="opn">(</span><span class="pln">op compiled-procedure-entry</span><span class="clo">)</span><span class="pln">
          </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">goto </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">))</span><span class="pln">
primitive-branch17
  </span><span class="opn">(</span><span class="pln">assign val 
          </span><span class="opn">(</span><span class="pln">op apply-primitive-procedure</span><span class="clo">)</span><span class="pln"> 
          </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">)</span><span class="pln"> 
          </span><span class="opn">(</span><span class="pln">reg argl</span><span class="clo">))</span><span class="pln">
after-call15   </span><span class="roman"><span class="com">; </span><code><span class="com">val</span></code><span class="com"> now contains result of </span><code><span class="com">(= n 1)</span></code></span><span class="pln">
  </span><span class="opn">(</span><span class="pln">restore env</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">restore continue</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">test </span><span class="opn">(</span><span class="pln">op false?</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">branch </span><span class="opn">(</span><span class="pln">label false-branch4</span><span class="clo">))</span><span class="pln">
true-branch5  </span><span class="roman"><span class="com">; return 1</span></span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign val </span><span class="opn">(</span><span class="pln">const </span><span class="lit">1</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">goto </span><span class="opn">(</span><span class="pln">reg continue</span><span class="clo">))</span><span class="pln">

false-branch4
</span><span class="roman"><span class="com">;; compute and return </span><code><span class="com">(* (factorial (- n 1)) n)</span></code></span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign proc 
          </span><span class="opn">(</span><span class="pln">op lookup-variable-value</span><span class="clo">)</span><span class="pln"> 
          </span><span class="opn">(</span><span class="pln">const </span><span class="pun">*</span><span class="clo">)</span><span class="pln"> 
          </span><span class="opn">(</span><span class="pln">reg env</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">save continue</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">save proc</span><span class="clo">)</span><span class="pln">   </span><span class="roman"><span class="com">; save </span><code><span class="com">*</span></code></span><span class="com"> procedure</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign val 
          </span><span class="opn">(</span><span class="pln">op lookup-variable-value</span><span class="clo">)</span><span class="pln"> 
          </span><span class="opn">(</span><span class="pln">const n</span><span class="clo">)</span><span class="pln"> 
          </span><span class="opn">(</span><span class="pln">reg env</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign argl </span><span class="opn">(</span><span class="pln">op list</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">save argl</span><span class="clo">)</span><span class="pln">   </span><span class="roman"><span class="com">; save partial argument list for </span><code><span class="com">*</span></code></span><span class="pln">
</span><span class="roman"><span class="com">;; compute </span><code><span class="com">(factorial (- n 1))</span></code><span class="com">,</span></span><span class="com"> </span><span class="pln">
</span><span class="roman"><span class="com">;; which is the other argument for </span><code><span class="com">*</span></code></span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign proc
          </span><span class="opn">(</span><span class="pln">op lookup-variable-value</span><span class="clo">)</span><span class="pln"> 
          </span><span class="opn">(</span><span class="pln">const factorial</span><span class="clo">)</span><span class="pln"> 
          </span><span class="opn">(</span><span class="pln">reg env</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">save proc</span><span class="clo">)</span><span class="pln">  </span><span class="roman"><span class="com">; save </span><code><span class="com">factorial</span></code><span class="com"> procedure</span></span><span class="pln">
</span><span class="roman"><span class="com">;; compute </span><code><span class="com">(- n 1)</span></code><span class="com">, which is the argument for </span><code><span class="com">factorial</span></code></span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign proc 
          </span><span class="opn">(</span><span class="pln">op lookup-variable-value</span><span class="clo">)</span><span class="pln">
          </span><span class="opn">(</span><span class="pln">const </span><span class="pun">-</span><span class="clo">)</span><span class="pln"> 
          </span><span class="opn">(</span><span class="pln">reg env</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign val </span><span class="opn">(</span><span class="pln">const </span><span class="lit">1</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign argl </span><span class="opn">(</span><span class="pln">op list</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign val 
          </span><span class="opn">(</span><span class="pln">op lookup-variable-value</span><span class="clo">)</span><span class="pln"> 
          </span><span class="opn">(</span><span class="pln">const n</span><span class="clo">)</span><span class="pln"> 
          </span><span class="opn">(</span><span class="pln">reg env</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign argl </span><span class="opn">(</span><span class="pln">op </span><span class="kwd">cons</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">reg argl</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">test </span><span class="opn">(</span><span class="pln">op primitive-procedure?</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">branch </span><span class="opn">(</span><span class="pln">label primitive-branch8</span><span class="clo">))</span><span class="pln">
compiled-branch7
  </span><span class="opn">(</span><span class="pln">assign continue </span><span class="opn">(</span><span class="pln">label after-call6</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign val
          </span><span class="opn">(</span><span class="pln">op compiled-procedure-entry</span><span class="clo">)</span><span class="pln">
          </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">goto </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">))</span><span class="pln">
primitive-branch8
  </span><span class="opn">(</span><span class="pln">assign val 
          </span><span class="opn">(</span><span class="pln">op apply-primitive-procedure</span><span class="clo">)</span><span class="pln"> 
          </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">)</span><span class="pln"> 
          </span><span class="opn">(</span><span class="pln">reg argl</span><span class="clo">))</span><span class="pln">

after-call6   </span><span class="roman"><span class="com">; </span><code><span class="com">val</span></code><span class="com"> now contains result of </span><code><span class="com">(- n 1)</span></code></span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign argl </span><span class="opn">(</span><span class="pln">op list</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">restore proc</span><span class="clo">)</span><span class="pln"> </span><span class="roman"><span class="com">; restore </span><code><span class="com">factorial</span></code></span><span class="pln">
</span><span class="roman"><span class="com">;; apply </span><code><span class="com">factorial</span></code></span><span class="pln">
  </span><span class="opn">(</span><span class="pln">test </span><span class="opn">(</span><span class="pln">op primitive-procedure?</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">branch </span><span class="opn">(</span><span class="pln">label primitive-branch11</span><span class="clo">))</span><span class="pln">
compiled-branch10
  </span><span class="opn">(</span><span class="pln">assign continue </span><span class="opn">(</span><span class="pln">label after-call9</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign val
          </span><span class="opn">(</span><span class="pln">op compiled-procedure-entry</span><span class="clo">)</span><span class="pln">
          </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">goto </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">))</span><span class="pln">
primitive-branch11
  </span><span class="opn">(</span><span class="pln">assign val 
          </span><span class="opn">(</span><span class="pln">op apply-primitive-procedure</span><span class="clo">)</span><span class="pln"> 
          </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">)</span><span class="pln"> 
          </span><span class="opn">(</span><span class="pln">reg argl</span><span class="clo">))</span><span class="pln">
after-call9      </span><span class="roman"><span class="com">; </span><code><span class="com">val</span></code><span class="com"> now contains result</span></span><span class="com"> </span><span class="pln">
                 </span><span class="roman"><span class="com">; of </span><code><span class="com">(factorial (- n 1))</span></code></span><span class="pln">
  </span><span class="opn">(</span><span class="pln">restore argl</span><span class="clo">)</span><span class="pln"> </span><span class="roman"><span class="com">; restore partial argument list for </span><code><span class="com">*</span></code></span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign argl </span><span class="opn">(</span><span class="pln">op </span><span class="kwd">cons</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">reg argl</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">restore proc</span><span class="clo">)</span><span class="pln"> </span><span class="roman"><span class="com">; restore </span><code><span class="com">*</span></code></span><span class="pln">
  </span><span class="opn">(</span><span class="pln">restore continue</span><span class="clo">)</span><span class="pln">
</span><span class="roman"><span class="com">;; apply </span><code><span class="com">*</span></code><span class="com"> and return its value</span></span><span class="pln">
  </span><span class="opn">(</span><span class="pln">test </span><span class="opn">(</span><span class="pln">op primitive-procedure?</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">branch </span><span class="opn">(</span><span class="pln">label primitive-branch14</span><span class="clo">))</span><span class="pln">
compiled-branch13
</span><span class="roman"><span class="com">;; note that a compound procedure here</span></span><span class="pln">
</span><span class="roman"><span class="com">;; is called tail-recursively</span></span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign val
          </span><span class="opn">(</span><span class="pln">op compiled-procedure-entry</span><span class="clo">)</span><span class="pln">
          </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">goto </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">))</span><span class="pln">
primitive-branch14
  </span><span class="opn">(</span><span class="pln">assign val 
          </span><span class="opn">(</span><span class="pln">op apply-primitive-procedure</span><span class="clo">)</span><span class="pln"> 
          </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">)</span><span class="pln"> 
          </span><span class="opn">(</span><span class="pln">reg argl</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">goto </span><span class="opn">(</span><span class="pln">reg continue</span><span class="clo">))</span><span class="pln">
after-call12
after-if3
after-lambda1
</span><span class="roman"><span class="com">;; assign the procedure to the variable </span><code><span class="com">factorial</span></code></span><span class="pln">
  </span><span class="opn">(</span><span class="pln">perform </span><span class="opn">(</span><span class="pln">op define-variable!</span><span class="clo">)</span><span class="pln"> 
           </span><span class="opn">(</span><span class="pln">const factorial</span><span class="clo">)</span><span class="pln"> 
           </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">)</span><span class="pln"> 
           </span><span class="opn">(</span><span class="pln">reg env</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign val </span><span class="opn">(</span><span class="pln">const ok</span><span class="clo">))</span></pre></div>
</blockquote>

<blockquote>
<p><strong><a id="Exercise-5_002e33"></a>Exercise 5.33:</strong> Consider the following definition
of a factorial procedure, which is slightly different from the one given above:
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">factorial-alt n</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> </span><span class="opn">(</span><span class="pun">=</span><span class="pln"> n </span><span class="lit">1</span><span class="clo">)</span><span class="pln">
      </span><span class="lit">1</span><span class="pln">
      </span><span class="opn">(</span><span class="pun">*</span><span class="pln"> n </span><span class="opn">(</span><span class="pln">factorial-alt </span><span class="opn">(</span><span class="pun">-</span><span class="pln"> n </span><span class="lit">1</span><span class="clo">)))))</span></pre></div>

<p>Compile this procedure and compare the resulting code with that produced for
<code>factorial</code>.  Explain any differences you find.  Does either program
execute more efficiently than the other?
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-5_002e34"></a>Exercise 5.34:</strong> Compile the iterative factorial
procedure
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">factorial n</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="kwd">define</span><span class="pln"> </span><span class="opn">(</span><span class="pln">iter product counter</span><span class="clo">)</span><span class="pln">
    </span><span class="opn">(</span><span class="kwd">if</span><span class="pln"> </span><span class="opn">(</span><span class="pun">&gt;</span><span class="pln"> counter n</span><span class="clo">)</span><span class="pln">
        product
        </span><span class="opn">(</span><span class="pln">iter </span><span class="opn">(</span><span class="pun">*</span><span class="pln"> counter product</span><span class="clo">)</span><span class="pln">
              </span><span class="opn">(</span><span class="pun">+</span><span class="pln"> counter </span><span class="lit">1</span><span class="clo">))))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">iter </span><span class="lit">1</span><span class="pln"> </span><span class="lit">1</span><span class="clo">))</span></pre></div>

<p>Annotate the resulting code, showing the essential difference between the code
for iterative and recursive versions of <code>factorial</code> that makes one process
build up stack space and the other run in constant stack space.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-5_002e35"></a>Exercise 5.35:</strong> What expression was compiled to
produce the code shown in <a href="#Figure-5_002e18">Figure 5.18</a>?
</p></blockquote>

<blockquote>
<p><strong><a id="Figure-5_002e18"></a>Figure 5.18:</strong> <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mo stretchy="false">↓<!-- ↓ --></mo>
</math> An example of compiler output.  See
<a href="#Exercise-5_002e35">Exercise 5.35</a>.
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="pln">assign val </span><span class="opn">(</span><span class="pln">op make-compiled-procedure</span><span class="clo">)</span><span class="pln"> 
            </span><span class="opn">(</span><span class="pln">label entry16</span><span class="clo">)</span><span class="pln"> 
            </span><span class="opn">(</span><span class="pln">reg env</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">goto </span><span class="opn">(</span><span class="pln">label after-lambda15</span><span class="clo">))</span><span class="pln">
entry16
  </span><span class="opn">(</span><span class="pln">assign env </span><span class="opn">(</span><span class="pln">op compiled-procedure-env</span><span class="clo">)</span><span class="pln">
              </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign env </span><span class="opn">(</span><span class="pln">op extend-environment</span><span class="clo">)</span><span class="pln"> 
              </span><span class="opn">(</span><span class="pln">const </span><span class="opn">(</span><span class="pln">x</span><span class="clo">))</span><span class="pln"> 
              </span><span class="opn">(</span><span class="pln">reg argl</span><span class="clo">)</span><span class="pln"> 
              </span><span class="opn">(</span><span class="pln">reg env</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign proc </span><span class="opn">(</span><span class="pln">op lookup-variable-value</span><span class="clo">)</span><span class="pln"> 
               </span><span class="opn">(</span><span class="pln">const </span><span class="pun">+</span><span class="clo">)</span><span class="pln"> 
               </span><span class="opn">(</span><span class="pln">reg env</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">save continue</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">save proc</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">save env</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign proc </span><span class="opn">(</span><span class="pln">op lookup-variable-value</span><span class="clo">)</span><span class="pln"> 
               </span><span class="opn">(</span><span class="pln">const g</span><span class="clo">)</span><span class="pln"> 
               </span><span class="opn">(</span><span class="pln">reg env</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">save proc</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign proc </span><span class="opn">(</span><span class="pln">op lookup-variable-value</span><span class="clo">)</span><span class="pln"> 
               </span><span class="opn">(</span><span class="pln">const </span><span class="pun">+</span><span class="clo">)</span><span class="pln"> 
               </span><span class="opn">(</span><span class="pln">reg env</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign val </span><span class="opn">(</span><span class="pln">const </span><span class="lit">2</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign argl </span><span class="opn">(</span><span class="pln">op list</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign val </span><span class="opn">(</span><span class="pln">op lookup-variable-value</span><span class="clo">)</span><span class="pln">
              </span><span class="opn">(</span><span class="pln">const x</span><span class="clo">)</span><span class="pln"> 
              </span><span class="opn">(</span><span class="pln">reg env</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign argl </span><span class="opn">(</span><span class="pln">op </span><span class="kwd">cons</span><span class="clo">)</span><span class="pln">
               </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">)</span><span class="pln">
               </span><span class="opn">(</span><span class="pln">reg argl</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">test </span><span class="opn">(</span><span class="pln">op primitive-procedure?</span><span class="clo">)</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">branch </span><span class="opn">(</span><span class="pln">label primitive-branch19</span><span class="clo">))</span><span class="pln">
compiled-branch18
  </span><span class="opn">(</span><span class="pln">assign continue </span><span class="opn">(</span><span class="pln">label after-call17</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign val
          </span><span class="opn">(</span><span class="pln">op compiled-procedure-entry</span><span class="clo">)</span><span class="pln">
          </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">goto </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">))</span><span class="pln">
primitive-branch19
  </span><span class="opn">(</span><span class="pln">assign val
          </span><span class="opn">(</span><span class="pln">op apply-primitive-procedure</span><span class="clo">)</span><span class="pln">
          </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">)</span><span class="pln"> 
          </span><span class="opn">(</span><span class="pln">reg argl</span><span class="clo">))</span><span class="pln">
after-call17
  </span><span class="opn">(</span><span class="pln">assign argl </span><span class="opn">(</span><span class="pln">op list</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">restore proc</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">test </span><span class="opn">(</span><span class="pln">op primitive-procedure?</span><span class="clo">)</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">branch </span><span class="opn">(</span><span class="pln">label primitive-branch22</span><span class="clo">))</span><span class="pln">
compiled-branch21
  </span><span class="opn">(</span><span class="pln">assign continue </span><span class="opn">(</span><span class="pln">label after-call20</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign val
          </span><span class="opn">(</span><span class="pln">op compiled-procedure-entry</span><span class="clo">)</span><span class="pln">
          </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">goto </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">))</span><span class="pln">
primitive-branch22
  </span><span class="opn">(</span><span class="pln">assign val 
          </span><span class="opn">(</span><span class="pln">op apply-primitive-procedure</span><span class="clo">)</span><span class="pln"> 
          </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">)</span><span class="pln"> 
          </span><span class="opn">(</span><span class="pln">reg argl</span><span class="clo">))</span><span class="pln">
after-call20
  </span><span class="opn">(</span><span class="pln">assign argl </span><span class="opn">(</span><span class="pln">op list</span><span class="clo">)</span><span class="pln"> </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">restore env</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign val
          </span><span class="opn">(</span><span class="pln">op lookup-variable-value</span><span class="clo">)</span><span class="pln"> 
          </span><span class="opn">(</span><span class="pln">const x</span><span class="clo">)</span><span class="pln"> 
          </span><span class="opn">(</span><span class="pln">reg env</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign argl
          </span><span class="opn">(</span><span class="pln">op </span><span class="kwd">cons</span><span class="clo">)</span><span class="pln">
          </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">)</span><span class="pln">
          </span><span class="opn">(</span><span class="pln">reg argl</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">restore proc</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">restore continue</span><span class="clo">)</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">test </span><span class="opn">(</span><span class="pln">op primitive-procedure?</span><span class="clo">)</span><span class="pln">
        </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">branch </span><span class="opn">(</span><span class="pln">label primitive-branch25</span><span class="clo">))</span><span class="pln">
compiled-branch24
  </span><span class="opn">(</span><span class="pln">assign val </span><span class="opn">(</span><span class="pln">op compiled-procedure-entry</span><span class="clo">)</span><span class="pln">
              </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">goto </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">))</span><span class="pln">
primitive-branch25
  </span><span class="opn">(</span><span class="pln">assign val 
          </span><span class="opn">(</span><span class="pln">op apply-primitive-procedure</span><span class="clo">)</span><span class="pln">
          </span><span class="opn">(</span><span class="pln">reg proc</span><span class="clo">)</span><span class="pln"> 
          </span><span class="opn">(</span><span class="pln">reg argl</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">goto </span><span class="opn">(</span><span class="pln">reg continue</span><span class="clo">))</span><span class="pln">
after-call23
after-lambda15
  </span><span class="opn">(</span><span class="pln">perform </span><span class="opn">(</span><span class="pln">op define-variable!</span><span class="clo">)</span><span class="pln"> 
           </span><span class="opn">(</span><span class="pln">const f</span><span class="clo">)</span><span class="pln"> 
           </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">)</span><span class="pln"> 
           </span><span class="opn">(</span><span class="pln">reg env</span><span class="clo">))</span><span class="pln">
  </span><span class="opn">(</span><span class="pln">assign val </span><span class="opn">(</span><span class="pln">const ok</span><span class="clo">))</span></pre></div>
</blockquote>

<blockquote>
<p><strong><a id="Exercise-5_002e36"></a>Exercise 5.36:</strong> What order of evaluation does our
compiler produce for operands of a combination?  Is it left-to-right,
right-to-left, or some other order?  Where in the compiler is this order
determined?  Modify the compiler so that it produces some other order of
evaluation.  (See the discussion of order of evaluation for the
explicit-control evaluator in <a href="5_002e4_002e1.xhtml#g_t5_002e4_002e1">5.4.1</a>.)  How does changing the
order of operand evaluation affect the efficiency of the code that constructs
the argument list?
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-5_002e37"></a>Exercise 5.37:</strong> One way to understand the
compiler’s <code>preserving</code> mechanism for optimizing stack usage is to see
what extra operations would be generated if we did not use this idea.  Modify
<code>preserving</code> so that it always generates the <code>save</code> and
<code>restore</code> operations.  Compile some simple expressions and identify the
unnecessary stack operations that are generated.  Compare the code to that
generated with the <code>preserving</code> mechanism intact.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-5_002e38"></a>Exercise 5.38:</strong> Our compiler is clever about
avoiding unnecessary stack operations, but it is not clever at all when it
comes to compiling calls to the primitive procedures of the language in terms
of the primitive operations supplied by the machine.  For example, consider how
much code is compiled to compute <code>(+ a 1)</code>: The code sets up an argument
list in <code>argl</code>, puts the primitive addition procedure (which it finds by
looking up the symbol <code>+</code> in the environment) into <code>proc</code>, and tests
whether the procedure is primitive or compound.  The compiler always generates
code to perform the test, as well as code for primitive and compound branches
(only one of which will be executed).  We have not shown the part of the
controller that implements primitives, but we presume that these instructions
make use of primitive arithmetic operations in the machine’s data paths.
Consider how much less code would be generated if the compiler could
<a id="index-open_002dcode"></a>
<em>open-code</em> primitives—that is, if it could generate code to directly
use these primitive machine operations.  The expression <code>(+ a 1)</code> might be
compiled into something as simple as<a class="footnote_link" id="DOCF328" href="#FOOT328"><sup>328</sup></a>
</p>
<div class="lisp">
<pre class="lisp prettyprinted" style=""><span class="opn">(</span><span class="pln">assign val </span><span class="opn">(</span><span class="pln">op lookup-variable-value</span><span class="clo">)</span><span class="pln"> 
            </span><span class="opn">(</span><span class="pln">const a</span><span class="clo">)</span><span class="pln"> 
            </span><span class="opn">(</span><span class="pln">reg env</span><span class="clo">))</span><span class="pln">
</span><span class="opn">(</span><span class="pln">assign val </span><span class="opn">(</span><span class="pln">op </span><span class="pun">+</span><span class="clo">)</span><span class="pln">
            </span><span class="opn">(</span><span class="pln">reg val</span><span class="clo">)</span><span class="pln">
            </span><span class="opn">(</span><span class="pln">const </span><span class="lit">1</span><span class="clo">))</span></pre></div>

<p>In this exercise we will extend our compiler to support open coding of selected
primitives.  Special-purpose code will be generated for calls to these
primitive procedures instead of the general procedure-application code.  In
order to support this, we will augment our machine with special argument
registers <code>arg1</code> and <code>arg2</code>.  The primitive arithmetic operations of
the machine will take their inputs from <code>arg1</code> and <code>arg2</code>. The
results may be put into <code>val</code>, <code>arg1</code>, or <code>arg2</code>.
</p>
<p>The compiler must be able to recognize the application of an open-coded
primitive in the source program.  We will augment the dispatch in the
<code>compile</code> procedure to recognize the names of these primitives in addition
to the reserved words (the special forms) it currently
recognizes.<a class="footnote_link" id="DOCF329" href="#FOOT329"><sup>329</sup></a> For each special
form our compiler has a code generator.  In this exercise we will construct a
family of code generators for the open-coded primitives.
</p>
<ol>
<li> The open-coded primitives, unlike the special forms, all need their operands
evaluated.  Write a code generator <code>spread-arguments</code> for use by all the
open-coding code generators.  <code>Spread-arguments</code> should take an operand
list and compile the given operands targeted to successive argument registers.
Note that an operand may contain a call to an open-coded primitive, so argument
registers will have to be preserved during operand evaluation.

</li><li> For each of the primitive procedures <code>=</code>, <code>*</code>, <code>-</code>, and
<code>+</code>, write a code generator that takes a combination with that operator,
together with a target and a linkage descriptor, and produces code to spread
the arguments into the registers and then perform the operation targeted to the
given target with the given linkage.  You need only handle expressions with two
operands.  Make <code>compile</code> dispatch to these code generators.

</li><li> Try your new compiler on the <code>factorial</code> example.  Compare the resulting
code with the result produced without open coding.

</li><li> Extend your code generators for <code>+</code> and <code>*</code> so that they can handle
expressions with arbitrary numbers of operands.  An expression with more than
two operands will have to be compiled into a sequence of operations, each with
only two inputs.

</li></ol>
</blockquote>

<div class="footnote">
<hr />

<h4 class="footnotes-heading">Footnotes</h4>

<div id="FOOT328"><p><a class="footnote_backlink" href="#DOCF328"><sup>328</sup></a>
We have used the same symbol
<code>+</code> here to denote both the source-language procedure and the machine
operation.  In general there will not be a one-to-one correspondence between
primitives of the source language and primitives of the machine.</p>
</div>
<div id="FOOT329"><p><a class="footnote_backlink" href="#DOCF329"><sup>329</sup></a>
Making the primitives into reserved words is in general a
bad idea, since a user cannot then rebind these names to different procedures.
Moreover, if we add reserved words to a compiler that is in use, existing
programs that define procedures with these names will stop working.  See
<a href="5_002e5_002e6.xhtml#Exercise-5_002e44">Exercise 5.44</a> for ideas on how to avoid this problem.</p>
</div>
</div>
<hr />
<nav class="header">
<p>
Next: <a href="5_002e5_002e6.xhtml#g_t5_002e5_002e6" accesskey="n" rel="next">5.5.6</a>, Previous: <a href="5_002e5_002e4.xhtml#g_t5_002e5_002e4" accesskey="p" rel="prev">5.5.4</a>, Up: <a href="5_002e5.xhtml#g_t5_002e5" accesskey="u" rel="prev">5.5</a>   [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>


</section>
</body>
</html>